;TO DO:

;1. MAKE INITSPRT ADD BASESPRITE TO RECOMMENDED BASE SPRITE SO THAT WHEN
;THERE AREN'T TOO MANY ON A LINE IT GOES BACK WHERE IT BELONGS PRIORITY WISE.

;THIS ASSEMBLY CONTAINS LOW LEVEL SUBROUTINES FOR THE KUNGFU STATE MACHINE.
;THEY ARE A REDUCED VERSION OF THE STANDARD COLOR DREAMS SUBS.ASM FOR
;THE NINTENDO.  THEY ONLY SUPPORT 2 HIGH SPRITES AND NO VERTICAL SCROLLING
;AT ALL IS SUPPORTED.
;
;DEFINE( ROMVER,-1)		;REMOVE COMMENT TO MAKE ROM VERSION.
ROMVER = -1
;DEFINE( BLOCKMODE,-1)		;REMOVE COMMENT FOR BLOCK MODE.  LEAVE FOR
				;STRIP MODE.
;DEFINE( INDIRECT,-1)		;REMOVE COMMENT TO MAKE BLOCK MODE RUN
				;WITH 1 BYTE BLOCK NUMBER TABLES.
;DEFINE( SOLFILL,-1)		;REMOVE COMMENT TO MAKE AREAS OUTSIDE 
				;BACKGROUND BE SOLID.

.import BOOT, NMI, LDC35
;*************** ROM PAGE 2 SUBROUTINES AND DATA AREA ************
;
.include "ScoutDEF.h"
;.COMMAND -O			;ENABLE MULTIPLE OUTPUT FILES
;.SEGMENT .MEMORY,$8000		;DEFINE SEGMENT .MEMORY, LOAD AT 8000H
;.MEMORY				;ACTIVATE SEGMENT .MEMORY
.org $0
.segment "BANK_01"
.include "YOURBACK.ASM";INCLUDE( YOURBACK.ASM)	;BACKGROUNDS FROM ND.EXE
.include "YOURSND.ASM";INCLUDE( YOURSND.ASM)	;SOUND DATA TO PUT IN THE SECOND ROM PAGE
.include "YOURCODE.ASM";INCLUDE( YOURCODE.ASM)	;ENTITY LANGUAGE CODE FOR THE SECOND PAGE

;Where does this Junk Data come from?
;It's repeated data from BANK_00 - Evenball
.incbin "JunkData.bin"

;IFDEF( `BLOCKMODE', `
;.ORG	32160	;(7DA0H)
;	', ` 
;.ORG	32224	;(7DE0H)
;	' )
;THIS TABLE HAS THE LENGTH OF BYTES THAT EACH COMMAND TAKES.  WE USE
;THIS TO FETCH DATA AND INCREMENT THE POINTER PRIOR TO THE COMMAND.
;THE LENGTH HERE IS THE LENGTH INCLUDING THE COMMAND BYTE ITSELF.
.byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;Padded by evenball
CMDLEN:
	.byte	2,5,4,4,3,4,3,2,3,2,2,3,3,2,2,2		;CMD00
	.byte	2,1,1,1,1,4,3,1,1,1,2,4,3,3,2,5		;CMD10
	.byte	3,1,4,4,4,5,1,3,4,2,4,4,2,3,1,2		;CMD20
	.byte	2,9,2,1,1,6,5,4,4,6,3,3,5,3,3,2		;CMD30
	.byte	3,5,3,2,1,4,2,2,2,3,2,4,2,3,3,2		;CMD40
	.byte	3,4,4,5,3,2,2,3,4,3,2,2,2,2,2,4		;CMD50 
	.byte	4,5,4,3,2,3,4,6,1,5,2,3,3,5,7,6		;CMD60
	.byte	10,2,2,2,5,4,2,7,3,1,2,5,2,3,1,7	;CMD70
	.byte	3,3,5,3,2,2,2,2,2,3,2,3,1,2,2,1		;CMD80
 	.byte	3,3,4,4,4,1,3,2,2,1,3,3,2,2,5,5		;CMD90
 	.byte	5,2,1,5,2,1,3,1,1,3,1,1,1,1,1,1		;CMDA0

;THIS CODE IS USED TO FILL THE COMMAND BUFFER FROM THE COMMAND STREAM
;OR TO GET DATA FROM ONE OF THE COMMANDS.  ITS CALLED SINGLE THREADLY 
;BY MOVEENEMY IN KUNGFU.ASM OUTSIDE NMI.  THE DATA IS POINTED TO BY (ENEMYPTR) 
;EXCEPT THAT THE HIGH BIT IS NOT SET IF THE DATA IS IN THE SECOND PAGE.  
;CALL HERE WITH (ENEMYPTR) POINTING TO THE COMMAND BYTE OR DATA.  SET
;X=0 IF YOU ARE FETCHING A COMMAND (IT WILL DETERMINE HOW MUCH DATA)
;AND X<>0 TO FETCH JUST DATA FOR LENGTH X (16 MAX!). SUBSVAR1 RETURNS 
;THE LENGTH OF DATA WE GOT WHICH WILL ALWAYS BE X IF X<>0.

FILLCBUF:
	LDA	a:ENEMYPTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA			;SAVE IT
	BMI	XFCB15
	ORA	#128
	STA	a:ENEMYPTR+1	;IN EITHER CASE, MAKE IT BE IN ROM
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XFCB15:	LDY	#0	
	CPX	#0
	BNE	XFCB17
	LDA	(ENEMYPTR),Y
	TAX			;GET THE COMMAND BYTE
	LDA	CMDLEN+$8000,X	;GET THE COUNT FOR THIS COMMAND
	TAX
XFCB17:	STX	a:SUBSVAR1	;RETURN THE COUNT BYTE
XFCB20:	LDA	(ENEMYPTR),Y
	STA	CMDBUF,Y	;FETCH LENGTH REQUESTED
	INY
	DEX
	BNE	XFCB20
	PLA
	BMI	XFCB30
	STA	a:ENEMYPTR+1	;RESTORE ORIGINAL BANK SPECIFICATION
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XFCB30:	RTS	

;THIS SUB IS USED TO FETCH DATA FROM EITHER PAGE INTO THE STACK AREA.
;YOU LOWER YOUR STACK POINTER FAR ENOUGH DOWN TO HOLD THE DATA
;AND THEN WHEN DONE MOVE IT BACK UP AND THUS THIS ROUTINE IS GOOD FROM
;BOTH INSIDE AND OUTSIDE NMI.
;
;ON ENTRY, (SUBSVAR1) SHOULD POINT TO THE DATA TO FETCH.  BIT H80 IS SET 
;IF ITS IN THE LOW PAGE, NOT SET IF IN THE HIGH.  LOAD SUBSVAR3 WITH THE COUNT 
;TO FETCH.  ON RETURN, YOUR DATA IS AT (SP)+1.  NO OTHER VARIABLES ARE CHANGED.

;FILLSTACK:
	TSX
	INX
	INX
	INX			;GET PLACE TO PUT THE DATA
	LDA	a:SUBSVAR2	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	XFSK10
	ORA	#128
	STA	a:SUBSVAR2
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XFSK10:	LDY	#0	
XFSK20:	LDA	(SUBSVAR1),Y
	STA	256,X			
	INY
	INX
	DEC	a:SUBSVAR3
	BNE	XFSK20
	PLA
	BMI	XFSK25
	STA	a:SUBSVAR2
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XFSK25:	RTS	

;THIS SUB IS USED TO FETCH COLUMN DATA FROM A BACKGROUND BLOCK DIRECTLY
;INTO SCNBUF.  ON ENTRY:
;(NMI_PTR) POINTS TO THE FIRST BYTE TO FETCH.  BIT 8000H SET IF LOW PAGE,
;  	OFF IF HIGH PAGE (THAT BIT IS PRESERVED ON RETURN).
;TMP_NMI1 HAS THE COUNT TO FETCH.  
;X HAS THE PLACE TO PUT IT INTO SCNBUF. 
;TMP_NMI2 HAS THE WIDTH OF THE BACKGROUND IN COLUMNS (THE AMOUNT
;	TO SKIP AFTER EACH FETCH).  
;
;ON RETURN:  THE DATA IS IN SCNBUF, X IS UPDATED AND SO IS NMI_PTR.

;LOADCOL:

	LDA	a:NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	XLDC15
	ORA	#128
	STA	a:NMI_PTR+1
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XLDC15:	CLC
	LDY	#0
XLDC20:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCNBUF,X	;QUE IT UP
	INX
	LDA	a:NMI_PTR
	ADC	TMP_NMI2	;SKIP TO NEXT ROW IN DATA
	STA	a:NMI_PTR
	BCC	XLDC30
	INC	a:NMI_PTR+1
	CLC
XLDC30:	DEC	TMP_NMI1
	BNE	XLDC20

XLDC35:	PLA
	BMI	XLDC40
	LDA	a:NMI_PTR+1
	EOR	#128
	STA	a:NMI_PTR+1
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XLDC40:	RTS	

;THIS ROUTINE IS USED TO WRITE PALETTE DATA INTO A SCREEN BUFFER IN
;COLUMN FORMAT.  IT DIFFERS DEPENDING ON BLOCK OR STRIP MODE.

;IN STRIP MODE, EACH PALETTE BYTE MUST BE INDIVIDUALLY
;ADDRESSED.  THIS ROUTINE WILL DO THAT WHILE FETCHING AND STORING DIRECTLY
;INTO SCNBUF.  ON ENTRY:
;TMP_NMI4:TMP_NMI3 POINTS TO THE PLACE TO PUT THE DATA IN THE VIDEO BUFFER.
;(NMI_PTR) POINTS TO THE PALETTE BYTE TO PUT THERE.
;TMP_NMI1 HAS THE COUNT OF PALETTE BYTES TO PUT THERE.
;TMP_NMI2 HAS THE WIDTH OF THE BACKGROUND'S PALETTE ARRAY.
;X HAS PLACE IN SCNBUF TO PUT THE DATA.

;IN BLOCK MODE THE DATA MUST BE SHIFTED BEFORE ADDRESSING AND THIS ROUTINE
;SIMPLY FETCHES IT INTO THE LOCATION YOU SPECIFY IN MEMORY.  IT FETCHES
;1 OR 2 BYTES EACH CALL SINCE THE BACKGROUNDS ARE ONLY 2 PALETTE BYTES
;HIGH.  ON ENTRY:
;(NMI_PTR) POINTS TO THE PALETTE BYTE TO GET FIRST
;TMP_NMI1 HAS THE COUNT OF PALETTE BYTES TO GET, 1 OR 2.  
;X HAS THE PLACE IN A 9 BYTE BUFFER STARTING AT TMP_NMI6 AT WHICH TO PUT
; THE DATA.  X IS UPDATED.

;LOADPCOL:

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDY	#0
	LDA	a:NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	XLPC14
	ORA	#128
	STA	a:NMI_PTR+1	;IN EITHER CASE, MAKE IT BE IN ROM
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XLPC14:	LDY	#0
XLPC15:	LDA	(NMI_PTR),Y	;GET THE BYTE
	STA	TMP_NMI6,X	;QUE IT UP
	INX
	DEC	TMP_NMI1
	BEQ	XLDC35		;SHARE SOME ENDING CODE
	LDY	#2
	JMP	LPC15
.endif	
.ifndef BLOCKMODE;	', `

	LDA	a:NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	XLPC14
	ORA	#128
	STA	a:NMI_PTR+1	;IN EITHER CASE, MAKE IT BE IN ROM
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XLPC14:	LDY	#0
XLPC15:	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI4
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI3
	STA	SCNBUF,X
	INX
	LDA	#1		;WE ALWAYS JUST QUE 1 IN THIS CASE
	STA	SCNBUF,X
	INX

	LDA	(NMI_PTR),Y	;GET THE BYTE
	STA	SCNBUF,X		;QUE IT UP
	INX
	TYA
	CLC
	ADC	TMP_NMI2	;UPDATE INDEX WITHIN OUR DATA
	TAY
	BCC	XLPC20
	INC	a:NMI_PTR+1

;WRAP THE PALETTE RAM INDEX.  WE JUST NEED TO WRAP AROUND IN THIS BUFFER.

XLPC20:	LDA	TMP_NMI3
	CLC
	ADC	#8		;SKIP TO NEXT PALETTE ROW
	STA	TMP_NMI3

 	DEC	TMP_NMI1
 	BNE	XLPC15
	JMP	LDC35		;SHARE A HAPPY ENDING	

.endif;	' )

;THIS SUB IS USED TO FETCH ROW DATA FROM A BACKGROUND BLOCK DIRECTLY
;INTO SCNBUF.  ON ENTRY:
;(NMI_PTR) POINTS TO THE FIRST BYTE TO FETCH.  BIT 8000H SET IF LOW PAGE,
;  	OFF IF HIGH PAGE (THAT BIT IS PRESERVED ON RETURN).
;TMP_NMI1 HAS THE COUNT TO FETCH.  
;X HAS THE PLACE TO PUT IT INTO SCNBUF. 
;
;ON RETURN:  THE DATA IS IN SCNBUF, X IS UPDATED AND SO IS NMI_PTR.

;LOADROW:

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `		

	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	XLDR15
	ORA	#128
	STA	NMI_PTR+1
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XLDR15:	CLC
	LDY	#0
XLDR20:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCNBUF,X	;QUE IT UP
	INX
	LDA	NMI_PTR
	ADC	#1		;SKIP TO NEXT COL IN DATA
	STA	NMI_PTR
	BCC	XLDR30
	INC	NMI_PTR+1
	CLC
XLDR30:	DEC	TMP_NMI1
	BNE	XLDR20
	JMP	LDC35

.endif;	', )

;THIS SUB IS USED TO SHIFT ROW DATA FROM A BACKGROUND BLOCK DIRECTLY
;INTO SCNBUF.  THIS IS NECESSARY WHEN THE SCREEN PAGE IS VERTICALLY
;AN ODD VALUE.  LOADROW HAS ALREADY PUT SOME THERE AND WE ARE SHIFTING
;NEW DATA UP INTO IT NIBBLE WISE. ON ENTRY:
;(NMI_PTR) POINTS TO THE FIRST BYTE TO FETCH.  BIT 8000H SET IF LOW PAGE,
;  	OFF IF HIGH PAGE (THAT BIT IS PRESERVED ON RETURN).
;TMP_NMI1 HAS THE COUNT TO FETCH.  
;X HAS THE PLACE TO SHIFT IT INTO SCNBUF. 
;
;ON RETURN:  THE DATA IS IN SCNBUF, X IS UPDATED AND SO IS NMI_PTR.

;SHIFTROW:

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `		

	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	XSHR15
	ORA	#128
	STA	NMI_PTR+1
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
XSHR15:	LDY	#0
XSHR20:	LDA	(NMI_PTR),Y	;GET A BYTE
	ROR	A	
	ROR	SCNBUF,X	
	ROR	A	
	ROR	SCNBUF,X	
	ROR	A	
	ROR	SCNBUF,X	
	ROR	A	
	ROR	SCNBUF,X	;SHIFT THE TOP NIBBLE INTO THE EXISTING BYTE
	INX
	LDA	NMI_PTR
	CLC
	ADC	#1		;SKIP TO NEXT COL IN DATA
	STA	NMI_PTR
	BCC	XSHR30
	INC	NMI_PTR+1
XSHR30:	DEC	TMP_NMI1
	BNE	XSHR20
	JMP	LDC35

.endif;	', )

;ENTER HERE WITH THE DESIRED$8000+$8000+PAGETAB VALUE IN A AND INDEX IN Y.

;THE TABLE IS NEEDED BECAUSE OUR ROM CARTRIDGE DOES NOT DECODE THE ROM AREA.
;ANY WRITE TO ROM TRIGGERS THE LS377 PAGING PORT.  SINCE A WRITE ALSO 
;TRIGGERS A ROM READ (WR DOES NOT QUALIFY ROM) WE NEED TO WRITE TO AN AREA
;OF ROM THAT RETURNS THE SAME VALUE WE ARE WRITING.

.segment "COMMONCODE2"
SELPAGE:		 
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
	RTS

PAGETAB:
.byte 12,13
.byte 28,29
.byte 44,45
.byte 60,61
.byte 76,77
.byte 92,93
.byte 108,109
.byte 124,125

;THIS NMI VECTOR IS NEEDED TO INSURE WE CAN GET AN NMI INTERRUPT WHILE
;WE ARE GETTING DATA FROM THE SECOND PAGE.

PNMI:
	PHA 
	TYA
	PHA
	LDA	ALTBANK
	STA	NMIBANK
	LDA	ALTINDX
	STA	NMIINDX		;SET RETURN POINT
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
	JSR	NMI		;CALL THE NMI LOGIC
	LDA	NMIBANK
	LDY	NMIINDX
.ifdef ROMVER; IFDEF( `ROMVER', `		
	STA	$8000+PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
	PLA
	TAY
	PLA
IRQRTI:
	RTI	

;THIS BOOT VECTOR IS NEEDED TO INSURE THAT WE DON'T CRASH IF WE 
;HAVE A PAGED VERSION.

PBOOT: 			;THIS LABEL ONLY FOR REFERENCE
	LDX	#$FF
	TXS			;SET UP THE STACK
	LDA	#12
	STA	$8000+PAGETAB
	JMP	BOOT

;.ORG	$7FFA
.segment "VECTORS2"
;HERE ARE THE INTERRUPT AND BOOT VECTORS.  

	.word	PNMI+$8000		;NMI INTERRUPT (VERTICAL RETRACE INT)
	.word	PBOOT+$8000		;BOOT VECTOR
	.word	IRQRTI+$8000		;IRQ VECTOR

;.ORG	0		;DO NOT CHANGE THIS ORG


