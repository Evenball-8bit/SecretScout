.define	REPRATE	4		;KEY REPEAT RATE IN 1/60 SECONDS.  DON'T 
				;MONKEY WITH THIS!

.define	J1REPENA  %00001111	;REPEAT ENABLE FLAG BITS FOR EACH J1 BUTTON
.define	J2REPENA  %00001111	;REPEAT ENABLE FLAG BITS FOR EACH J2 BUTTON
				;THE ARROWS KEYS MUST REPEAT. OTHERS MUST NOT.

;WARNING!!! THE ORG FOR ENEMY0 ASSUMES THIS MANY.  YOU COULD ADD 1 MORE
;SOUND SLOT BUT NOTHING ELSE.
.define	SPSLOTS  16		;MAX ALLOWED ACTIVE SPRITE BLOCKS
.define	SNDSLOTS  5		;MAX ALLOWED ACTIVE SOUND STRUCTURES
				;TOTAL=211 BYTES

;HERE ARE THE SOUND SLOTS.  EACH PARTICULAR FUNCTION HAS A DEDICATED
;SLOT.

;0-3 ARE THE MUSIC SLOTS 0-3

.define	DINGSLOT  4		;FOR THE PAUSE DING OR NOISE COMMAND

;		HERE ARE SOME EQUATES RECOMMENDED TO BE PLACED IN PARAM1
;		AS A SIGNAL OF WHAT YOU WANT.  YOU WOULD PUT THE QUALIFIER
;		IN PARAM2 (WORLD TO GO TO, ETC.):
.define			DOOR  0		;USE FOR AN OPENING
.define			CLIMB  1	;USE FOR CLIMBING (LADDERS)
.define			BARRIER  2	;USE FOR BARRIERS = FORCE FIELDS
.define			SINK  3		;USE FOR SWAMPS =  QUICKSAND
.define			TUNNEL  4	;USE FOR TUNNEL (HORIZONTAL)
.define			PIPE  5		;USE FOR PIPE (VERTICAL)
.define			BEAM  6		;TRANSPORTER (BEAM ME UP!)
.define			NEWWORLD  7	;GO TO NEW WORLD.  PUT NEW
.define			ELAUNCH  8	;PLACE THAT LAUNCHES ENEMY
.define			TRAP  9		;BOOBY TRAP THAT DOES ???
.define			TRANSFORM  10	;TO TRANSFORM THE ENTITY.
.define			ENDSCENE  11	;FOR END SCENE REQUEST
.define			WARPZONE  12	;WARP ZONE ENTRANCE
.define			PORTAL  13	;DOOR TO ANOTHER WORLD

;********************* STATE MACHINE RAM EQUATES *********************
;
;REMEMBER!!! THESE MUST NOT OVERLAP WITH THE VALUES USED BY KUNGSUBS.ASM.

.define	WORLD_REQUEST  $00	;SET TRUE TO REQUEST A NEW WORLD.
.define	CURWORLD  $01		;CURRENT WORLD (VALID IF WORLD_REQUEST=0)
.define	WORLD_INDX  $02		;CURRENT WORLD AS AN INDEX (0,2,4,6,ETC).

.define	SAFEX  $03		;FOR SAVING X VALUES.
.define	SAFEY  $04		;FOR Y VALUES.
.define	SAFEX2  $05		;A SECOND PLACE TO SAVE X 
.define	SAFEY2  $06		;SAME FOR Y.

.define	RESETFLG  $07		;SET TRUE AT RESET FOR THE RESET COMMAND

.define	SILENCEIT  $08		;USED BY SELECT MODE TO SILENCE NEW WORLDS.

.define	TIMETICK  $09		;LOADED WITH CLOCKPHASE.  WHEN IT DECS TO
				;ZERO PHASE4 IS SET.
				;AND USED BY MANY ROUTINES FOR PACING.

.define	SPECGOTO  $0A		;TRUE IF SPECIAL WORLDGOTO CONDITION

.define	LEFTCOL  $0B		;LEFTMOST COLUMN TO HAVE IN THE GOTO WORLD
;		$0C		;OR WHEN SAVING A WORLD'S STATE.

.define	CLOCKP  $0D 		;CLOCKPHASE THATS USER MODIFIABLE.

.define	STARTCOL  $0E		;LEFTMOST COLUMN OF SCREEN WITHIN
;		   0F		;CURRENT BACKGROUND.

.define	SAFEBYTE  $10		;TEMPORARY BYTE FOR USE FROM BOTH INSIDE
				;AND OUTSIDE NMI

.define	SAFEWORD  $11		;TEMPORARY WORD FOR USE FROM OUTSIDE NMI.
;		 $12		;EVEN THOUGH ITS IN LOW RAM, DON'T USE IT
				;FOR INDIRECT SO THAT WE CAN TRANSLATE
				;THIS CODE TO OTHER MACHINES MORE EASILY.

.define	SCROLLFLG  $13		;SCROLL FLAG.  BIT ORIENTED:
				;08 = UP SCROLL DISABLED
				;04 = DOWN SCROLL DISABLED
				;02 = LEFT SCROLL DISABLED
				;01 = RIGHT SCROLL DISABLED

.define	PHASE4  $14		;SET BY USER_NMI TO SIGNAL ITS TIME TO MOVE
				;ENEMIES.  BIT ORIENTED:
				;01 = TIME FOR NEW CLOCK PHASE (MOVE ENEMIES)
				;80 = LAST MOVEMENT CYCLE GOT BEHIND.

.define	SELKEY  $15		;WHAT THE SELECT BUTTON SHOULD DO
;	     $16		;-1 IS NO INTERRUPT

.define	NEWCOL  $17		;USED BY JOYSTICK ROUTINE TO FLAG
				;THAT A JOYSTICK ENTITY NEEDS TO TEST
				;A COLUMN AGAIN.

.define	PAUSEFLG  $18		;USER CAN DISABLE PAUSE HERE.  
				;DEFAULT=DISABLED

.define	RNDNUM1  $19
.define	RNDNUM2  $1A
.define	XRANDOM  $1B		;FOR RANDOM NUMBER GENERATOR

.define	WORLDCOL  $1C		;COLUMN WITHIN BACKGROUND PASSED TO SCREENFLGS
;		   1D

.define	RNDPTR  $1E		;FOR THE RANDOM NUMBER GENERATOR
;		 1F

.define	ALTPHASE  $20		;INCREMENTED EACH PHASE FOR HALF SPEED
				;ENTITIES

.define	NUMBUF  $20 		;BUFFER TO HOLD VIDEO WRITE DATA FOR CONVNUM
;	       $24 

.define	NMICOL  $25		;HOLDS TESTCOL FOR USE WHEN NEEDCOL IS SET.
;	       $26

.define	SAVEDWORLD  $27 	;FOR STATREQUEST COMMAND.

.define	BPAUSE  $28		;SET TRUE WHEN START IS PRESSED TO FORCE PAUSE.

.define	FLAGBYTE  $29		;THE FIRST OF 6 BYTES USED WITH THE HERO 
.define	BYTE1  $2A		;WORLD COMMAND THAT IS CURRENTLY BEING RUN
.define	BYTE2  $2B
.define	BYTE3  $2C
.define	BYTE4  $2D
.define	BYTE5  $2E

.define	QUARTERYLOST  $2F	;AMOUNT OF GLOBAL_YSCR LOST BY THE 1/4ers
.define	HALFYLOST $30		;AMOUNT LOST BY THE 1/2 SCROLLERS.  WE ADD
				;IT UP AND USE IT EACH TIME.
.define	GLOBAL_YSCR  $31	;SET TO DIRECTION TO SCROLL ENTITY AS A RESULT
				;OF JOYSTICK CONTROLLED SCREEN SCROLL.
.define	HALF_YSCR  $32		;CALCULATED FOR THOSE THAT USE 1/2
.define	QUAR_YSCR  $33		;FOR THOSE THAT USE 1/4

.define	QUARTERXLOST  $34	;AMOUNT OF GLOBAL_XSCR LOST BY THE 1/4ers
.define	HALFXLOST  $35		;AMOUNT LOST BY THE 1/2 SCROLLERS.  WE ADD
				;IT UP AND USE IT EACH TIME.
.define	GLOBAL_XSCR  $36	;SET TO DIRECTION TO SCROLL ENTITY AS A RESULT
				;OF JOYSTICK CONTROLLED SCREEN SCROLL.
.define	HALF_XSCR  $37		;CALCULATED FOR THOSE THAT USE 1/2
.define	QUAR_XSCR  $38		;FOR THOSE THAT USE 1/4

.define	MOMINDX  $39		;JOYSTICK MOMENTUM INDEX
.define	JOYINDX  $3A		;JOYSTICK INDEX. 0 OR 1

.define	ENABLE_SELECT  $3B	;USED TO ENABLE WORLD SELECT MODE

;FOR EACH OF THE 2 JOYSTICKS THERE ARE VARIABLES USED WITH AN INDEX
;OF 0 OR 1 TO STORE MOMENTUM OR DECIDE WHICH ENEMY TO APPLY IT TO.

.define	JOYENEMY  $3C		;ENEMY INDEX ATTACHED TO THIS JOYSTICK.
;		 $3D		;-1 = NONE.

.define	JOYX  $3E		;ACCUMULATED X MOMENTUM FOR THIS JOYSTICK
;	     $3F

.define	JOYY  $40		;ACCUMULATED Y MOMENTUM FOR THIS JOYSTICK
;	     $41

.define	SCOREL  $42		;LOW BYTE OF SCORE FOR JOYSTICK 0 AND 1
;	       $43		;SCOREH MUST FOLLOW THIS!
.define	SCOREH  $44		;HIGH BYTE OF SCORE FOR JOYSTICK 0 AND 1
;	       $45		

.define	HEROCOUNT  $46		;COUNT OF HEROS LEFT FOR EACH JOYSTICK
;		  $47

.define	PASSCNT  $48		;USED BY MOVEENEMY TO ALLOW 3 COMMANDS PER
				;TICK.  RESET BY ANY COMMAND THAT CHANGES
				;MOMENTUM.

.define	SAVED1  $49		;USED TO SAVE STUFF FOR INITSTAT SO THAT
.define	SAVED2  $4A		;ENDREQUEST CAN RESTORE IT.
.define	SAVED3  $4B
.define	SAVED4  $4C

.define	SAVESEL $4D		;TO SAVE WHAT SELECT DOES IF STATREQUEST WORLD
;		$4E

.define	STARTROW  $4F		;TOPMOST ROW ON SCREEN (USED IN BLOCK MODE)

.define	TOPROW  $50		;TOPMOST ROW TO HAVE IN THE GOTO WORLD
				;OR WHEN SAVING A WORLD'S STATE.

.define	TABLEPTR  $51		;POINTER TO THE SCREEN COLUMN FLAGS FOR
;		 $52		;THE CURRENT WORLD.  BOTH NMI AND NON-NMI
				;USE THIS BUT NMI SAVES IT OUT.

.define	ENEMYPTR  $53		;ENEMY POINTER FOR USE BY MOVEENEMY
;		   54

.define	EXTRA_PTR  $55		;INDIRECT POINTER FOR NON NMI USE (ALL USERS)
;		  $56

.define	SETUPFLG  $57		;USED BY SETUPANIM.

.define	CHEATMODE  $58		;USED TO INFORM CODE THAT CHEAT MODE ENTERED
				;THE CURRENT WORLD.

.define	TEST_JMP  $59		;INDIRECT JUMP FOR HERO FLAGS TESTING.  ALSO
;		 $5A		;USED AS AN INDIRECT POINTER BY SAME.  CAN
				;BE USED FROM OUTSIDE NMI LEVEL BY ANYONE.

.define	SAVEJOY  $5B		;TO SAVE JOYENEMY FOR STATREQUEST
;		$5C
		    
.define	NEEDCOL  $5D		;SET TRUE WHEN WE SCROLL THE BACKGROUND IF
				;WE NEED TO TEST A NEW SCREEN COLUMN.  ITS
				;SET BY NMI FOR NON-NMI TO USE.

.define	TESTCOL  $5E		;THE COLUMN WE NEED TO TEST WHEN CALLING
;		  5F		;SCREENFLAGS ROUTINES.  MUST ONLY BE SET 
				;OUTSIDE NMI.

.define	CMDBUF  $60		;BUFFER TO HOLD DATA FOR COMMANDS UP TO 16 BYTES.
.define	DATA1  $61
.define	DATA2  $62
.define	DATA3  $63
.define	DATA4  $64		;THESE ARE HERE TO MAKE DIRECT ACCESS TO
.define	DATA5  $65		;PARAMETERS EASIER
.define	DATA6  $66
;	       $6F		

.define	ENEMYLREG  $70			;REGISTER LOW.  ALSO USED 
					;TO HOLD THE COLUMN OF LAUNCH WHILE
					;AN ENEMY IS SLEEPING.
.define	ENEMYHREG  $80			;REGISTER HIGH.  ALSO USED TO
					;HOLD THE ROW ON SCREEN AT WHICH TO
					;PUT AN ENEMY WHEN IT NEEDS TO BE
					;LAUNCHED CAUSE ITS SLEEPING.

;90-DF USED BY ENEMYLCOL TO ENEMYLINK

;E0 TO FF ARE RESERVED FOR KUNGSUBS.ASM

;******************* LOW STACK MEMORY *****************

;THERE'S SOME MEMORY IN THE LOW STACK WE CAN USE SO WE USE IT TO REMEMBER
;WHICH ENEMIES HAVE BEEN KILLED. WE ALLOW 256 ENEMIES, 1 BIT IS NEEDED EACH 
;SO THE MEMORY HERE IS 32 BYTES.  ABOVE THAT IS THE STACK AREA.  THE BIT
;IS SET HERE IF THAT ENTITY WAS KILLED, RESET IF ITS STILL ALIVE.

;100-11F FOR USER SUBS TO USE.


.define	REMEMBER  $120		;PLACE TO REMEMBER UP TO 1024 ENEMIES DEATH.
;		 $13F

.define	STATERAM  $140
;		   15F		;32 BYTES TO HOLD 1 WORD FOR EACH ENTITY

.define	COMMONDATA  $160	;20H BYTES OF COMMON DATA FOR DATAAREA
;		   $17F	;COMMANDS.  USUALLY ITS FOR PRIZES.

;*************** ENTITY VARIABLES PLACED AT AVAILABLE SPOTS.  ************

.define	ENEMYLCOL  $90		;WORLD COLUMN FLAG THAT LAUNCHED THE ENEMY.
.define	ENEMYHCOL  $A0		;WORLD COLUMN FLAG THAT LAUNCHED THE ENEMY.
.define	ENEMYFEET  $B0		;ENEMIES FEET

.define	ENEMYCTRL  $C0		;CONTROL FLAG FROM ENEMY LAUNCH
;		    CF

.define	ENEMYLINK  $D0 		;ENEMY TO WHOM THIS ENEMY IS LINKED.  
				;-1 = NONE

.define	ENEMYCNT  $360		;ENEMY COUNTER #1
.define	ENEMYALT  $370		;ENEMY COUNTER #2

;********* ENEMY VARIABLES PLACED CONTIGUOUSLY. **************
;
.define	EBASE  $4D0
.define	ECNT  16			;NUMBER OF ENEMIES ALLOWED. ACTUALLY YOU CAN'T
				;JUST CHANGE THIS, IT REQUIRES THOUGHT SINCE
				;WE HAVE TO KEEP TRACK OF HOW LOW THIS TABLE
				;GOES.  ALSO, YOU MUST ALLOCATE THAT
				;MANY SPRITE SLOTS (SPSLOTS) AND SET THE
				;LIFE FORCE SLOT TO A VALUE ABOVE THEM.

.define	ENEMY0  EBASE		;-1 IF INACTIVE, NOT -1 IF ENEMY IS ACTIVE.  
				;HAS THE ENEMY NUMBER TO USE WITH ENTITYTAB.
				;BE SURE TO SET THIS LAST WHEN INITIALIZING
				;AN ENTITY BECAUSE USER_NMI LOOKS AT IT TO
				;MAKE DECISIONS ABOUT ENTITIES.

.define	ENEMYREQ  EBASE+ECNT*1  	;ENEMY REQUESTS.  SET EXTERNALLY TO REQUEST
				;AN ENEMY TO ENTER A MODE.  USE THE 
				;SAME VALUE AS COMMAND 0 IN KUNGTAB
				;USES ("EJUMP", "EFALL", "EDUCK", ETC).
				;THIS DOESN'T ALLOW ACTIVATING WAKEUP
				;MODE SINCE THIS EQUATES TO ZERO WHICH
				;IS THE FLAG FOR NO REQUEST.

.define	ENEMYXMOM  EBASE+ECNT*2	;ENEMY'S X MOMENTUM FOR ENEMIES 0-5.
				;ITS THE MOMENTUM/8 AS FOR THE HERO

.define	ENEMYYMOM  EBASE+ECNT*3	;ENEMY'S Y MOMENTUM FOR ENEMIES 0-5.
				;ITS MOMENTUM/8 AS FOR THE HERO.

.define	ENEMYHEALTH  EBASE+ECNT*4 ;AMOUNT OF HEALTH LEFT IN THE ENEMY.

.define	ENEMYDELAY  EBASE+ECNT*5	;SET TO DELAY ENEMY WITH THE DELAY COMMAND.
				;WILL STILL MOVE ACCORDING TO MOMENTUM
				;AND GRAVITY.

.define	ENEMYATK  EBASE+ECNT*6	;LAST ENEMY THAT ATTACKED THIS ENEMY. ITS
				;THE SLOT NUMBER, NOT THE ENTITYTAB
				;ENTRY.  -1 = NONE.

.define	ENEMYDAMG  EBASE+ECNT*7	;DAMAGE AND ATTACK NUMBER OF LAST ATTACKER
				;07H = DAMAGE REQUESTED
				;08H = REPORT ATTACK NUMBERS 16-31
				;F0H = ATTACK NUMBER REQUESTED.

.define	ENEMYHIGH  EBASE+ECNT*8	;ENEMY HEIGHT FROM THE ANIMATION OR SPRITE.
				;ITS HIS PIXEL HEIGHT.

.define	ENEMYWIDE  EBASE+ECNT*9	;ENEMY WIDTH FROM THE ANIMATION OR SPRITE.
				;ITS HIS PIXEL WIDTH.

.define	ENEMYX  EBASE+ECNT*10	;CURRENT ENEMY X LOCATION

.define	ENEMYY  EBASE+ECNT*11	;CURRENT ENEMY Y LOCATION
		
.define	ENEMYLROW  EBASE+ECNT*12	;ENEMIES LAST ROW THAT FLAGS TESTED ON

.define	ENEMYINL  EBASE+ECNT*13	;LOW BYTE OF WORD INDEX INTO MEMORY WHERE 
				;CURRENT MOVEMENT TABLE IS BEING RUN.

.define	ENEMYINH  EBASE+ECNT*14	;HIGH BYTE OF SAME INDEX.

.define	ENEMYFLGS  EBASE+ECNT*15	;ENEMY FLAGS FROM ENEMY TABLE AT LAUNCH TIME

.define	ENEMYGRAV  EBASE+ECNT*16	;ENEMY Y AXIS GRAVITY

.define	ENEMYXLIM  EBASE+ECNT*17	;ENEMY X MOMENTUM LIMIT

.define	ENEMYYLIM  EBASE+ECNT*18	;ENEMY Y MOMENTUM LIMIT

.define	ENEMYSOLID  EBASE+ECNT*19	;ENEMY SOLID VALUE

.define	ENEMYCENTR  EBASE+ECNT*20 ;CURRENT ENEMY CENTER OF BODY X LOCATION

.define	ENEMYJSTAT  EBASE+ECNT*21	;SOME MORE ENEMY STATUS BITS.	
				;80H SET = NO JOYSTICK ATTACHED
				;40H SET = ENEMY IS EXECUTING HALF SPEED
				;20H SET = ENEMY IS HIDDEN FOR STATREQUEST.
				;$10 = LAST JOYSTICK PRESS WAS LEFT
				;$08 = UNUSED.  RESERVED FOR LAST PRESS UP.
				;$04 = LINKED ENEMY USES FACE BITS ANYWAY.
				;BITS 03 = JOYSTICK USED:
				;           	0=JOYSTICK 1
				;           	1=JOYSTICK 2

.define	ENEMYTLLOW  EBASE+ECNT*22 ;ENTITY'S TARGET LEVEL, LOW BYTE
.define	ENEMYTLHI  EBASE+ECNT*23  ;ENTITY'S TARGET LEVEL, HIGH BYTE

.define	ENEMYTRACK  EBASE+ECNT*24 ;TARGET TRACKING DIRECTION AND ENTITY
				 ;CURRENT DIRECTION:
				 ;BIT 80H = SET IF THIS ENTITY FACING LEFT
				 ;BIT 40H = SET IF THIS ENTITY UPSIDE DOWN
				 ;BITS 03 = 0-2 X TRACKING FROM COMMAND 9D
				 ;BITS 30 = 0-2 Y TRACKING FROM COMMAND 9E

.define	ENEMYTRLOW  EBASE+ECNT*25 ;ENTITY'S TARGET, LOW BYTE
.define	ENEMYTRHI  EBASE+ECNT*26  ;ENTITY'S TARGET, HIGH BYTE

.define	ENEMYD1  EBASE+ECNT*27	;DAMAGE FLAG #1
.define	ENEMYD2  EBASE+ECNT*28	;DAMAGE FLAG #2
.define	ENEMYD3  EBASE+ECNT*29	;DAMAGE FLAG #3
.define	ENEMYD4  EBASE+ECNT*30	;DAMAGE FLAG #4
.define	ENEMYD5  EBASE+ECNT*31	;DAMAGE FLAG #5


.define	ENEMYRSL  EBASE+ECNT*32	;RESUME COMMAND PTR LOW
.define	ENEMYRSH  EBASE+ECNT*33	;RESUME COMMAND PTR HIGH. -1 = NO RESUME POINT

.define	ENEMYSTAT  EBASE+ECNT*34	;ENEMY CONTROL FLAGS FOR SPECIFIC STATUSES:
				;80H = SET IF ENEMY IS IN SLEEP MODE.  THEN
				;      ENEMYLREG HAS SCREEN COLUMN IT MUST
				;      BE ON IN ORDER TO BE LAUNCHED OR
				;	-2 IF JUST WHEN VISIBLE.
				;40H = REQUEST TO TURN ON SOLID CHECKING
				;20H = ATTACK IS ARMED.
				;10H = ENEMY IS STANDING ON SOLID
				;08H = ENEMY HAS ATTACKED SOMEONE
				;04H = SOLID STATE IS ON.
				;02H = ENEMY MOVED ON X AXIS
				;01H = ENEMY MOVED ON Y AXIS.  WE ONLY BOUNCE
				;      IF WE MOVED, HIT SOLID, AND HAVE 
				;      MOMENTUM.  NO BOUNCE IF WE JUST
				;	PUSHED SOLID (LIKE WITH STANDING).


.define	ENEMYXFRICT  EBASE+ECNT*35	;ENEMY X FRICTION OR OFFSET TO USE
					;ON X AXIS WHEN LINKED.
.define	ENEMYYFRICT  EBASE+ECNT*36	;ENEMY Y FRICTION OR OFFSET TO USE
					;ON X AXIS WHEN LINKED.

.define	ENEMYBOUNCE  EBASE+ECNT*37	;ENEMY BOUNCE FACTOR.

.define	ENEMYSD  EBASE+ECNT*38		;SAVED ENEMYDELAY BEFORE EXTERNAL 
					;EVENT THAT CAN BE RESUMED.  

.define	ENEMYFCTR  EBASE+ECNT*39		;FRICTION COUNT DOWN.
					;F0 = COUNT SINCE LAST Y MOM APPLIED
					;0F = COUNT SINCE LAST X MOM APPLIED

.define	ENEMYID EBASE+ECNT*40		;ID OF LAST ATTACKER (ENTITYTAB
					;ENTRY NUMBER).  VALID ONLY IF
					;ENEMYATK IS NOT -1.  LOADED WITH
					;-1 FOR USE BY HURTING DISABLED
					;ENTITIES.

.define	ENEMYP1  EBASE+ECNT*41		;FIRST BYTE PASSED BY WORLD EVENT.
.define	ENEMYP2  EBASE+ECNT*42		;SECOND BYTE PASSED BY WORLD EVENT.


.define	ENEMYINTS  EBASE+ECNT*43		;ENEMY INTERRUPTS DISABLE FLAG BIT
					;THE INTERRUPT BITS ARE DOCUMENTED
					;IN THE DISABLE COMMAND IN KUNGTAB
.define	ENEMYSINT  EBASE+ECNT*44		;SAVED ENEMY INTERRUPTS FOR RESUME

.define	ENEMYNUM  EBASE+ECNT*45		;ENEMY'S NUMBER IN THE PERMANENT MEMORY.

.define	ENEMYVCTM  EBASE+ECNT*46		;ENEMY'S LAST VICTIM

.define	ENEMYLTST  EBASE+ECNT*47		;LAST COLUMN THAT THE ENEMY TESTED.
.define	ENEMYHTST  EBASE+ECNT*48		;AND ALSO A HIGH BYTE FOR 1 WORD.

.define	ENEMYFACE  EBASE+ECNT*49		;ENEMY DIRECTION FLAG.  SEE KUNGTAB.


.define	ENEMYBEHAVE  EBASE+ECNT*50	;ENEMIES PERSONALITY BITS

;************************************************************************************
;From Kungsubs
;************************************************************************************
; ********************* SUBROUTINE RAM EQUATES *************************
;KUNGFU.ASM EXPECTS TO BE ABLE TO USE UP TO EF.

	TTT1 = $E0
	TTT2 = $E1

;E0-E2 OK FOR KUNGSUBS TO USE.

	VIDTYPE = $E3		;0 FOR PAGE 0, 1 FOR PAGE 1, -1 FOR 
				;STATUS LINE.
	STATTYPE = $E4		;TYPE OF STATUS BAR COMMAND (FILL, WRITE...)

	STATHI = $E5 		;HIGH BYTE OF STATUS LOCATION FOR SCNBUF
	STATLO = $E6 		;LOW BYTE OF STATUS LOCATION FOR SCNBUF

	STATLEN = $E7		;LENGTH TO WRITE TO STATUS LINE.  0 IF NOT
				;IN USE.  LOAD OTHER VARIABLES FIRST!
	STATROW = $E8		;ROW TO WRITE AT
	STATCOL = $E9		;COLUMN TO WRITE AT

	STATDATA = $EA		;LOCATION OF DATA TO WRITE TO STATUS BAR
;		 $EB		;OR THE DATA TO FILL WITH

;*******************************************************************
;THESE 4 VARIABLES ARE SWAPPED DURING NMI SO THAT FINDCOL CAN BE USED
;FROM BOTH LEVELS SEPERATELY AND SAVE THE OLD POSITIONS.
	WORLDSPOT = $EC		;CURRENT LOCATION IN THE WORLD LIST.  USED
				;AS POINTER, BE CAREFUL.
	SPOTCOL = $EE		;FIRST COLUMN OF CURRENT BACKGROUND IN
				;TOTAL WORLD'S LENGTH OF COLUMNS (COLUMN
				;THAT WORLDSPOT'S BACKGROUND STARTS ON).
 	BACKBASE = $F0		;BACKGROUND DATA PTR

	BPBASE = $F2 		;BACKGROUND PALETTE INFO PTR
;**********************************************************************

	WORLDPTR = $F4		;POINTER TO LIST OF BACKGROUNDS FOR THIS
				;WORLD.
	NMI_PTR = $F6

	BPAL_BASE = $F8		;BACKGROUND PALETTE REG DATA BASE PTR
	SPAL_BASE = $FA		;SPRITE PALETTE REG DATA BASE PTR
	MAIN_PTR = $FC		;POINTER FOR USE BY MAINLINE ROUTINES



	SUBSVAR1 = $FE		;VARIABLE FOR USE BY THE SUBS.  OK TO
	SUBSVAR2 = $FF		;USE FROM BOTH NMI AND NON-NMI LEVEL
				;BECAUSE ITS SAVED AT NMI.  MUST STAY
				;IN LOW RAM FOR A (POINTER).

	STATSPR = $200		;SPRITE RAM.  $200-$2FF
	SPRAM = $204		;SPRITE RAM AFTER SKIPING SPRITE #0
				;STORED IN FORMAT REQUIRED BY NES VIDEO
				;PROCESSOR EXCEPT FOR 1 BIT WE USE:
				;1 BYTE VERTICAL SCAN LINE FOR TOP SPRITE ROW
				;1 BYTE CHARACTER TO USE FROM CHAR SET
				;1 BYTE PALETTE AND FLIP SPEC:
				;	80H SET TO DISPLAY UPSIDE DOWN
				;	40H SET TO DISPLAY MIRROR IMAGE
				;	20H SET PUTS SPRITE BEHIND BACKGROUND
				;	08H USED BY US TO MARK IN USE
				;	XXB = PALETTE TO USE (0-3)
		 		;1 BYTE HORIZONTAL SCAN LINE FOR LEFT ROW

;THE FOLLOWING BUFFER IS USED TO HOLD ANY DATA TO BE WRITTEN TO THE
;SCREEN.  THE BUFFER HOLDS LIMITED DATA AND THE LIMIT IS DESIGNED TO
;BE THE MAX WE CAN SAFELY WRITE TO THE SCREEN WITHOUT OVERFLOWING
;THE VERTICAL RETRACE.  IF A ROUTINE WISHES TO WRITE TO SCREEN, IT 
;SHOULD BE ACTIVATED FROM THE TAIL END OF NMI WITH FLAGS THAT ARE SET.
;THE FIRST THING THE ROUTINE SHOULD DO WHEN CALLED IS CHECK ITS FLAG
;TO SEE IF IT NEEDS TO WRITE TO SCREEN.  IF IT DOES, IT SHOULD NEXT CHECK
;THIS BUFFER TO SEE IF IT CAN FIT ITS WRITE INTO THE REMAINING ROOM OF
;THE BUFFER.  SCSIZE HAS THE MAX THE BUFFER CAN HOLD AND SCCNT HAS THE
;AMOUNT ALREADY THERE.  IF THE BUFFER CAN'T HOLD THE SCREEN WRITE DATA
;THEN THE ROUTINE SHOULD LEAVE ITS FLAG SET AND FORGET IT THIS PASS
;OF NMI.  IF THE BUFFER CAN HOLD THE DATA, IT SHOULD INDEX TO THE NEXT
;UNUSED POSITION IN THE BUFFER, AND PUT THE FOLLOWING DATA INTO THE 
;BUFFER:
;
;1 BYTE VERTICAL WRITE FLAG.  0=NO VERTICAL WRITE, 4=VERTICAL WRITE
;HIGH BYTE OF SCREEN RAM LOCATION.  
;LOW BYTE OF SCREEN RAM LOCATION
;1 BYTE LENGTH OF DATA TO WRITE
;DATA FOR LENGTH SPECIFIED.
;
;THEN THE ROUTINE SHOULD ADD THE TOTAL LENGTH OF THE ABOVE DATA TO
;THE VARIABLE SCCNT.  AT NEXT NMI THE DATA WILL BE WRITTEN.  NO ROUTINE
;SHOULD HOG EACH NMI OR IT MAY LOCK OUT OTHER ROUTINES.

	SCNBUF = $300		;SCREEN WRITE BUFFER.  LENGTH MAY CHANGE
	SCSIZE = $60		;AMOUNT THAT BUFFER CAN HOLD

;360-37F USED BY KUNGFU FOR ENEMIES.

	SCCNT = $380		;COUNT OF DATA IN BUFFER

	TOOMANY = $381		;SET TRUE BY NMI IF LAST SCREEN PAINT HAD
				;TOO MANY SPRITES ON THE LINE.

	BPAL_BLINK = $382	;BACKGROUND PALETTE CONTROL RAM
	BPAL_DEPTH = $383
	BPAL_FREQ = $384
	BPAL_INDX = $385
	BPAL_CNT = $386

	NEW_PAL = $387		;BIT 01 SET IF NEW BACKGROUND PAL
				;BIT 02 SET IF NEW SPRITE PAL

	SPAL_BLINK = $388	;BACKGROUND PALETTE CONTROL RAM
	SPAL_DEPTH = $389
	SPAL_FREQ = $38A
	SPAL_INDX = $38B
	SPAL_CNT = $38C

	J1FLAGS = $38D		;JOYSTICK1 CURRENT STATE
	J2FLAGS = $38E		;JOYSTICK2 CURRENT STATE. ON=BUTTON DOWN.
				;MUST FOLLOW J1FLAGS!!!

        A_BUTTON = $80		;80H = A button		EQUATES TO MAKE IT
 	B_BUTTON = $40		;40H = B button		EASIER TO TEST J1FLAGS
 	SELECT = $20		;20H = Select
 	START = $10			;10H = Start
 	UP = 8			;08H = Up
 	DOWN = 4			;04H = Down
 	LEFT = 2			;02H = Left
 	RIGHT = 1			;01H = Right

	J1CHANGE = $38F		;USED TO HOLD CHANGES IN JOYSTICK STATE
	J2CHANGE = $390

	REPCNT = $391		;AUTOREPEAT COUNT DOWN TIMER

	J1REPFLG = $392		;HOLDS BIT FOR EACH J1 BUTTON AUTOREPEATING
	J2REPFLG = $393		;HOLDS BIT FOR EACH J1 BUTTON AUTOREPEATING
	J1HOLD = $394		;USED TO DELAY START OF AUTOREPEAT BY 1 REPEAT
	J2HOLD = $395		;USED TO DELAY START OF AUTOREPEAT BY 1 REPEAT

	WORLD_HEIGHT = $396	;TOTAL COMBINED HEIGHT OF WORLD IN ROWS

	DOUBLE_BIT = $397	;THIS VARIABLE TRACKS THE VALUE OF REG2000'S
				;DOUBLE HIGH SPRITE BIT.

	DIDX = $398 		;SIGNAL THAT WE JUST DID X SCROLL AND NEED
				;TO DO Y.

	END_ROW = $399		;USED TO ADJUST SCROLL POSITIONS

;*******************************************************************
;THESE 2 VARIABLES ARE SAVED DURING NMI SO THEY CAN BE USED OUTSIDE NMI.
	FETCHCOL = $39A		;COLUMN WE NEED TO FETCH WITH BUILD_COL
;		   39B		;OR BUILD_ROW.  ITS THE COLUMN WITHIN THE
				;STRUNG TOGETHER BACKGROUND SO IT NEEDS A
				;FULL WORD.

	FETCHROW = $39C		;ROW WE NEED TO FETCH ALONG WITH FETCHCOL
;		 $39D		;BUT WE ONLY SUPPORT 255 HIGH.
;*******************************************************************

	WORLD_WIDTH = $39E	;TOTAL COMBINED WIDTH OF WORLD IN COLUMNS 

	END_COL = $3A0		;LAST LEFTMOST COLUMN FOR THE BACKGROUND
	RIGHTLIMIT = $3A2	;RIGHTMOST LEGAL XBACK (PIXEL LOCATION)

	BACKVALID = $3A4		;TRUE IF THE BACKGROUND IS VALID. MAKE_SCROLL
				;WILL NOT CHANGE SCROLL VALUES IF FALSE.

	SOLIDCHAR = $3A5		;THE SOLID CHAR WE HIT WITH TESTPUT

	TESTX = $3A6		;SAVED BY TESTPUT FOR USERS IN KUNGFU.ASM
	TESTY = $3A7

	BOTLIMIT = $3A8		;BOTTOM MOST PIZEL COLUMN FOR THE BACKGROUND
;		 $3A9

	BLOCK_WIDTH = $3AA 	;BLOCK WIDTH OF WORLD IF BLOCK MODE

	BASESPRITE = $3AB	;BASE SPRITE FOR USE BY SPRITE ROUTINES
				;AND ROUTINE "ROTATE".

;THESE 8 BYTES HOLD A SECOND COPY OF KEY VARIABLES USED TO PIECE 
;BACKGROUNDS TOGETHER.  SINCE WE HAVE TO SCAN THE BACKGROUND TABLE
;LIST, IT SAVES TIME TO HAVE 2 COPIES OF THE SCAN INFORMATION.  ALSO,
;ITS MANDITORY TO SAVE AND RESTORE AFTER NMI SINCE TESTPUT USES
;THE SAME VARIABLES OUTSIDE OF INTERRUPTS.  2 COPIES MAKES THE MOST
;SENSE BECAUSE IT SAVES PROCESSOR POWER.

	XWORLDSPOT = $3AC
	XSPOTCOL = $3AE
	XBACKBASE = $3B0
	XBPBASE = $3B2
	XBACKSIZE = $3B4		;1 OR 2 SIZE OF BACKGROUND BLOCKS
	XBACKWIDE = $3B5		;WIDTH IN BLOCKS OF BACKGROUND
	XBACKHIGH = $3B6		;HEIGHT IN BLOCKS OF BACKGROUND
	XBPWIDE = $3B7		;WIDTH OF PALETTE INFO ASSOCIATED WITH BACKGRND

	STARTSTAT = $3B8		;SCROLL START FOR STATUS BAR ($F0-ROWS UP)
				;ZERO MEANS WE HAVE NO STATUS BAR
	PUTBAR = $3B9		;Y VALUE TO USE FOR THE SPRITE
	CUTOFF = $3BA		;SCROLL VALUE TO USE TO CUT OFF BACKGROUND.
	STATBITS = $3BB		;BITS FOR REG2000 FOR STATUS BAR
	SHAKEAMT = $3BC		;MICRO BACKGROUND SCROLL ADJUSTMENT FROM
				;THE SHAKE COMMAND
	BACKBITS = $3BD		;BITS FOR REG2000 FOR SPRITES AND CHAR SET

;THESE VARIABLES ARE GENERATED AHEAD OF TIME TO SAVE PROCESSOR POWER.
;THERE ARE 3 VALUES:
;STATBANK AND STATINDX ARE USED WHEN WE ARE IN THE STATUS BAR REGION.
;BACKBANK AND BACKINDX ARE USED WHEN WE ARE IN THE NORMAL BACKGROUND RUNNING
; ROM PAGE 0 CODE.
;ALTBANK AND ALTINDX ARE USED WHEN WE ARE IN THE NORMAL BACKGROUND BUT ARE
; ACCESSING ROM PAGE 1.

	STATBANK = $3BE		;STATUS BAR VIDEO BANK TO FEED TO PAGETAB
	STATINDX = $3BF		;INDEX TO USE INTO PAGETAB.

	BACKBANK = $3C0		;BELOW STATUS BAR VALUE TO FEED TO PAGETAB
	BACKINDX = $3C1

	ALTBANK = $3C2
	ALTINDX = $3C3

	NMIBANK = $3C4		;FOR NMI INTERRUPT LOGIC
	NMIINDX = $3C5

;3C6-3CF UNUSED

	TMP_NMI1 = $3D0		;TEMPORARY VARIABLES TO USE DURING NMI INT.
	TMP_NMI2 = $3D1		;RULES FOR USE:  EVEN USER SUBS MAY USE
	TMP_NMI3 = $3D2		;THESE VARIABLES BUT NO ROUTINE SHOULD 
	TMP_NMI4 = $3D3		;EXPECT ANY VALUES TO STAY HERE WHEN ANOTHER
	TMP_NMI5 = $3D4		;SUB IS CALLED UNLESS THAT ROUTINE 
	TMP_NMI6 = $3D5		;SPECIFICALLY STATES THAT THE VARIABLES ARE
	TMP_NMI7 = $3D6		;NOT USED.  OK TO USE OUTSIDE NMI IF YOU
	TMP_NMI8 = $3D7		;DISABLE NMI INTS THE WHOLE TIME.
	TMP_NMI9 = $3D8		
	TMP_NMIA = $3D9
	TMP_NMIB = $3DA
	TMP_NMIC = $3DB
	TMP_NMID = $3DC
	TMP_NMIE = $3DD

	SUBSVAR5 = $3DE		
	SUBSVAR6 = $3DF
	SUBSVAR3 = $3E0		;NON-PTR CAPABLE SUBS FOR USE FROM ANY LEVEL.
	SUBSVAR4 = $3E1		

	MATH1 = $3E2		;TEMPORARY VARIABLES FOR USE BY MATH ROUTINES.
	MATH2 = $3E3		;SAVED EACH NMI AND RESTORED TO ALLOW ALL
	MATH3 = $3E4		;TO USE MATH ROUTINES.  THESE MAY BE USED
	MATH4 = $3E5		;AS TEMP VARIABLES ALSO BUT WILL BE CHANGED
				;IF A MATH ROUTINE IS CALLED.

	STATDELAY = $3E6		;DELAY AFTER COLLISION DETECTION BEFORE
				;HITTING SCROLL REGS.  ACCESSABLE FROM
				;THE POKE COMMAND.

	FOUNDSOME = $3E7 	;USED BY FEED_SOUND

	REG4015 = $3E8		;VOICE ENABLE REG CURRENT STATE

	SCRLDIF = $3E9		;FOR USE BY SCROLL ROUTINE.

;3EA UNUSED

	MOVEBACK = $3EB		;SET TRUE IF BACKGROUND NEEDS MOVING.
				;BIT ORIENTED:
				;01 = X MIGHT NEED SCROLLING
				;02 = Y MIGHT NEED SCROLLING

	SPYADJ = $3EC		;CENTERING AMOUNT FOR SPRITES AS A RESULT
				;OF THE BACKGROUND SHIFT

	ROTATEFLG = $3ED 	;SET TO 0 TO TURN OFF ROTATION

	XBACK = $3EE		;USER SET DESIRED X PIXEL LOCATION IN BACKGND
;		3EF

	YBACK = $3F0		;USER SET DESIRED Y
;		3F1

	ROTATING = $3F2 		;TRUE IF WE ARE ROTATING THE SPRITES AND
				;SHOULDN'T DO THE SPRITE DMA TRANSFER

	CURX = $3F3		;CURRENTLY DRAWN X PIXEL BACKGROUND LOCATION
;              3F4
	CURY = $3F5		;CURRENTLY DRAWN Y PIXEL LOCATION
;              3F6

;****************************************************************
;THESE 4 VARIABLES ARE SWAPPED DURING NMI SO THAT NON-NMI LEVELS MAY
;DO SOLID CHECKING USING FINDCOL.
	BACKSIZE = $3F7		;1 OR 2 SIZE OF BACKGROUND BLOCKS
	BACKWIDE = $3F8		;WIDTH IN BLOCKS OF BACKGROUND
	BACKHIGH = $3F9		;HEIGHT IN BLOCKS OF BACKGROUND
	BPWIDE = $3FA		;WIDTH OF PALETTE INFO ASSOCIATED WITH BACKGRND
;******************************************************************

	DRUMLOCK = $3FB 		;BITS TO LOCK DRUM OUT FROM USING A SPECIFIC
				;VOICE.  USE SAME BIT AS ENABLE_BIT RETURNS.
				;WHEN SET, ITS LOCKED OUT.

	XSCROLL = $3FC		;X SCREEN SCROLL VALUE
	YSCROLL = $3FD		;Y SCREEN SCROLL VALUE WHEN BACKGROUND ACTIVE
	REG2001 = $3FE		;VALUE TO WRITE TO $2001 TO ENABLE VIDEO
	REG2000 = $3FF		;THE VALUE WE WRITE TO $2000 MINUS NMI ENABLE
				;THE FOLLOWING BITS MUST REMAIN OFF!!!
				;BIT $80 
				;BIT $04

;******        SPRITE BLOCK AND ANIMATION RAM.        ******
;
;THE SPRITE BLOCKS AND ANIMATION SPECIFICATIONS ARE STORED HERE.  THE
;MAXIMUM NUMBER OF ACTIVE BLOCKS IS DETERMINED BY THE VARIABLE SPSLOTS.
;EACH BLOCK OR ANIMATION USES 7 BYTES OF RAM.  YOU MAY CHANGE SPSLOTS
;BUT WATCH YOUR RAM USAGE.  THIS VARIABLE IS IN USERASM.ASM

	ANIM_WIDE = 10		;WIDTH OF EACH ENTRY.  NOT USER CHANGABLE.
	SPMEM = SPSLOTS*ANIM_WIDE	;AMOUNT OF RAM USED BY THE SPRITE SLOTS
	ANIM_RAM = $400		;BASE SLOT OF ANIMATION/SPRITE RAM
				;FORMAT:
	FB = 0			;FLAG BYTE: 	0=SLOT AVAILABLE,
				;		80H SET IF STRUCTURE NOT 
				;		    POSITIONED YET.
				;		40H SET IF ANIMATION IS
				;		    FROZEN OR IF SPRITE ONLY.
				;		20H SET IF ANIMATION UPDATE
				;		    BY X ALIGNMENT.
				;		10H SET IF ANIMATION UPDATE
				;		    BY Y ALIGNMENT.
				;		08H SET IF SOLID CHAR DEFINED.
				;		
				;		BITS 07 ARE STRUCTURE TYPE:
				;		  1=SPRITE, 2=SPRITE ANIM.,
				;		  3=OBJECT ANIMATION.
				;
	AF = 1			;AUXILARY FLAGS:
				;		BITS 07H = SHIFT COUNT
				;		  FOR ALIGNMENT BY X OR Y.
				;		BIT 10H = AUTOFREEZE IF SET.
				;		BIT 20H = AUTOKILL IF SET.
				;		BIT 40H = MIRROR IMAGE.
				;		  WHEN SET SPRITE IS FLIPPED
				;		  FROM LEFT TO RIGHT.
				;		BIT 80H = UPSIDE DOWN
				;		  WHEN SET SPRITE IS DISPLAYED
				;		  UPSIDE DOWN FROM ORIGINAL
				;		  SPECIFICATION.			

	PTRL = 2			;WORD PTR TO DATA OR ANIMATION LIST
	PTRH = 3
	BS = 4			;IF SPRITE, BASE SPRITE*4 INDEX (BYTE).
				;IF OBJECT ANIMATION THEN LOW 4 BITS ARE
				;COLUMN POSITION/4, HIGH ARE ROW POSITION/4
	NS = 5			;IF SPRITE, NUMBER OF SPRITES (BYTE).
				;IF OBJECT, BIT 80H SET IF REFRESH NEEDED.
				;           BITS 7FH ARE AMOUNT OF RAM NEEDED
				;	    TO WRITE AN UPDATE OUT.
	FR = 6			;CURRENT ANIMATION FRAME (BYTE)
	CN = 7			;COUNT DOWN TO NEXT FRAME CHANGE (BYTE)
	RL = 8			;RELOAD VALUE FOR COUNT DOWN (BYTE). INITIALLY
				;   LOADED WITH VALUE FROM ANIMATION, THEN
				;   ITS USER CHANGEABLE.
	SL = 9			;SOLID CHAR VALUE.  ONLY VALID IF SOLID
				;   DEFINED BIT SET IN FLAGS.

;HERE ARE THE SOUND SLOTS.  THEY FOLLOW THE SPRITE SLOTS IN MEMORY AND
;USE THE EQUATES ABOVE TO DETERMINE THEIR BASE LOCATION.  ALL SLOT ORIENTED
;STRUCTURES SHOULD FOLLOW THIS STRATEGY OF CALCULATING THEIR LOCATION
;BASED ON THE PREVIOUS NUMBER OF SLOTS.  YOU CAN CHANGE THE NUMBER
;OF SOUND STRUCTURES BY SETTING SNDSLOTS IN USERASM.ASM

	SND_WIDE = 8		;WIDTH OF EACH ENTRY.  NOT USER CHANGABLE.
	SNDMEM = SNDSLOTS*SND_WIDE ;AMOUNT OF RAM USED BY THE SPRITE SLOTS
	SND_RAM = $400+SPMEM	;BASE SLOT OF ANIMATION/SPRITE RAM
				;FORMAT:
	SF = 0			;SOUND FLAG:  BIT 80H SET IF SLOT IN USE.
				;	      BIT 40H SET IF SOUND HAS NOT
				;             BEEN ASSIGNED TO A REGISTER SET.
				;	      BIT 20H SET IF SOUND SUSPENDED
				;	        BY ANOTHER VOICE.
				;             LOW BITS SPECIFY LOW BYTE OF
				;	      REGISTER SET BASE (0,4,8,ETC).
	ST = 1			;SOUND TIMER.  LOADED WITH NOTE OR PAUSE
				;             DURATION IN 1/60 SECOND TICKS.
	SBL = 2			;BASE POINTER (WORD) TO THE ORIGINAL SOUND
	SBH = 3			;	      STRUCTURE PASSED IN CALL.
	SOL = 4			;SOUND OFFSET OF CURRENT PLAY LOCATION.			
	SOH = 5
	SI = 6			;INSTRUMENT CURRENTLY ACTIVE.  USED TO 
				;	      RESTORE SOUND IF SUSPENDED.
	LOP = 7			;LOOP COUNTER FOR THE LOOP COMMAND
        
;THE FOLLOWING EQUATES ARE USED TO MAKE MUSIC STRINGS.

.define	LC $00
.define	LCs $01
.define	LDb $01
.define	LD $02
.define	LDs $03
.define	LEb $03
.define	LE $04
.define	LF $05
.define	LFs $06
.define	LGb $06
.define	LG $07
.define	LGs $08
.define	LAb $08
.define	LA $09
.define	LAs $0A
.define	LBb $0A
.define	LB $0B
.define	C $0C
.define	Cs $0D
.define	Db $0D
.define	D $0E
.define	Ds $0F		
.define	Eb $0F
.define	E $10
.define	F $11
.define	Fs $12
.define	Gb $12
.define	G $13	       	;NOTES (CENTER AROUND INSTRUMENT RANGE)
.define	Gs $14
.define	Ab $14
.define	Ax $15		;SPECIAL CASE.  A WAS REGISTER INDICATOR.  USE Ax.
.define	As $16
.define	Bb $16
.define	B $17
.define	HC $18
.define	HCs $19	;s MEANS SHARP (#)
.define	HDb $19	;b MEANS FLAT
.define	HD $1A
.define	HDs $1B
.define	HEb $1B
.define	HE $1C
.define	HF $1D
.define	HFs $1E
.define	HGb $1E
.define	PAUSE $1F

.define	N16 %00000000		;NOTE DURATIONS.  USE BY ADDING (Gs+N16)
.define	N8 %00100000
.define	N4 %01000000
.define	N2 %01100000
.define	N1 %10000000

.define	BASE_HARPSI %10100000
.define	HARPSI %10100001
.define	HIGH_HARPSI %10100010
.define	BASE_STRING %10100011
.define	STRING %10100100
.define	HIGH_STRING %10100101
.define	BASE_ELECPIANO %10100110
.define	ELECPIANO %10100111
.define	HIGH_ELECPIANO %10101000	;INSTRUMENT SELECT COMMANDS
.define	BASE_SLIDER %10101001
.define	SLIDER %10101010
.define	HIGH_SLIDER %10101011
.define	BASE_BEE %10101100
.define	BEE %10101101
.define	HIGH_BEE %10101110
.define	BASE_PIANO %10101111
.define	PIANO %10110000
.define	HIGH_PIANO %10110001
.define	BASE_ARCADE %10110010
.define	ARCADE %10110011
.define	HIGH_ARCADE %10110100

.define	SOUNDLOOP %11000000	;LOOP COMMAND
.define	NODRUMS %11000010	;DISALLOW DRUMS IN THIS VOICE CHANNEL
.define	ALLOWDRUMS %11000011

.define	VOICE0 %11100000
.define	VOICE1 %11100001	;USED TO SELECT A REGISTER SET (VOICE).
.define	VOICE2 %11100010
.define	VOICE3 %11100011

.define	REPLAY %11100100	;USED TO REPEAT THE SOUND STRING OR END IT.
.define	ENDPLAY %11101000

.define	LOADREG0 %11101100
.define	LOADREG1 %11101101	;USED TO HARD CODE LOADING OF REGISTERS
.define	LOADREG2 %11101110	;IN CURRENTLY SELECTED REGISTER SET (VOICE).
.define	LOADREG3  %11101111

.define	STOPVOICE %11110000
.define	STARTVOICE %11110100 	;USED TO SILENCE OR ACTIVATE A VOICE

.define	PERCUSSION %11111000	;USED TO SELECT THE PERCUSSION INSTRUMENTS

.define	LOADALL %11111001	;USED TO SPECIFY LOADING ALL 4 REGS

.define	WAIT %11111011		;USED TO DELAY AFTER LOADALL OR LOADREGx

;THIS TABLE HAS THE PERCUSSION INSTRUMENT EQUATES AND TABLES OF REGISTER
;LOADS FOR PERCUSSION INSTRUMENTS. YOU CAN USE UP TO $1E AS THE EQUATE.  
;1F IS FOR PAUSE. THE PERCUSSION INSTRUMENTS MUST USE ALL VOICES SINCE
;THE NECESSARY SOUNDS ARE DISTRIBUTED OVER THE ENTIRE REGISTER SELECTION.
;THE TABLE OF REGISTER LOADS SPECIFIES THE BASE REGISTER TO BE USED.

.define	BSD0 0		;BASE DRUM FOR VOICE 0
.define	BSD1 1		;BASE DRUM FOR VOICE 2
.define	TOM0 2		;TOM DRUM FOR VOICE 0
.define	TOM1 3		;TOM DRUM FOR VOICE 1
.define	SN0 4		;SNARE FOR VOICE 0
.define	SN1 5		;SNARE FOR VOICE 2
.define	RIM 6		;RIM SHOT
.define	BRS 7		;BRUSH
.define	HIBELL 8	;HIGH BELL
.define	TRI 9		;HIGH TRIANGLE
.define	HH 10		;HIGH HAT VOICE 3
.define	TOM2 11		;TOM DRUM FOR VOICE 2
.define	HITOM0 12	;HIGH TOM FOR VOICE 0
.define	HITOM1 13	;HIGH TOM FOR VOICE 1
.define	LOWTOM0 14	;HIGH TOM FOR VOICE 0
.define	LOWTOM1 15	;HIGH TOM FOR VOICE 1

;THE FORMAT OF THIS TABLE IS:
;1 BYTE BASE REGISTER  4 BYTES VALUES TO WRITE THERE.

.define	PERCENABLE %00001111	;VOICES TO ENABLE FOR PERCUSSION





;*******************************************************************************
;Imported from KUNGTAB.ASM
;*******************************************************************************

.define	STATCHAR  $FE		;FOR BACKGROUND (BOTTOM OF STAT BAR)
.define	STATSPRITE  $FE	;FOR THE SPRITE (USUALLY 2 HIGH)

.define	CLOCKPHASE  3		;THIS VARIABLE CONTROLS HOW MANY TIMES PER
				;SECOND EACH ENEMY IS MOVED.  YOUR COUNTERS
				;ALSO RUN AT THIS FREQUENCY SO BE CAREFUL.
				;HERE ARE THE VALUES:
				;	    1 = 30 TIMES PER SECOND.  WILL
				;		SLOW DOWN IF MORE THAN 10
				;		ENEMIES LAUNCHED BUT NOT
				;		THAT NOTICABLE.
				;	    3 = 15 TIMES PER SECOND.	
				;	    7 = 7.5 TIMES PER SECOND

.define	XSCROLLSPEED  8	;FASTEST THE SCREEN IS ALLOWED TO SCROLL ON X.  
			;DON'T GO ABOVE 8 OR THE HERO WILL BE ABLE 
			;MAKE THE SCREEN SKIP OVER ENEMY LAUNCHES.  

.define	ERASECHAR  $40	;THE CHAR TO BLANK FILL SCREENS WITH.  MUST BE
			;BLANK IN ALL BACKGROUNDS.
                          
;NOTE:  THESE VALUES WILL HAVE TO BE CHANGED IF YOU CHANGE CLOCKPHASE.

.define	DEF_XLIM  24	;64 MAX!
.define	DEF_YLIM  64	;64 MAX IF YOUR SOLIDS ARE 1 HIGH, 120 IF 2 HIGH.
.define	DEF_GRAV  10
.define	DEF_XFRICT  16
.define	DEF_YFRICT  0
.define	XFCTR  3		;1/15 DELAY AFTER APPLYING X MOMENTUM BEFORE FRICTION
			;EACH TICK HERE ALLOWS 2 INSTRUCTIONS.
.define	YFCTR  3		;DELAY AFTER APPLYING Y MOM BEFORE FRICTION KICKS IN
.define	DEF_BOUNCE  0	;DEFAULT BOUNCE FACTOR

.define HEROID  1
.define STATGUYID  2
.define WORLDGUYID  3
.define SKELETON  4
.define MAGICGUYID  8	
.define BOSSMAN  19
.define QUIKEIGHT  20
.define EAGLEFLY  21
.define WHITEFAKE  22
.define MONGOLIAN  23
.define KNIFEJUMP  24
.define SWORDMAN  25
.define GREENCAPE  26
.define FLYBOY  27
.define NINJAFAKE  28
.define BOLTGUYID  30	;BULLET WHITEHAT SHOOTS
.define SHURIGUYID  31		;DAGGER FOR NINJA
.define BOMBGUYID  32		;BOMB THAT NINJA THROWS
.define FIREDUMMY  33
.define BOOMCHUCK  34
.define ARRMAN  36		;ARROW MAN IN CITY
.define WINDOWMAN  38		;MAN IN WINDOW ROOM
.define ROCKGUYID  41		;NEED TO MAKE A ROCK TO FALL SOME DAY
.define SMROCKGUYID  42		;SMALL ROCK THAT THE BIG ONE BLOWS UP INTO
.define SKULLGUYID  45		;THING THROWN BY BIG WIZARD
.define BIGSPGUYID  48		;THING SHOT BY BIG WIZZARD
.define LITLSPGUYID  48		;THING SHOT BY LITTLE WIZZARD
.define EWAKE  0		;WAKE UP.  
.define EHURT  10	;ENTITY HURT 
.define EFALL  20	;FALLING
.define ECMD  30		;WORLD COMMAND
.define EJUMP  40	;JUMPING
.define EATTACK  50	;ATTACKING/SHOOTING
.define EDUCK  60	;DUCKING (DOWN KEY PRESSED)
.define ESTAND  70	;STANDING
.define EWALK  80	;WALKING

;	HERE ARE SOME RECOMMENDED EXTENSIONS AND AN EQUATE YOU COULD USE:

.define ENEAR  90	;FOR A NEAR RANGE ATTACK
.define EMIDDLE  100	;FOR A MIDDLE RANGE ATTACK
.define EFAR  110	;FOR A FAR RANGE ATTACK
.define ECHARGE  120	;FOR A CHARGING ATTACK
.define EPOSE  130	;A POSE (DELAY) BEFORE AN ATTACK
.define EDODGE  140	;TO DODGE ATTACKS
.define ESHOOT  150	;SHOOTING ANIMATION
.define HURTING  $01	;(EHURT)
.define FALLING  $02	;(EFALL)
.define TESTING  $04	;FOR WORLD COMMAND (ECMD)
.define JUMPING  $08	;(EJUMP)
.define ATTACKING  $10	;(EATTACK)
.define SELECTING  $20	;SELECT KEY
.define DUCKING  $40	;(EDUCK)
.define ALL  $FF	;ALL OF THEM.
.define	COLUMN  0	;TO SPECIFY BY WORLD COLUMN
.define	ID  1		;TO SPECIFY BY ENTITY #
.define	JOY1  0		;JOYSTICK 0
.define	JOY2 1		;JOYSTICK 1
.define	OURJOY  2	;JOYSTICK OF THIS ENTITY
			;(IF NONE, WILL IGNORE CMD)
.define	KILLERSJOY  3	;JOYSTICK OF LAST ATTACKER
			;(IF NONE, WILL IGNORE CMD)
STATE = -1
;5C =	<RGB> THIS COMMAND ALLOWS YOU TO SET THE RGB AND MONO BITS THAT
;	CONTROL THE PALETTES.  REMEMBER THAT THIS EFFECTS BOTH SPRITE
;	AND BACKGROUND PALETTES.  UNFORTUNATELY, TO RESTORE THE
;	UNCHANGED PALETTE SET YOU MUST LOAD THE REGISTER WITH 0 AND
;	CALL WITH REGISTER AS THE PARAMETER.  1 BYTE FOLLOWS THIS COMMAND:
;		1 BYTE VALUE TO USE FOR RGB AND MONO BITS:
.define	RED $20
.define	GREEN $40
.define	BLUE $80
.define	MONO $01
;			OR <REGISTER> TO USE THE REGISTER'S CONTENTS.
;
;	SAMPLE USAGES:	.byte 	RGB,REGISTER	;REGISTER'S CONTENTS
;			.byte 	RGB,RED|BLUE	;RED WITH BLUE SET
;5D =	<SETBEHAVIOR> THIS COMMAND ALLOWS YOU TO SET THE INDIVIDUAL 
;	BEHAVIOR BITS.  THESE BITS CAN BE TESTED WITH THE <IFBEHAVIOR> 
;	COMMAND. THE BEHAVIOR BIT NAMES ARE JUST EQUATES.  THE BEHAVIOR BYTE
;	CAN ACCOMODATE 8 OF THEM.  THE VALUES HERE ARE JUST SUGGESTIONS.
;	1 BYTE FOLLOWS THIS COMMAND:
;		1 BYTE BEHAVIOR BIT TO SET OR <REGISTER>:
.define	INTELLIGENT $01 
.define	SHY $02
.define	WEAK $04
.define	HIJUMPER $08
.define	FAST $10
.define	MAD $20
.define	DYING $40
.define	OPTION1 $80

;IF YOU WOULD LIKE MORE GENERIC BITS TRY THESE:

.define	OPT1 $01 
.define	OPT2 $02 
.define	OPT3 $04 
.define	OPT4 $08 
.define	OPT5 $10 
.define	OPT6 $20 
.define	OPT7 $40 
.define	OPT8 $80  

STATVID = -1


;THE FOLLOWING EQUATES ARE USED TO DEFINE THE COMMAND LANGUAGE RECOMMENDED
;IN THE DOCUMENTATION ABOVE.  SOME EQUATES ARE SPECIFIED IN THE COMMAND
;BLOCK FOR EASE OF UPDATE.

.define	ACTIVATE $00
.define	RANGE $01
.define	LEDGE $02
.define	PRECIPICE $03
.define	SKIP $04
.define	SLOTS $04
.define	RANDOM $05
.define	MOMLIMIT $06
.define	DELAY $07
.define	XDIR $07
.define	YDIR $08
.define	ADDMOM $08
.define	GRAVITY $09
.define	SOLIDSTATE $0A
.define	OFF -1
.define	DONTCARE -1
.define	NOCHANGE -1
.define	ON 1
.define	SAFE 2
.define	IDENTIFY $0B
.define	BEHAVIOR $0B
.define	HERO0 $0001
.define	HERO1 $0002
.define	ENEMY $0004
.define	HELPER $0008
.define	BENIGN $0010
.define	HARMLESS $0020
.define	KILLER $0040
.define	DEADLY $0080
.define	BULLET0 $0100
.define	BULLET1 $0200
.define	BULLET $0400
.define	PLATFORM $0800
.define	HEART $1000
.define	PRIZE $2000
.define	SUPPLY $4000
.define	ASSAILANT $8000
.define	TARGET $0C
.define	XTRACK $0D
.define	NONE $00
.define	TOWARDS $01
.define	AWAY $02
.define	ORIGIN $03
.define	YTRACK $0E
.define	WORLD $0F
.define	JOYSTICK $10
.define	ADDJOYX $11
.define	XMOM $11
.define	ADDJOYY $12
.define	YMOM $12
.define	ZEROJOYX $13
.define	DEF_SOLID $13
.define	ZEROJOYY $14
.define	BUTTON $15
.define	SEQUENCE $16
.define	XLINK $16
.define	RESUME $17
.define	YLINK $17
.define	DING $18
.define	MUSTDEFEAT $18
.define	FINISH $19
.define	XDIST $19
.define	SETCOUNTER $1A
.define	YDIST $1A
.define	COUNT $1B
.define	FRICTION $1C
.define	GOTO $1D
.define	DIE $1E
.define	LAUNCH $1F
.define	STANDING $20
.define	DAMAGE $21
.define	ASSESS $22
.define	ATTACKER $23
.define	ATTACK $24
.define	SPEED $25
.define	REARM $26
.define	ATTACKED $27
.define	FRAME $28
.define	DISPLAY $29
.define	TOFRONT $00
.define	BEHIND $20
.define	WORLDCMD $2A
.define	IFPARAM $2B
.define	INSTRUCTIONS $2C
.define	SETMOM $2D
.define	TESTFLAG $2E
.define	DISABLE $2F
.define	ENABLE $30
.define	SOUND $31
.define	BOUNCE $32
.define	SETJOYX $33
.define	SETJOYY $34
.define	ACTIVE $35
.define	HURT $36
.define	ADDSCORE $37
.define	SETSCORE $38
.define	SCORE $39
.define	ADDHEROS $3A
.define	SETHEROS $3B
.define	HEROS $3C
.define	RESET $3D
.define	SETREG $3E
.define	REGISTER $00
.define	PARAM2 $00
.define	HEALTH $01
.define	ENTITY $02
.define	FETCHREG $3F
.define	ANDREG $40
.define	COMPARE $41
.define	ADD $42
.define	SETPAUSE $43
.define	TABLE $44
.define	VICTIM $45					    
.define	LOAD $46
.define	STORE $47
.define	ADDDATA $48
.define	NOISE $49
.define	SETALT $4A
.define	ALTCOUNT $4B
.define	FACE $4C
.define	CURRENT $80
.define	TRAVELING $40
.define	RISING $20
.define	JOYDIR $10
.define	BPALETTE $4D
.define	SPALETTE $4E
.define	SHAKE $4F
.define	LOWNOISE $50
.define	XVISUAL $51
.define	YVISUAL $52
.define	EQUAL $53
.define	REGINDEX $54
.define	DISSCROLL $55
.define	ENASCROLL $56
.define	SETCOL $57
.define	COMPAREDATA $58
.define	REGMOM $59
.define	EXCHANGE $5A
.define	XOR $5B
.define	RGB $5C
.define	SETBEHAVIOR $5D
.define	RESETBEHAVIOR $5E
.define	IFBEHAVIOR $5F
.define	IFNBEHAVIOR $60
.define	CREATE $61
.define	STAIR $62
.define	ANIMATION $63
.define	CHEAT $64
.define	RESETFRICTION $65
.define	FLOOR $66
.define	LINK $67
.define	UNLINK $68
.define	SPAWN $69
.define	HALFFREQ $6A
.define	IFLINKED $6B
.define	RELINK $6C
.define	TOPSTAT $6D
.define	WRITEVID $6E
.define	FILLVID $6F
.define	SETSTATPAL $70
.define	RDIVIDE $71
.define	RMULTIPLY $72
.define	GETHEROS $73
.define	SHOWSCORE $74
.define	SHOWREG $75
.define	SETHEALTH $76
.define	SOUNDBUSY $77
.define	REGSOUND $78
.define	HIDEALL $79
.define	HOWMANY $7A
.define	TESTSOLID $7B
.define	WIPEOUT $7C
.define	THROWBACK $7D
.define	GETCOLUMN $7E
.define	TABLEVID $7F
.define	LIMIT $80
.define	MOVEIN $81
.define	NOTEQUAL $82
.define	PALCLR $83
.define	SETSELECT $84
.define	CDIVIDE $85
.define	GETJOYHEALTH $86
.define	SETJOYHEALTH $87
.define	ENTITYBITS $88
.define	WORLDGOTO $89
.define	REBORN $8A
.define	IFNCHEAT $8B
.define	WHOSLINKED $8C
.define	GETSCORE $8D
.define	PUTSCORE $8E
.define	SWAP $8F
.define	PEEK $90
.define	POKE $91
.define	NOTBUTTON $92
.define	ABOVECOUNT $93
.define	IFXEDGE $94
.define	CASE $95
.define	EDGEMOM $96
.define	ANDDATA $97
.define	STATREQUEST $98		
.define	ENDREQUEST $99			
.define	IFREQUEST $9A
.define	USERSUB $9B
.define	ROTATION $9C
.define	LOWEXEC $9D
.define	XVIRTUAL $9E		; (DON'T COMMENT OUT UNLESS YVIRTUAL ALSO)
.define	YVIRTUAL $9F
.define	BVIRTUAL $A0
.define	BLOAD $A1
.define	LINKMOM $A2
.define	DISTANCE $A3		
.define	LINKFACE $A4
.define	READCHAR $A5
.define	REGLAUNCH $A6
.define	WHOSTHERE $A7
.define	ALIGNXY $A8
.define	MOVEOVER $A9

;YOU CAN COMMENT OUT ANY THESE DEFINES AND THE REQUIRED CODE WILL
;NOT ASSEMBLE.  USE THIS TO FREE UP MEMORY IN EMERGENCY CASES.

;DEFINE( XDISPLAY,-1)
;DEFINE( XADDSCORE,-1)
;DEFINE( XSETSCORE,-1)
;DEFINE( XSCORE,-1)
;DEFINE( XVICTIM,-1)
;DEFINE( XDISSCROLL,-1)
;DEFINE( XSETCOL,-1)
;DEFINE( XCOMPAREDATA,-1)
;DEFINE( XRGB,-1)
;DEFINE( XSHOWSCORE,-1)
;DEFINE( XGETSCORE,-1)
;DEFINE( XPUTSCORE,-1)
;DEFINE( XPEEK,-1)
;DEFINE( XPOKE,-1)
;DEFINE( XEDGEMOM,-1)
;DEFINE( XUSERSUB,-1)
;DEFINE( XLOWEXEC,-1)
;DEFINE( XXVIRTUAL,-1)		; (DON'T COMMENT OUT UNLESS YVIRTUAL ALSO)
;DEFINE( XYVIRTUAL,-1)
;DEFINE( XBVIRTUAL,-1)
XBLOAD = -1;DEFINE( XBLOAD,-1)
;DEFINE( XLINKMOM,-1)
;DEFINE( XLINKFACE,-1)
XREADCHAR = -1;DEFINE( XREADCHAR,-1)
XREGLAUNCH = -1;DEFINE( XREGLAUNCH,-1)
;DEFINE( XWHOSTHERE,-1)
;DEFINE( XALIGNXY,-1)
;DEFINE( XMOVEOVER,-1)