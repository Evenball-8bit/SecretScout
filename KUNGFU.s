;NEXT:
;3. CAN POSSIBLE REMOVE WORLDCOL AND USE TESTCOL.

;.COMMAND -w142
;		NES KUNG FU GAME STATE MACHINE
;
;COPYRIGHT 1990 BY DANIEL LAWTON, ALL RIGHTS RESERVED.
;LAST UPDATE STARTED ON 9/15/90

;			HOW THIS STATE MACHINE WORKS:
;
;TO ASSEMBLE, YOU JUST RUN A65 KUNGFU.  THE KUNGFU.ASM FILE "INCLUDES"
;ALL NECESSARY FILES.  THESE FILES ARE KUNGSUBS.ASM, KUNGTAB.ASM,
;YOURBACK.ASM, YOURCODE.ASM, YOURSND.ASM, AND DRAWDATA.ASM.  
;YOURBACK AND DRAWDATA ARE MADE AUTOMATICALLY
;BY THE ND.EXE DRAWING PROGRAM.  YOURBACK HAS BACKGROUND DATA FOR THE
;SECOND ROM PAGE AND DRAWDATA HAS PALETTE/SPRITE DEFFINITIONS.  KUNGSUBS
;HAS SUBROUTINES THAT GO DIRECTLY TO THE HARDWARE.  KUNGFU IS THE STATE
;MACHINE EXECUTION MAINLINE.  KUNGTAB IS WHERE YOU PUT YOUR GAME PLAY
;DATA.  YOURCODE AND YOURSND ARE EXPLAINED AT THE TOP OF KUNGTAB.ASM.
;THE RESULT OF THE ASSEMBLY IS CODE.PRG WHICH IS LOADED WITH
;THE COLOR DREAMS DEBUGGER BOARD FOR THE NES.  IT WILL HAVE 2 32K SEGMENTS
;EACH WITH A 6 BYTE HEADER.  THE FIRST LOADS INTO PAGE 0 AND THE SECOND
;INTO PAGE 1.  YOU MUST ALSO HAVE YOUR .VID FILE WHICH IS ALSO CREATED
;AUTOMATICALLY BY THE DRAWING PROGRAM.
;
;THE STATE MACHINE USES THE DATA YOU PLACE IN KUNGTAB TO EXECUTE THE 
;GAME.  THERE ARE 3 MAIN THINGS YOU DO IN KUNGTAB.  YOU DEFINE WORLDS
;WHICH ARE BACKGROUNDS AND PALETTES.  YOU DEFINE "ENTITIES" WHICH ARE
;MOVING SPRITES.   FINALLY, YOU DEFINE THINGS IN THE BACKGROUND WHICH
;INTERACT WITH THE SPRITES.  YOU NEED TO CHECK OUT KUNGTAB.ASM AND SIMPLY
;GO THROUGH IT LINE BY LINE SETTING THE DEFINED PARAMETERS IF YOU WANT
;LEARN TO USE THE STATE MACHINE.  THIS MODULE SHOULD OPERATE TRANSPARENTLY
;TO YOU, YOU SHOULD NOT MAKE MODIFICATIONS HERE.  

;AT BOOT THIS PROGRAM SIMPLY ACTIVATES WORLD #0 AND ITS UP TO YOU TO
;DETECT RESET, INITIALIZE FLAGS, AND LOOK FOR THE START KEY. 
;CHECKOUT KUNGTAB AND BE METHODICAL ABOUT SETTING AND UNDERSTANDING 
;EACH ENTRY.

;			PROGRAMMER'S WARNING
;
;ALL PROCESSING OF ENTITY MOVEMENTS AND WORLD SCROLL TAKES PLACE OUTSIDE
;NMI.  DURING NMI WE ONLY SUPPORT JOYSTICKS (WHICH ONLY SET VARIABLES
;AND FLAGS).  ALSO, NMI KEEPS THE TIME FOR THE MAINLINE BY SETTING 
;TIMETICK AND PHASE4.  YOU CAN'T MIX
;LEVELS ON CALLS TO THE KUNGSUBS IN SOME CASES.  THINK ABOUT IT BEFORE
;YOU ADD CUSTOM CODE.
;
.include "ScoutDEF.h"
ROMVER = -1
.feature force_range
;INCLUDE( KUNGSUBS.ASM)
;**********************************************************************************************
;Stuff moved here from Kungsubs - Evenball
;**********************************************************************************************
;.CODE				;SPECIFY CODE SEGMENT IN CASE OF PAGEING
.segment "BANK_00"


;.ORG	$8000		;CODE ROM PROGRAM ORIGIN.

;************************** BOOT VECTOR ************************
;
;THIS BOOT VECTOR IS FOR THE SUBROUTINES.  DON'T PUT YOUR CODE HERE,
;PUT IT IN THE LEGAL BOOT SUBROUTINE "USER_BOOT" AT THE END OF THIS ASSEMBLY.

;THIS ROUTINE SIMPLE DISABLES VIDEO AND NMI, WAITS FOR THE VIDEO PROCESSOR
;TO RESET, AND THEN INITIALIZES OUR VARIABLES.  CODE WILL EVENTUALLY
;BE ADDED TO WORK IN CONJUNCTION WITH SPECIAL FEATURES OF THE COLOR
;DREAMS INC. CARTRIDGES BUT THIS IS NOT YET RELEASED INFO.

BOOT:	SEI			;DISALLOW IRQ INTERRUPTS

	LDA	#0
	STA	$2000		;MAKE SURE NMI INTS ARE OFF

;WAIT FOR VIDEO SYNC PULSES. WE NORMALLY JUST NEED TO DO THIS AT BOOT
;TO WAIT FOR THE VIDEO TO GET OUT OF RESET.  AFTER THIS KEY CHIP LOGIC
;THIS IS PROBABLY UNNECESSARY.

	JSR	VERT_WAIT	
	JSR	VERT_WAIT	;WAIT FOR 2 TO MAKE SURE BIT IS VALID

	LDA	#6
	STA	$2001

;THIS ROUTINE GENERATES 2 PULSES TO DRIVE THE NINTENDO KEY CHIP FOILER.
;THE PULSES MUST BE ON THE LS377 PIN Q3 WITH PIN Q2 USED AS A BLEED TO
;RAISE THE KEY INPUT BACK TO +5.  THE PAGEING SOFTWARE MUST KEEP THESE
;PINS HIGH WHEN NOT IN USE.

	JSR	XPULSE
	JSR	XPULSE
	LDA	#12
	STA	TWELVE
	JMP	XEXIT

;THIS ROUTINE GENERATES A .005 SECOND HIGH AND THEN LOW PULSE.

XPULSE:	LDA	#8
	STA	EIGHT
	JSR	DELAY005
	LDA	#0
	STA	ZERO
	JSR	DELAY005
	RTS

;THIS ROUTINE DELAYS .0025 SECONDS.

DELAY005:
      	LDY	#4
	LDX	#58		;(MAKES 3*256 + 1*58)
XXX10:	DEX
	BNE	XXX10
	DEY
	BNE	XXX10
	RTS

ZERO:	.byte	0
EIGHT:	.byte	8
TWELVE:	.byte	12

XEXIT:	

;INITIALIZE THE VARIABLES WE USE.

	LDA	#0
	STA	NEW_PAL		;RESET FLAG OF PALETTE NEEDS INIT
	STA	SCCNT		;ZERO DATA TO WRITE TO SCREEN
	STA	XSCROLL
	STA	YSCROLL		;ZERO SCROLL
	STA	CURX
	STA	CURY		;ZERO BACKGROUND SCROLL LOW VALUES FOR PUTSPRT
	STA	BACKVALID
	STA	MOVEBACK	;RESET FLAG TO SCROLL BACKGROUND
	STA	BPAL_BLINK
	STA	SPAL_BLINK	;PREVENT PALETTE UPDATES
	STA	J1FLAGS
	STA	J2FLAGS
	STA	J1HOLD
	STA	J2HOLD
	STA	J1REPFLG
	STA	J2REPFLG	;RESET BUTTON LOGIC
	STA	REG2000		;AND ZERO SCREEN PAGE 
	STA	DOUBLE_BIT
	STA	REG4015		;AND SOUND ENABLE REG
	STA	SPYADJ
	STA	BASESPRITE
	STA	ROTATEFLG
	STA	ROTATING
	STA	SHAKEAMT
	STA	STATBANK
	STA	STATBITS
	STA	BACKBANK
	STA	BACKBITS

	LDA	#REPRATE
	STA	REPCNT		;RELOAD THE JOYSTICK REPEAT RATE

	LDA	#10
	STA	STATDELAY

	LDA	#$18
	STA	REG2001		;SET UP FOR SPRITES, BACKGROUND, NO ODD COLORS
				;AND 31 COL MODE FOR ALL.

	JSR	HIDESPRITES	;FREE UP AND HIDE THE SPRITES
	JSR	ZERO_ANIM	;CLEAR THE ANIMATION RAM
	JSR	ZERO_SOUND

;CALL THE USER'S BOOT CODE.

	JSR	USER_BOOT

;ALLOW NMI INTERRUPTS.

	JSR	RESUME_NMI

;NON-INTERRUPT MAINLINE.  WE TAKE LIGHT GUN SAMPLES AND
;CALL THE USER NON-NMI PROGRAM.

B1000:	JSR	USER_MAINLINE
	JMP	B1000

;************************ NMI INTERRUPT ***************************
;
;THIS IS THE NMI SERVICE ROUTINE.  IT COMPLETELY CONTROLS ALL WRITES
;TO THE SCREEN AND YOUR CODE SHOULD NOT VIOLATE THIS SCHEME OR YOU
;MAY LOOSE COMPATIBILITY WITH THESE SUBS.  IF YOU WANT TO DO PROCESSING
;UNDER NMI (AND IT IS STRONGLY RECOMMENDED THAT ALL OF YOUR PROCESSING
;IS DONE IN THIS MANNER) PUT YOUR CODE INTO THE ROUTINE "USER_NMI"
;AT THE END OF THIS ASSEMBLY.  IF YOU WANT TO WRITE TO RAM, FOLLOW
;THE RULES FOR PUTTING DATA INTO SCNBUF.  SEE THE COMMENTS ON SCNBUF
;IN THE RAM EQUATES.


;THIS NMI ROUTINE USES THE FOLLOWING STRATIGY:
;
;1. ALL DATA TO WRITE TO SCREEN IS KEPT IN A BUFFER WHICH CANNOT
;HOLD MORE THAN CAN BE SUCCESSFULLY WRITTEN.  AT NMI START, THE
;SPRITES DMA TRANSFER IS STARTED AND THEN WHATEVER IS QUED IN THE
;BUFFER IS WRITTEN.  THEN VIDEO IS RE-ENABLED (BUT NOT NMI INTS).
;
;2. ROUTINES THAT SET FLAGS TO GET PROCESSOR POWER OFF THE NMI TICK
;ARE CALLED IF THEIR FLAGS ARE SET.  THEY ONLY CALCULATE AND PUT DATA
;INTO THE SCREEN BUFFER, THEY NEVER ACCESS VIDEO DIRECTLY.  IF THEY 
;CANNOT FIT THEIR DATA IN THE BUFFER THEY IGNORE THIS NMI.
;
;3. THE JOYSTICK IS CHECKED AND THE USER JOYSTICK ROUTINES ARE CALLED
;FOR ALL CHANGES.
;
;4. THE USER PROGRAM NMI PROCESSOR ROUTINE IS CALLED.  THIS ROUTINE
;MUST ALSO USE ONLY THE BUFFER OR THE SUBROUTINES AND MUST NOT WRITE
;TO VIDEO.

;TRANSFER THE DMA AND WRITE OUT THE SCREEN BUFFER.

NMI:	LDA	#06		
	STA	$2001		;DISABLE VIDEO TO ALLOW SCREEN ACCESS

	LDA	PUTBAR		;GET ROW TO PUT IT ON
	SEC
	SBC	SHAKEAMT
	STA	STATSPR		;ALWAYS REPOSITION THE TOP SPRITE IF STAT BAR

	LDA	ROTATING	;DON'T DO THE DMA IF ROTATING FLAG SET
	BNE	N10
	STA	$2003		;ZERO SPRITE DMA BASE REG
	LDA	#STATSPR >> 8	;GET PAGE OF SPRITE RAM
	STA	$4014		;START THE SPRITE RAM DMA TRANSFER

N10:	JSR	STOP_NMI		;DISABLE NMI

	LDA	$2002		;RESET ADDRESS REG SELECT FOR THROUGHOUT NMI.
	AND	#$20
	STA	TOOMANY		;KEEP SPRITE FLICKER BIT

	TXA	
	PHA
	TYA
	PHA			;SAVE THE REGISTERS

	JSR	WRITE_SCNBUF	;WRITE OUT ANY DATA IN SCNBUF
 	LDA	#0
	STA	SCCNT

	LDA	MATH1
	PHA
	LDA	MATH2
	PHA			
	LDA	MATH3
	PHA			
	LDA	MATH4
	PHA			;SAVE MATH SUBS VARIABLES

	JSR	MAKE_SCROLL	;SCREEN UPDATED, MAKE ANY NEW SCROLL NEEDED

;DONE WRITING OUT THE SPRITE AND SCREEN DATA.  USE THE CORRECT LOGIC
;TO ENABLE VIDEO AND SCROLL AS NEEDED.  THE 2 POSSIBILITIES ARE
;TOP OF SCREEN STATUS BAR OR NONE.  WE JUST CALL A ROUTINE THAT IS
;SELECTIVELY LOADED DURING ASSEMBLY.

N100: 	JSR	FINISH_TOP

;VIDEO IS ENABLED.  CALL ROUTINES THAT DO PROCESSING WHEN ACTIVATED
;BY FLAGS.  WE HAVE TO PRIORITIZE THEM.

;WE FIRST SAVE OFF A FEW MEMORY VARIABLES THAT ARE DEFINED TO BE USABLE
;BY ALL.

	LDA	SUBSVAR1
	PHA
	LDA	SUBSVAR2
	PHA
	LDA	SUBSVAR3
	PHA
	LDA	SUBSVAR4
	PHA
	LDA	SUBSVAR5
	PHA			
	LDA	SUBSVAR6
	PHA			;SAVE SUB VARIABLES SO THAT THE SUBS MAY
				;BE USED FROM ANY LEVEL.

	LDA	FETCHCOL
	PHA
	LDA	FETCHCOL+1
	PHA
	LDA	FETCHROW
	PHA

	JSR	SWAPPTRS	;SWAP THE IMPORTANT BACKGROUND SCANNERS

;CHECK FOR JOYSTICK CHANGES.

	LDA	#1
	STA	$4016
	LDA	#0
	STA	$4016		;LATCH A VALUE TO SHIFT.  ALSO LATCHES 4017.

	LDA	#0
	STA	J1CHANGE	;ZERO RESULT
	LDX	#8
N200:	LDA	$4016
	ROR	A
	ROL	J1CHANGE	;MOVE BIT UP INTO OUR BYTE
	DEX
	BNE	N200
	LDA	J1CHANGE	;GET NEW VALUE
	TAX			;SAVE NEW VALUE
	EOR	J1FLAGS		;GET CHANGES
	STA	J1CHANGE	;SAVE CHANGES
	STX	J1FLAGS		;AND CURRENT STATE

	LDA	#0
	STA	J2CHANGE	;ZERO RESULT
	LDX	#8
N210:	LDA	$4017
	ROR	A
	ROL	J2CHANGE	;MOVE BIT UP INTO OUR BYTE
	DEX
	BNE	N210
	LDA	J2CHANGE	;GET NEW VALUE
	TAX			;SAVE NEW VALUE
	EOR	J2FLAGS		;GET CHANGES
	STA	J2CHANGE	;SAVE CHANGES
	STX	J2FLAGS		;AND CURRENT STATE

;DO THE NECESSARY AUTOREPEAT LOGIC. 
;FIRST WE RESET ANY AUTOREPEATING KEYS THAT ARE NO LONGER DOWN.

	LDA	J1FLAGS
	AND	J1REPFLG	
	STA	J1REPFLG
	LDA	J1FLAGS
	AND	J1HOLD
	STA	J1HOLD		;RESET ANY NO LONGER DOWN IN JOYSTICK 1 FLAGS

	LDA	J2FLAGS
	AND	J2REPFLG
	STA	J2REPFLG
	LDA	J2FLAGS
	AND	J2HOLD
	STA	J2HOLD		;RESET ANY NO LONGER DOWN IN JOYSTICK 2 FLAGS

;SEE IF THE REPEAT COUNTER HAS RUN DOWN.  

	DEC	REPCNT		;COUNT DOWN THE REPEAT COUNTER
	BNE	N215		;SKIP IF NOT TIME TO REPEAT AGAIN.
	LDA	#REPRATE
	STA	REPCNT		;RELOAD IT

	LDA	J1REPFLG	;GET THE REPEATING KEYS
	ORA	J1CHANGE
	STA	J1CHANGE	;SET AS IF ITS A CHANGED KEY

	LDA	J2REPFLG	
	ORA	J2CHANGE
	STA	J2CHANGE

	LDA	J1HOLD		;GET KEYS WAITING TO AUTOREPEAT NEXT PASS
	AND	#J1REPENA	;BUT ONLY WANT THOSE ENABLED TO REPEAT
	STA	J1REPFLG	;SET TO REPEAT NEXT COUNT
	LDA	J1FLAGS
	STA	J1HOLD		;MOVE CURRENT STATE INTO THE HOLDING FLAG

	LDA	J2HOLD		;GET KEYS WAITING TO AUTOREPEAT NEXT PASS
	AND	#J2REPENA	;BUT ONLY WANT THOSE ENABLED TO REPEAT
	STA	J2REPFLG	;SET TO REPEAT NEXT COUNT
	LDA	J2FLAGS
	STA	J2HOLD		;MOVE CURRENT STATE INTO THE HOLDING FLAG

;CALL THE USER JOYSTICK ROUTINES TO SERVICE ANY CHANGED BUTTON.
;IF YOU WANT TO GET ONLY BUTTONS THAT GO DOWN, REMOVE THE COMMENT FROM
;THE AND INSTRUCTION IMMEDIATLY PRECEEDING THE BIT TESTS.

N215: 	LDA	J1CHANGE	;GET JOYSTICK 1 CHANGES
	AND	J1FLAGS		
	BEQ	N240		;SKIP IF NO JOYSTICK CHANGES THIS PASS.

	ROR	J1CHANGE
	BCC	N220
	JSR	RIGHT1
N220:	ROR	J1CHANGE
	BCC	N221
	JSR	LEFT1
N221:	ROR	J1CHANGE
	BCC	N222
	JSR	DOWN1
N222:	ROR	J1CHANGE
	BCC	N223
	JSR	UP1
N223:	ROR	J1CHANGE
	BCC	N224
	JSR	STRT1
N224:	ROR	J1CHANGE
	BCC	N225
	JSR	SEL1
N225:	ROR	J1CHANGE
	BCC	N226
	JSR	B1		
N226:	ROR	J1CHANGE
	BCC	N240
	JSR	A1

N240:	LDA	J2CHANGE	;GET JOYSTICK 2 CHANGES
	AND	J2FLAGS		
	BEQ	N260

	ROR	J2CHANGE
	BCC	N250
	JSR	RIGHT2
N250:	ROR	J2CHANGE
	BCC	N251
	JSR	LEFT2
N251:	ROR	J2CHANGE
	BCC	N252
	JSR	DOWN2
N252:	ROR	J2CHANGE
	BCC	N253
	JSR	UP2
N253:	ROR	J2CHANGE
	BCC	N254
	JSR	STRT2
N254:	ROR	J2CHANGE
	BCC	N255
	JSR	SEL2
N255:	ROR	J2CHANGE
	BCC	N256
	JSR	B2
N256:	ROR	J2CHANGE
	BCC	N260
	JSR	A2

;CALL THE KUNGFU NMI ROUTINE.  ITS THE ONE THAT MIGHT MAKE US NEED TO SCROLL

N260:  	LDA	a:BPAUSE		;IF PAUSED, DON'T DO ANY OF IT.
	BNE	N380

	JSR	USER_NMI
 	JSR	DOSCRL		;SCROLL THE BACKGROUND IF NEEDED
	JSR	DOPAL		;UPDATE PALETTES IF NEEDED

	LDA	ROTATING	;DON'T DO THE DMA IF ROTATING FLAG SET
	BNE	N265
	JSR	CHECK_ANIM	;SEE IF ANIMATIONS NEED PROCESSING
N265:
	JSR	FEED_SOUND	;FEED THE SOUND CHIP

;DONE WITH THIS NMI.  RESTORE REGS AND REENABLE NMI INTERRUPTS.

N380: 	JSR	SWAPPTRS	;SWAP THE IMPORTANT BACKGROUND SCANNERS

	PLA
	STA	FETCHROW
	PLA	
	STA	FETCHCOL+1
	PLA
	STA	FETCHCOL

 	PLA
 	STA	SUBSVAR6
 	PLA
 	STA	SUBSVAR5
 	PLA
 	STA	SUBSVAR4
 	PLA
 	STA	SUBSVAR3
 	PLA
 	STA	SUBSVAR2
 	PLA
 	STA	SUBSVAR1	

	PLA
 	STA	MATH4
 	PLA
 	STA	MATH3
 	PLA
 	STA	MATH2
 	PLA	
 	STA	MATH1

 	PLA
 	TAY
 	PLA
	TAX

	JSR	RESUME_NMI

	RTS			;WE RTS TO PNMI WHICH RTIs

;THIS SUBROUTINE IS CALLED TO SWAP THE IMPORTANT BACKGROUND LINK AND SCAN
;VARIABLES WITH THE EXTRA COPY.  IT IS CALLED AT THE START AND END OF
;NMI SO THAT WE CAN SCROLL FASTER AND WITHOUT DISTURBING SOLID CHECKING
;THAT TAKES PLACE OUTSIDE NMI.

SWAPPTRS:
	LDA	WORLDSPOT
	LDX	XWORLDSPOT
	STA	XWORLDSPOT
	STX	WORLDSPOT

	LDA	WORLDSPOT+1
	LDX	XWORLDSPOT+1
	STA	XWORLDSPOT+1
	STX	WORLDSPOT+1

	LDA	SPOTCOL
	LDX	XSPOTCOL
	STA	XSPOTCOL
	STX	SPOTCOL

	LDA	SPOTCOL+1
	LDX	XSPOTCOL+1
	STA	XSPOTCOL+1
	STX	SPOTCOL+1

	LDA	BACKBASE
	LDX	XBACKBASE
	STA	XBACKBASE
	STX	BACKBASE

	LDA	BACKBASE+1
	LDX	XBACKBASE+1
	STA	XBACKBASE+1
	STX	BACKBASE+1

	LDA	BPBASE
	LDX	XBPBASE
	STA	XBPBASE
	STX	BPBASE

	LDA	BPBASE+1
	LDX	XBPBASE+1
	STA	XBPBASE+1
	STX	BPBASE+1

	LDA	BACKSIZE
	LDX	XBACKSIZE
	STA	XBACKSIZE
	STX	BACKSIZE

	LDA	BACKWIDE
	LDX	XBACKWIDE
	STA	XBACKWIDE
	STX	BACKWIDE

	LDA	BACKHIGH
	LDX	XBACKHIGH
	STA	XBACKHIGH
	STX	BACKHIGH

	LDA	BPWIDE
	LDX	XBPWIDE
	STA	XBPWIDE
	STX	BPWIDE

	RTS

;			TOP OF SCREEN STATUS BAR LOGIC
;
;THIS ROUTINE WILL MOVE SPRITE #0 TO THE CORRECT LOCATION FOR TOP OF
;SCREEN STATUS BAR AND WILL MARK IT AS IN USE.  IT IS CALLED AT BOOT
;AFTER THE SPRITES ARE FREED UP AND AFTER EACH TOPSTAT COMMAND IN
;KUNGFU.ASM.  SPRITE 0 IS ALWAYS MARKED AS IN USE, EVEN IF WE HAVE NO
;TOP OF SCREEN STATUS BAR.

TOPSPRITE:
	LDA	PUTBAR		;GET ROW TO PUT IT ON
	STA	STATSPR
	LDA	#1		;SET SPRITE TO CREEP OUT OF INVISIBLE FIRST 
	STA	STATSPR+3	;COLUMN BY ONLY 1 PIXEL.
	LDA	#STATSPRITE	;AND GET A SOLID LINE SPRITE
	STA	STATSPR+1
	LDA	#$28		;PUT IT BEHIND ANYTHING ELSE, MARK IN USE.
	STA	STATSPR+2
TPS10:	RTS

;THIS ROUTINE PROVIDES THE ACTUAL TOP OF SCREEN STATUS BAR SUPPORT.

;FIRST WE MAKE SURE OUR CHAR IS STILL THERE.  WE ALWAYS PUT ONE THERE
;FOR SAFETY REASONS.

FINISH_TOP:

	LDA	STARTSTAT	;SEE IF WE HAVE A STATUS BAR
	BNE	FT01		;IF SO, GO MAKE ONE

	LDA	XSCROLL
	STA	$2005		;IF NOT, SELECT THE NORMAL X SCROLL
	LDA	YSCROLL
	STA	$2005		;SELECT THE NORMAL Y SCROLL
	LDA	REG2001
	STA	$2001		;ENABLE VIDEO 
	JMP	FT35

FT01:	LDA	$2002
	LDA	#$27
	STA	$2006
	LDA	#$A0	
	STA	$2006		;ADDRESS LAST ROW OF SCREEN BUFFER, FIRST CHAR
	LDA	#STATCHAR
	STA	$2007		;AND WRITE OUT THE CHAR TO DETECT AS SOLID

;SELECT THE VIDEO BANK USED FOR THE TOP OF SCREEN STATUS BAR. THEN 
;SET THE SCREEN SCROLL TO DISPLAY THE STATUS BAR REGION AND ENABLE 
;VIDEO.  OUR STATUS BAR LOGIC PUTS THE SPRITE COLLISION DETECTION
;ON THE START OF THE LINE EXCEPT THAT IT CREEPS OUT OF THE INVISIBLE
;FIRST COLUMN (WE RUN WITH THE LEFT COLUMN INVISIBLE) BY ONLY 1 PIXEL.
;WE SELECT THE LAST PIXEL OF THE FIRST VIDEO PAGE THUS MAKING ONLY
;1 SMALL DOT DISPLAY OF OUR COLLISION SPRITE.  THIS ALSO GIVES US
;A FULL LINE SCAN TIME (59 MICROSECONDS) TO CHANGE THE X SCROLL.
 
	LDA	STATBANK
	LDY	STATINDX
	JSR	SELPAGE		;SELECT THE PAGE ACCORDING TO ROM OR ROMLESS

	LDA	REG2000
	AND	#$E7
	ORA	STATBITS
	STA	REG2000		;SET UPPER/LOWER BANK BITS FOR THE STATUS
				;BAR VIDEO BANK.

	AND	#$FE
	STA	$2000	;SELECT FIRST SCREEN PAGE BUT SCROLL TO LAST PIXEL

	LDA	REG2001
	STA	$2001	;ENABLE VIDEO 

	LDA	#255	;SET SCROLL THAT JUST MAKES 1 PIXEL TO RIGHT OF
	STA	$2005	;THE INVISIBLE ZONE SO WE CAN GET 1 PIXEL COLLISION
	LDA	STARTSTAT	
	CLC
	ADC	SHAKEAMT
	STA	$2005		;MOVE VERTICAL ALONG WITH SHAKE 

;NOW WAIT FOR THE BIT TO GO OFF THEN ON.

	LDY	#10
	LDA	#$40
FT31:	BIT	$2002
	BEQ	FT32		;WAIT FOR 40H TO GO OFF
	DEX
	BNE	FT31		;OR FOR A TIMEOUT
	DEY
	BNE	FT31
	JMP	FT33

	LDY	#10
FT32:	BIT	$2002
	BNE	FT33
	DEX
	BNE	FT32
	DEY
	BNE	FT32

;IT CHANGED STATE.  SET THE NEW SCROLL VALUES

FT33:	LDX	STATDELAY
FT33A:	DEX
	BNE	FT33A		;DON'T KNOW WHY BUT DELAY CLEARS UP JUNK

	LDA	XSCROLL
	STA	$2005		;SELECT THE NORMAL X SCROLL
	LDA	YSCROLL
	STA	$2005		;SELECT THE NORMAL Y SCROLL

FT35:	LDA	REG2000
	AND	#$E7
	ORA	BACKBITS
	STA	REG2000		;SET UPPER/LOWER BANK BITS FOR THESE SETS
	STA	$2000		;FIX THE PAGE # TO WHAT USER WANTED

	LDA	BACKBANK
	LDY	BACKINDX
	JSR	SELPAGE		;SELECT THE PAGE ACCORDING TO ROM OR ROMLESS

	RTS

;********************* SUBROUTINE AREA ***************************
;
;THIS AREA CONTAINS BOTH ROUTINES YOU MAY CALL AS DOCUMENTED IN 
;THE SUBS.DOC AND ALSO SUPPORT ROUTINES USED BY THE SUBS THEMSELVES.
;DON'T PUT ANY OF YOUR CODE HERE OR YOU WILL BECOME INCOMPATIBLE WITH
;NEW RELEASES.


;THIS ROUTINE WILL PLAY (ACTIVATE) THE SOUND STRUCTURE POINTED TO BY
;Y:X.  THE SLOT TO PLAY IT IN IS PASSED IN A.  A RETURNS Z IF SUCCESS
;AND NZ IF FAILURE.  THE VALUES FOR A ARE:

;0 AND Z IF SUCCESS.
;-1 IF THE SOUND SLOT # WAS INVALID (OVER RANGE).
;1 IF THE SLOT WAS ALREADY IN USE (USE SILENCE TO FREE THE SLOT).

PLAY:  	STX	SUBSVAR1
	STY	SUBSVAR2	;SAVE ENTRY POINTERS
	JSR	SNDINDX		;IN RANGE?
	BEQ	P10
	RTS

P10:	LDA	SND_RAM+SF,X	;IN USE?
	BPL	P20
	LDA	#1		;IF IT IS, RETURN 1
	RTS

P20:	LDA	#1
	STA	SND_RAM+ST,X	;SET NEXT NMI TO ACTIVATE SOUND
	LDA	#0
	STA	SND_RAM+SI,X	;SET INSTRUMENT 0 AS DEFAULT
	STA	SND_RAM+LOP,X	;ZERO LOOP COUNTER
	LDA	SUBSVAR1
	STA	SND_RAM+SBL,X
	STA	SND_RAM+SOL,X	;SET LOW OFFSET
	LDA	SUBSVAR2
	STA	SND_RAM+SBH,X
	STA	SND_RAM+SOH,X	;SET HIGH OFFSET
	LDA	#$C0
	STA	SND_RAM+SF,X	;SET AS ACTIVE SOUND STRUCTURE BUT NO REG.
	RTS

;THIS ROUTINE IS USED AT BOOT TO ZERO THE SOUND CONTROL RAM. SILENCE
;CANNOT BE USED BECAUSE THE DATA WILL BE INTERPRETED AND IT IS INVALID AT
;THAT TIME.

ZERO_SOUND:
 	LDA	#0
	STA	DRUMLOCK
	TAX
ZS10:	STA	SND_RAM,X
	INX
	CPX	#SNDMEM		;SEE IF DONE
	BNE	ZS10
	RTS

;THIS ROUTINE WILL SILENCE (FREE UP) THE SOUND SLOT SPECIFIED BY A.
;IT IS OK TO SILENCE A SOUND THAT IS NOT ACTIVE.  ON RETURN A=0 AND Z 
;IF SUCCESS OR A=-1 AND NZ IF INVALID SLOT #.

SILENCE:
	CMP	#-1		;SILENCE ALL?
	BNE	S10

ALLSILENCE:
	LDA	#0
S5:	PHA
	JSR	SILENCE		;IF SO, LOOP WITH ALL VALUES
	BNE	S7
	PLA
	CLC
	ADC	#1
	JMP	S5
S7:	PLA
	LDA	#0		;AND RETURN OK.
	RTS

S10:	JSR	SNDINDX
	BEQ	S20	
	RTS			;IF BAD INDEX, RETURN -1

;INTERNAL CALL LOCATION IF X HAS A VALID SLOT NUMBER TO SILENCE.

S20:  	LDA	SND_RAM+SF,X	;GET THE FLAG BYTE
	BPL	S50		;SKIP IF NOT IN USE

;THIS SLOT WAS ACTIVE.  IF IT WAS NOT ACTUALLY PLAYING WE ARE DONE BUT
;IF IT WAS PLAYING, WE MIGHT HAVE TO REACTIVATE ANOTHER SUSPENDED SOUND
;SLOT.  WE SCAN THE LIST FROM THE TOP DOWN AND ONLY REACTIVATE THE FIRST
;WE FIND.

	TAY			;SAVE A COPY
	AND	#$60		;SEE IF NOT ASSIGNED OR IF SUSPENDED
	BEQ	S25		;SKIP IF TRULY ACTIVE
	LDA	#0
	STA	SND_RAM+SF,X	;IF INACTIVE, JUST FREE IT UP
	JMP	S50		;IF THIS ONE'S INACTIVE, IT DIDN'T SUSPEND ANY

S25:  	JSR	DISABLE_VOICE	;IF ACTIVE, DISABLE IT'S VOICE
	LDA	SND_RAM+SF,X	;GET BACK IT'S FLAG
	PHA			;SAVE THE FLAG
	LDA	#0
	STA	SND_RAM+SF,X	;FREE UP THIS SOUND STRUCTURE
	PLA
	AND	#$1F		;KEEP BASE OF REGISTERS IN USE
	STA	SUBSVAR1	;SAVE HERE FOR COMPARE TO ONES WE FIND
	CMP	#$1F		;PERCUSSION?
	BEQ	S50

	LDX	#0		;START AT LOWEST SLOT

S30:	TXA
	PHA
	LDA	SND_RAM+SF,X	;GET ITS FLAG BYTE
	BPL	S42		;IF NOT IN USE, SKIP IT

	AND	#$20		;SEE IF SUSPENDED
	BEQ	S42		;WE DON'T CARE UNLESS IT IS
	LDA	SND_RAM+SF,X
	AND	#$1F		;GET THE VOICE IT WAS USING
	EOR	SUBSVAR1	;SEE IF SAME AS OURS
	BNE	S42		;IF NOT, WE DON'T CARE
	PLA			;IF IT WAS, DISCARD SLOT INDEX
	JSR	INITSND		;AND INITIALIZE IT
	JSR	ENABLE_VOICE
	LDA	SND_RAM+SF,X
	AND	#$DF
	STA	SND_RAM+SF,X	;AND MARK AS NOT SUSPENDED ANY MORE
	JMP	S50

S42:	PLA
	CLC
	ADC	#SND_WIDE
	TAX
	CMP	#SND_WIDE*SNDSLOTS	;SEE IF DONE WITH LIST
	BCC	S30			;DO NEXT
	JMP	S50

S45:	PLA			;IF LIST END, DONE
S50:	LDA	#0
	RTS

;THIS ROUTINE WILL CHECK THE STATUS OF THE SOUND SLOT IN A.  ON RETURN:
;A=0 AND Z IF NOT IN USE
;A=1 AND NZ IF IN USE
;A=-1 AND NZ IF INVALID SLOT #

PLAYING:
	JSR	SNDINDX		;IN RANGE?
	BNE	PL10
	LDA	SND_RAM+SF,X	;IN USE?
	BMI	PL20
	LDA	#0
PL10:	RTS
PL20:	LDA	#1		;IF IT IS, RETURN 1
	RTS

;THIS ROUTINE IS CALLED TO INITIALIZE A NEW WORLD BACKGROUND OR TO RAPIDLY
;MOVE TO A NEW LOCATION IN AN EXISTING WORLD BACKGROUND.  IT FILLS THE ENTIRE
;SCREEN BUFFER IN 1 PASS AND THUS PRODUCES A QUICK FLICKER ON THE SCREEN.
;TYPICALLY IT IS ONLY USED TO BOOT A SCREEN AND NOT TO SCROLL IT.

;A WORLD CONSISTS OF A LIST OF BACKGROUNDS TERMINATED WITH 0.  THE 
;NAME OF THE BACKGROUND THAT IS DESIRED TO BE PLACED AT A HORIZONTAL
;POSITION IN THE WORLD IS PLACED IN THE LIST AND THE SCROLLING ROUTINES
;WILL AUTOMATICALLY FETCH DATA FROM THERE AT LAUNCH TIME.  SEE KUNGTAB.ASM 
;FOR MORE INFO.

;TO USE THIS ROUTINE, SET XBACK (WORD) TO THE DESIRED X PIXEL LOCATION
;IN THE BACKGROUND.  SET YBACK (WORD) TO THE DESIRED Y PIXEL LOCATION.
;POINT Y:X (Y HIGH BYTE, X LOW BYTE) TO THE BACKGROUND TO BE USED.

;OUT OF RANGE X AND Y LOCATIONS WILL BE CORRECTED AND THIS FACT CAN
;BE USED TO MOVE TO THE BOTTOM OR END OF A SCREEN.

;ON RETURN:	SEE SIZE_LIST.  
;		SEE POINTBACK
;		SEE MAKECOL

INITBACK:
	JSR	ALLOW_WRITES

	STX	WORLDPTR
	STY	WORLDPTR+1
	JSR	SIZE_LIST	;MAKE THE PARAMETERS ABOUT THIS BACKGROUND.
	LDA	#-1
	STA	BACKVALID	;ENABLE BACKGROUND SCROLL CREATION

	JSR	WRITE_SCNBUF	;CLEAR THE BUFFER WE NEED
	JSR	FIXSCROLL	;FIX THE USER'S WINDOW VALUES
	JSR	MAKECOL		;MAKE THE ROW AND COLUMN OF UPPER LEFT SCREEN		

;BUILD THE COLUMNS NEEDED TO FILL THE SCREEN.  COLUMNS ARE USED INSTEAD
;OF ROWS BECAUSE ALL COLUMNS ARE GUARANTEED TO BE CONTINUOUS FROM THE
;SAME BACKGROUND BUT ROWS MIGHT BRIDGE BACKGROUNDS.  WE USE THE SAME 
;ROUTINE USED TO SCROLL BUT CALL IT UNTIL DONE.

	LDX	#33		;GET LOOP COUNT
	LDA	WORLD_WIDTH+1	;SEE IF WORLD CAN TAKE IT
	BNE	IB50
	CPX	WORLD_WIDTH
	BCC	IB50
	LDX	WORLD_WIDTH	;IF WORLD SMALLER THAN 33, USE MAX

IB50: 	TXA
	PHA

	JSR	FINDCOL		;FIND OUT WHERE THE NEXT COLUMN IS STORED
	JSR	BUILD_COL	;GET DATA ROW INTO SCNBUF. 
	JSR	WRITE_SCNBUF

	LDA	FETCHCOL
	CLC
	ADC	#1
	STA	FETCHCOL
	BCC	IB66
	INC	FETCHCOL+1	;MOVE TO NEXT COLUMN

IB66: 	PLA
	TAX
	DEX
	BNE	IB50		;DO ALL 33 COLS

;MAKE THE SCROLL VALUE FROM THE CURRENT WINDOW LOCATIONS

	LDA	XBACK
	STA	CURX
	LDA	XBACK+1
	STA	CURX+1

	LDA	YBACK
	STA	CURY
	LDA	YBACK+1
	STA	CURY+1		;SET WINDOW AS CURRENT LOCATION

	JSR	MAKE_SCROLL	;CONVERT IT INTO SCROLL VALUES

;COPY THE SCAN VARIABLES INTO THE COPY USED BY NMI.

	LDA	WORLDSPOT
	STA	XWORLDSPOT

	LDA	WORLDSPOT+1
	STA	XWORLDSPOT+1

	LDA	SPOTCOL
	STA	XSPOTCOL

	LDA	SPOTCOL+1
	STA	XSPOTCOL+1

	LDA	BACKBASE
	STA	XBACKBASE

	LDA	BACKBASE+1
	STA	XBACKBASE+1

	LDA	BPBASE
	STA	XBPBASE

	LDA	BPBASE+1
	STA	XBPBASE+1

	LDA	BACKSIZE
	STA	XBACKSIZE

	LDA	BACKWIDE
	STA	XBACKWIDE

	LDA	BACKHIGH
	STA	XBACKHIGH

	LDA	BPWIDE
	STA	XBPWIDE

;THIS SUB CAN BE CALLED TO RE-ENABLE NMI.  IT DOES NOT RE-ENABLE VIDEO.
;THE NEXT NMI WILL DO THAT.

RESUME_NMI:			
	LDA	REG2000
	ORA	#$80
	STA	$2000		;REENABLE NMI AND LET IT REENABLE VIDEO
	RTS

;THIS SUB WILL DISABLE NMI, WAIT FOR VERTICAL RETRACE, AND THEN DISABLE
;VIDEO.  IT SHOULD BE USED IN PREP FOR A SCREEN WRITE.

ALLOW_WRITES:
	JSR	STOP_NMI	;DISABLE NMI
	JSR	VERT_WAIT	;WAIT TO PREVENT SCREEN FLASH
	LDA	#6
	STA	$2001		;ENABLE SCREEN WRITES, DISABLE VIDEO
	RTS

;THIS ROUTINE WILL TAKE XBACK AND YBACK AND MAKE FETCHCOL AND FETCHROW
;FOR USE WITH BUILD_COL AND BUILD_ROW.  IN OTHERWORDS, IT MAKES THE COLUMN
;(WORD) AND ROW (BYTE) OF THE UPPER LEFT CORNER OF THE VIEWABLE SCREEN.
;THE COLUMN IS THE COLUMN WITHIN THE CURRENT COMBINED BACKGROUND WORLD,
;NOT WITHIN THE LITTLE BACKGROUND AT THAT POINT.  FINDCOL IS HELPFUL
;FOR MAKING THAT CORRECTION.

MAKECOL:
	LDA	XBACK
	STA	FETCHCOL
	LDA	XBACK+1
	STA	FETCHCOL+1
	LSR	FETCHCOL+1
	ROR	FETCHCOL
	LSR	FETCHCOL+1
	ROR	FETCHCOL
	LSR	FETCHCOL+1
	ROR	FETCHCOL	;MAKE /8 COLUMN (WORD)
	
	LDA	YBACK
	STA	FETCHROW
	LDA	YBACK+1
	LSR	A
	ROR	FETCHROW
	LSR	A
	ROR	FETCHROW
	LSR	A
	ROR	FETCHROW	;MAKE /8 ROW (BYTE)
	RTS

;THIS ROUTINE WILL SCAN A BACKGROUND LIST THAT COMPRISES A WORLD AND
;WILL RETURN INFORMATION NEEDED TO CONTROL THAT BACKGROUND
;(WORLDPTR) SHOULD POINT TO THE LIST ON ENTRY.  THE RESULTS ARE
;DIFFERENT FOR BLOCK MODE OR STRIP MODE.  ON RETURN:

;STRIP MODE RESULTS:
;WORLD_WIDTH = THE WIDTH OF THE WORLD IN COLUMNS (1 WORD).
;WORLD_HEIGHT = HEIGHT OF WORLD IN ROWS (1 BYTE)
;END_COL = THE LAST LEFTMOST COLUMN FOR THE BACKGROUND.
;RIGHTLIMIT = THE RIGHTMOST POSSIBLE PIXEL LOCATION FOR XBACK
;BOTLIMIT = THE BOTTOMMOST PIXEL LOCATION FOR YBACK (BLOCK MODE ONLY)
;(WORLDSPOT) = (WORLDPTR) 
;SPOTCOL=0
;POINTBACK HAS BEEN CALLED FOR CURRENT WORLDSPOT

;BLOCK MODE RESULTS
;WORLD_WIDTH = THE WIDTH OF THE WORLD IN COLUMNS (1 WORD).
;WORLD_HEIGHT = HEIGHT OF WORLD IN ROWS (1 BYTE)
;END_COL = THE LAST LEFTMOST COLUMN FOR THE BACKGROUND.
;RIGHTLIMIT = THE RIGHTMOST POSSIBLE PIXEL LOCATION FOR XBACK
;END_ROW = THE BOTTOMMOST ROW FOR THE BACKGROUND (BLOCK MODE ONLY)
;BOTLIMIT = BOTTOMMOST PIXEL ROW FOR THE BACKGROUND
;BLOCK_WIDTH = THE WIDTH IN BLOCKS OF THE BACKGROUND
;(WORLDPTR) = DIRECT POINTER TO THE START OF THE ACTUAL BLOCK NAMES
;(WORLDSPOT) = AVAILABLE TO USE TO POINT TO A GIVEN BACKGROUND

SIZE_LIST:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		
				;BLOCK MODE HAS A Y STARTING OFFSET

 	LDY	#0
	LDA	(WORLDPTR),Y	;GET WIDTH IN BLOCKS OF WORLD
	STA	BLOCK_WIDTH	;SAVE HERE
	TAY
	LDX	#8
	JSR	MUL
	STX	WORLD_WIDTH
	STY	WORLD_WIDTH+1	;SET RESULTING LENGTH

	TXA			;GET LOW BYTE OF RESULTING LENGTH
	SEC
	SBC	#32
	STA	END_COL
	STA	RIGHTLIMIT
	TYA
	SBC	#0
	STA	END_COL+1
	STA	RIGHTLIMIT+1
	ASL	RIGHTLIMIT
	ROL	RIGHTLIMIT+1
	ASL	RIGHTLIMIT
	ROL	RIGHTLIMIT+1
	ASL	RIGHTLIMIT
	ROL	RIGHTLIMIT+1	;MAKE END PIXEL VALUE

	LDY	#1
	LDA	(WORLDPTR),Y	;GET HEIGHT IN BLOCKS
	TAY
	LDX	#8
	JSR	MUL		;MAKE HEIGHT IN ROWS
	STX	WORLD_HEIGHT	;SAVE HEIGHT OF WORLD IN ROWS
	TXA			;WILL BE LESS THAN 256
	SEC
	SBC	#30		;MAKE LAST ROW FOR SCREEN.
	BCS	SLZ10
	LDA	#0		;IF ITS 0, SET AS SUCH
SLZ10:	STA	END_ROW
	STA	BOTLIMIT
	LDA	#0
	STA	BOTLIMIT+1
	ASL	BOTLIMIT
	ROL	BOTLIMIT+1
	ASL	BOTLIMIT
	ROL	BOTLIMIT+1
	ASL	BOTLIMIT
	ROL	BOTLIMIT+1	;MAKE END PIXEL VALUE

	LDA	WORLDPTR
	CLC
	ADC	#2		;POINT DIRECTLY TO THE FIRST ENTRY
	STA	WORLDPTR
	LDA	WORLDPTR+1
	ADC	#0
	STA	WORLDPTR+1
	RTS
.endif
	;', `
.ifndef BLOCKMODE
;NOT BLOCK MODE.  ADD UP THE LIST SIZE.

	LDA	WORLDPTR
	STA	WORLDSPOT
	LDA	WORLDPTR+1
	STA	WORLDSPOT+1	;SET UP A POINTER
	LDA	#0		;MAKE AN INDEX TO USE
	STA	WORLD_WIDTH
	STA	WORLD_WIDTH+1	;ZERO WIDTH IN COLUMNS
	
SLZ10: 	LDY	#1
	LDA	(WORLDSPOT),Y	;GET UPPER BYTE OF BACKGROUND NAME
	CMP	#-1
	BEQ	SLZ50
	JSR	POINTBACK	;GET BACKGROUND SIZE
	LDA	BACKWIDE
	CLC
	ADC	WORLD_WIDTH
	STA	WORLD_WIDTH
	BCC	SLZ30
	INC	WORLD_WIDTH+1

SLZ30:	JSR	NEXTSPOT	;MOVE TO NEXT ENTRY IN WORLD LIST
	JMP	SLZ10

;DONE.  SET POINTER AND VARIABLES.

SLZ50:	LDA	WORLDPTR
	STA	WORLDSPOT
	LDA	WORLDPTR+1
	STA	WORLDSPOT+1	;RETURN WORLDSPOT=WORLDPTR
	LDA	#0
	STA	SPOTCOL		;SET WHAT WORLDSPOT POINTS TO
	STA	SPOTCOL+1
	JSR	POINTBACK	;AND MAKE INFO VALID FOR THAT BACKGROUND

	LDA	WORLD_WIDTH	;GET FINAL WIDTH	
	SEC
	SBC	#32
	STA	END_COL
	LDA	WORLD_WIDTH+1
	SBC	#0
	STA	END_COL+1
	LDA	END_COL
	STA	RIGHTLIMIT
	LDA	END_COL+1
	STA	RIGHTLIMIT+1
	ASL	RIGHTLIMIT
	ROL	RIGHTLIMIT+1
	ASL	RIGHTLIMIT
	ROL	RIGHTLIMIT+1
	ASL	RIGHTLIMIT
	ROL	RIGHTLIMIT+1	;MAKE END PIXEL VALUE

	LDA	BACKHIGH	
	STA	WORLD_HEIGHT	;SET HEIGHT OF WORLD SAME AS FIRST STRIP

	RTS

	.endif ;' )

;THIS SUB ADDS 2 TO WORLDSPOT.

NEXTSPOT:
	LDA	WORLDSPOT
	CLC
	ADC	#2
	STA	WORLDSPOT
	BCC	NXP10
	INC	WORLDSPOT+1	;MOVE INDEX TO NEXT LIST ENTRY
NXP10:	RTS

;THIS SUB SUBTRACTS 2 FROM WORLDSPOT.

PREVSPOT:
	LDA	WORLDSPOT
	SEC
	SBC	#2
	STA	WORLDSPOT
	BCS	PVR10
	DEC	WORLDSPOT+1	;MOVE INDEX TO NEXT LIST ENTRY
PVR10:	RTS

;IF STRIP MODE, THIS SUB WILL TAKE A DESIRED WORLD COLUMN IN FETCHCOL AND 
;SETUP THE BACKGROUND PARAMETERS NEEDED FOR THAT COLUMN.   IT USES THE 
;CURRENT WORLDSPOT AND SPOTCOL TO FIND IT THE QUICKEST AND THESE MUST 
;BE VALID.  ALSO, POINTBACK MUST HAVE BEEN CALLED FOR THAT WORLDSPOT.
;ON RETURN:
;(WORLDSPOT) POINTS TO THAT BACKGROUND ENTRY IN THE WORLD LIST.
;SPOTCOL = WORLD COLUMN # THAT COLUMN 0 OF THAT BACKGROUND REPRESENTS
;POINTBACK HAS BEEN CALLED FOR THAT WORLDSPOT.
;SUBSVAR6 HAS THE COLUMN # WITHIN THE CURRENT BACKGROUND STRIP THAT THIS 
; COLUMN ACTUALLY REPRESENTS.  FETCHCOL IS UNCHANGED.

;IF ITS BLOCK MODE, THIS TAKES FETCHCOL AND FETCHROW AND USES SOME SUBSVARs 
;TO RETURN:
;(WORLDSPOT) POINTS TO THAT BACKGROUND ENTRY IN THE BLOCK MATRIX.
;POINTBACK HAS BEEN CALLED FOR THAT WORLDSPOT.
;SUBSVAR6 HAS THE COLUMN # WITHIN THAT BACKGROUND BLOCK THAT THIS COLUMN 
;ACTUALLY REPRESENTS.  FETCHCOL IS UNCHANGED.

FINDCOL:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `

	LDA	FETCHCOL
	STA	WORLDSPOT
	LDA	FETCHCOL+1
	LSR	A
	ROR	WORLDSPOT
	LSR	A
	ROR	WORLDSPOT
	LSR	A
	ROR	WORLDSPOT	;MAKE BLOCK NUMBER COLUMN ITS ON

	LDA	FETCHROW
	LSR	A
	LSR	A
	LSR	A		;MAKE BLOCK NUMBER ROW ITS IN BACKGRND MATRIX
	TAX
	LDY	BLOCK_WIDTH
	JSR	MUL		;MAKE BLOCK NUMBER OF START OF THIS ROW
	LDA	WORLDSPOT
	JSR	ADD_WORD
	STX	WORLDSPOT
	STY	WORLDSPOT+1	;SET INITIAL BLOCK NUMBER

;IFDEF( `INDIRECT', `
				;IF INDIRECT MODE, 1 BYTE PER BACKGROUND
.ifndef INDIRECT;	', `
	ASL	WORLDSPOT
	ROL	WORLDSPOT+1	;IF NOT INDIRECT MODE,DOUBLE EACH FOR WORD
	.endif ;' )

	LDA	WORLDSPOT
	CLC
	ADC	WORLDPTR	;ADD OFFSET OF ACTUAL MATRIX
	STA	WORLDSPOT
	LDA	WORLDPTR+1
	ADC	WORLDSPOT+1
	STA	WORLDSPOT+1	;MAKE DIRECT POINTER TO THE BLOCK WE MUST USE
	LDA	FETCHCOL
	AND	#7		;MAKE COLUMN WITHIN BACKGROUND
	STA	SUBSVAR6
	JSR	POINTBACK	;SET UP BACKBASE, ETC
	RTS
.endif
	;', `
.ifndef BLOCKMODE
	LDA	FETCHCOL
	SEC
	SBC	SPOTCOL
	STA	SUBSVAR6
	LDA	FETCHCOL+1
	SBC	SPOTCOL+1	;MAKE DISTANCE TO THIS COLUMN
	BCS	FC20

;WE NEED TO BACK UP THE CURRENT POINTER.

	JSR	PREVSPOT	;BACK UP THE POINTER
	JSR	POINTBACK	;SET UP FOR THIS ONE
	LDA	SPOTCOL
	SEC
	SBC	BACKWIDE	;CORRECT FOR WIDTH
	STA	SPOTCOL
	BCS	FC15
     	DEC	SPOTCOL+1
FC15:	JMP	FINDCOL		;AND TRY AGAIN.		

;WE DONT NEED TO BACK UP.  SEE IF THE CURRENT BACKGROUND HOLDS THIS ONE.
;SUBSVAR6 HAS THE LOW DISTANCE TO IT AND A THE HIGH.

FC20:	CMP	#0		;MAKE SURE NOT OUT OF RANGE
	BNE	FC40
	LDA	SUBSVAR6
	CMP	BACKWIDE	;IN RANGE?
	BCC	FC50

;WE NEED TO MOVE ON IN THE BACKGROUND LIST BECAUSE THIS BACKGROUND DOESNT
;HOLD THE ONE WE WANT.

FC40:	JSR	NEXTSPOT
	LDA	SPOTCOL
	CLC
	ADC	BACKWIDE	;CORRECT FOR WIDTH
	STA	SPOTCOL
	BCC	FC45
     	INC	SPOTCOL+1
FC45:	JSR	POINTBACK
	JMP	FINDCOL

FC50:	RTS
.endif ;' )

;THIS SUB WILL TAKE A POINTER IN (WORLDSPOT) AND USE IT TO SET UP
;BACKBASE, BACKSIZE, BACKWIDE, BACKHIGH, AND BPBASE.  WORLDSPOT SHOULD POINT
;TO AN ENTRY IN THE LIST OF BACKGROUNDS TO USE.

POINTBACK:
.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `

;BLOCK MODE LOGIC.

	LDY	#0

.ifdef INDIRECT;IFDEF( `INDIRECT', `
	LDA	(WORLDSPOT),Y	;ITS INDIRECT MODE.  THIS IS INDEX TO BACKGRND
	STA	BACKBASE
	STY	BACKBASE+1
	ASL	BACKBASE
	ROL	BACKBASE+1	;MAKE *2 POINTER FROM BLOCK NUMBER
	LDA	#BLOCKS & 255
	CLC
	ADC	BACKBASE
	STA	BACKBASE
	LDA	#BLOCKS >> 8
	ADC	BACKBASE+1
	STA	BACKBASE+1
	LDA	(BACKBASE),Y
	CLC
	ADC	#3		;POINT DIRECTLY TO BACKGROUND DATA
	PHA
	INY
	LDA	(BACKBASE),Y
	ADC	#0
	STA	BACKBASE+1
	PLA
	STA	BACKBASE
.endif;	', `
.ifndef INDIRECT
	LDA	(WORLDSPOT),Y	;IF DIRECT BLOCK MODE, (WORLDSPOT) HAS ADDRESS
	CLC
	ADC	#3		;POINT DIRECTLY TO DATA
	STA	BACKBASE
	INY
	LDA	(WORLDSPOT),Y
	ADC	#0
	STA	BACKBASE+1
.endif ;' )
	LDA	#8
	STA	BACKWIDE
	STA	BACKHIGH
	LDA	BACKBASE
	CLC
	ADC	#64		;SKIP TO PALETTE DATA
	STA	BPBASE
	LDA	BPBASE+1
	ADC	#0
	STA	BPBASE+1
	RTS
.endif
	;', `
.ifndef BLOCKMODE
;STRIP MODE LOGIC

	LDY	#0
	LDA	(WORLDSPOT),Y
	STA	BACKBASE
	STA	SUBSVAR1
	INY
	LDA	(WORLDSPOT),Y
	STA	BACKBASE+1	;GET NEXT BACKGROUND
	STA	SUBSVAR2

	TSX
	TXA
	SEC
	SBC	#4
	TAX
	TXS
	LDA	#3
	STA	SUBSVAR3
	JSR	FILLSTACK	;GET THE BACKGROUND HEADER
	TSX
	INX			;POINT TO THE DATA

	LDA	256,X
	STA	BACKSIZE
	LDA	257,X
	STA	BACKWIDE
	CLC
	ADC	#3		;ROUND WIDTH UP TO MAKE PALETTE WIDTH
	ROR	A
	LSR	A		;AND DIVIDE BY 4 TO GET PALETTE WIDTH
	STA	BPWIDE
	LDA	258,X
	STA	BACKHIGH	;GET THE 3 BACKGROUND PARAMETERS

	TXA
	CLC
	ADC	#3
	TAX
	TXS			;FIX THE STACK

	LDA	BACKBASE
	CLC
	ADC	#3
	STA	BACKBASE
	LDA	BACKBASE+1
	ADC	#0
	STA	BACKBASE+1	;MAKE POINTER POINT TO THE ACTUAL DATA ROWS

	LDX	BACKWIDE
	LDY	BACKHIGH
	JSR	MUL		;MAKE A POINTER TO THE PALETTE INFO
	CLC
	TXA
	ADC	BACKBASE
	STA	BPBASE
	TYA
	ADC	BACKBASE+1
	STA	BPBASE+1	;POINT DIRECTLY TO IT IN MEMORY
	RTS
 .endif ;' )
	
;THIS ROUTINE WILL SCROLL A BACKGROUND THAT HAS BEEN INITIALIZED WITH INITBACK.
;SET XBACK AND YBACK (BOTH WORDS) AND CALL THIS ROUTINE.  YOU MUST
;KEEP THESE VALUES IN RANGE AND VALID OR THE SPRITE SOLID CHECKING
;LOGIC MAY FAIL.  EVEN SO, THE VALUES
;YOU PUT IN XBACK AND YBACK WILL BE CORRECTED IF THEY ARE INVALID. DON'T
;TRY TO SCROLL MORE THAN 8 PIXELS PER NMI OR THE SCREEN MOVEMENT WILL NOT 
;BE ABLE TO KEEP UP WITH YOU.  IT WILL CORRECTLY SCROLL BUT ON RETURN
;YOUR XBACK VALUE MAY NOT BE EQUAL TO THE INTERNAL CURX WHICH IS THE
;ACTUAL SCREEN VIEWABLE POSITION.  

SCRLX:				;CALL HERE TO SCROLL X ONLY
	LDA	#1			
SCRL5:	LDX	BACKVALID
	BEQ	SCRL10
	ORA	MOVEBACK
	STA	MOVEBACK		;JUST SET A FLAG
SCRL10:	RTS

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET
SCRLY:				;CALL HERE TO SCROLL Y ONLY.
	LDA	#2		;SET Y SCROLL BIT
	JMP	SCRL5
.endif ;' )

;THIS ROUTINE WILL ACTIVATE A BACKGROUND PALETTE.  POINT Y TO THE
;HIGH OFFSET AND X TO THE LOW AND CALL.

;THIS ROUTINE SHOULD ONLY BE CALLED FROM AN NMI LEVEL OR FROM A MAIN
;LEVEL WHILE NMI IS DISABLED.  OTHERWISE THERE IS A SMALL CHANCE OF
;MESSING UP A SPRITE PALETTE.

BACKPAL:
	STX	BPAL_BASE
	STY	BPAL_BASE+1	;SET BASE OF PALETTE INFO
	LDA	#1
	ORA	NEW_PAL
	STA	NEW_PAL		;SET FLAG TO INIT PALETTE DURING NMI
	RTS

;THIS ROUTINE WILL ACTIVATE A SPRITE PALETTE.  POINT Y TO THE
;HIGH OFFSET AND X TO THE LOW AND CALL.

;THIS ROUTINE SHOULD ONLY BE CALLED FROM AN NMI LEVEL OR FROM A MAIN
;LEVEL WHILE NMI IS DISABLED.  OTHERWISE THERE IS A SMALL CHANCE OF
;MESSING UP A BACKGROUND PALETTE.

SPRITEPAL:
	STX	SPAL_BASE
	STY	SPAL_BASE+1	;SET BASE OF PALETTE INFO
	LDA	#2
	ORA	NEW_PAL
	STA	NEW_PAL		;SET FLAG TO INIT PALETTE DURING NMI
	RTS

;THIS ROUTINE IS USED TO CHANGE THE BASE SLOT OCCUPIED BY THE SPRITES.
;IT SETS THE VARIABLE "BASESPRITE" USED BY THE INIT ROUTINE TO PUT
;THE SLOTS AT THE RECOMMENDED POSITION DESPITE ROTATION.  WHEN THERE
;ARE TOO MANY SPRITES ON THE LINE, MAKE A NEW ROTATION VALUE FROM 0-F0
;AND CALL HERE.  IT MOVES THE SLOTS AROUND, ADJUSTS THEIR BASE SPRITE
;VALUES, AND SETS BASESPRITE TO THE CURRENT VALUE. WHEN THERE ARE NOT
;TOO MANY THIS ROUTINE WILL RESTORE THE ORIGINAL PRIORITY AS 
;SET BY THE RECOMMENDED BASE SPRITE IN THE DRAWING PROGRAM.
;SUBSVAR1,2 AND 3 ARE USED BY THIS ROUTINE.

;IF THE FLAG ROTATEFLG IS NOT SET, THIS ROUTINE ALWAYS SETS BASESPRITE
;TO 0 AND DEROTATES THE SPRITES.

ROTATE:
	LDA	BASESPRITE	;ROTATION OFF IS IGNORED UNTIL BASE=0
	BNE	RTT0
	LDA	ROTATEFLG	;OFF?
	BEQ	RTT1
	LDA	TOOMANY		;SEE IF SUBS FOUND TOO MANY ON LINE
	BNE	RTT0
RTT1:	JMP	RTT100

;WE ARE GOING TO ROTATE THE SPRITES.  SAVE THE FIRST 32 BYTES ON 
;THE STACK SO WE CAN FORGET ABOUT OVERLAPPING MOVEMENT.

RTT0:  	LDA	#-1
	STA	ROTATING	;LOCK OUT ANY SPRITE DMA TRANSFERS
	TSX
	TXA
	SEC
	SBC	#$20		;MAKE ROOM TO SAVE 32 BYTES ON STACK
	TAX
	TXS
	INX			;POINT TO PLACE TO SAVE THEM
	STX	SUBSVAR2	;SAVE LOCATION IN STACK MEMORY
	LDA	BASESPRITE	;NOW MAKE THE COUNT TO ROTATE THEM BY
	BEQ	RTT4
	CMP	#$20
	BCC	RTT5		;WE ROTATE BY $20 TILL WE GET CLOSE TO 0.
RTT4:	LDA	#$20		;THEN WE ROTATE BY $1C TO RESTORE 0 BASE.
RTT5:	STA	SUBSVAR1	;MAKE COUNTER
	STA	SUBSVAR3	;AND SAVE THE ADJUSTMENT TO BASESPRITE

	LDY	#0
RTT10:	LDA	SPRAM,Y
	STA	$100,X
	INY
	INX
	DEC	SUBSVAR1
	BNE	RTT10		;SAVE THE FIRST 32 FOR OVERLAPPING MOVE

;NOW MOVE DOWN ALL BUT THE SAVED ONES.  Y IS ALREADY SET TO PLACE TO PUT THEM.

	LDX	#0
	LDA	#$FC
	SEC
	SBC	SUBSVAR3	;MAKE AMOUNT TO BE MOVED DOWN
	STA	SUBSVAR1	;WHICH DEPENDS ON WHAT OUR ADJUSTMENT WAS
RTT20:	LDA	SPRAM,Y
	STA	SPRAM,X
	INY
	INX
	DEC	SUBSVAR1
	BNE	RTT20

;MOVE THE ONES FROM THE STACK INTO THE TOP.  X HAS THE CORRECT LOCATION.

	LDA	SUBSVAR3	;GET COUNT WE PUT INTO THE STACK
	STA	SUBSVAR1
	LDY	SUBSVAR2

RTT30:	LDA	$100,Y
	STA	SPRAM,X
	INY
	INX
	DEC	SUBSVAR1
	BNE	RTT30
	
;DONE ROTATING.  CHANGE THE BASE SPRITE IN THE SLOTS.

	LDA	#SPSLOTS
	STA	SUBSVAR1	;SET COUNT OF SPRITE SLOTS TO CHANGE
	LDX	#0		;POINT TO FIRST
	
RTT40:	LDA	ANIM_RAM+BS,X	;GET BASE SPRITE
	SEC
	SBC	SUBSVAR3	;CORRECT IT
	BCS	RTT45
	SEC
	SBC	#4		;AND SKIP LAST SPRITE

RTT45:	STA	ANIM_RAM+BS,X
	TXA
	CLC
	ADC	#ANIM_WIDE	;MOVE TO NEXT SLOT
	TAX
	DEC	SUBSVAR1
	BNE	RTT40	

	LDA	BASESPRITE
	SEC
	SBC	SUBSVAR3
	BCS	RTT50
	SEC
	SBC	#4
RTT50:	STA	BASESPRITE	;SET NEW BASE SPRITE
	TSX
	TXA
	CLC
	ADC	#$20		;FIX THE STACK
	TAX
	TXS
RTT100:	LDA	#0
	STA	ROTATING	;ALLOW SPRITE DMA TRANSFERS
	RTS
	
;THIS ROUTINE WILL INITIALIZE A BLOCK OF SPRITES OR AN ANIMATION.
;POINT Y:X TO THE STRUCTURE, SET A TO THE DESIRED SLOT IN THE
;SPRITE/ANIMATION RAM AND CALL.  THE STRUCTURE SHOULD BE ONE 
;CREATED WITH THE COLOR DREAMS DRAWING PROGRAM.  BACKGROUND 
;ANIMATION IS ALSO ALLOWED.  THIS CALL DOES NOT POSITION THE SPRITE
;BLOCK OR OBJECT ANIMATION, CALL PUTSPRT TO DO THAT.

;SPRITE STRUCTURES HAVE A BUILT IN BASE SPRITE NUMBER AS WELL AS
;A 1 BY 2 MODE FLAG.  THE 1 BY 2 MODE FLAG IS HONORED IMMEDIATLY ON
;MAKING THIS CALL.  THE APPROPRIATE REGISTER WILL BE SET INTO 1 BY 2
;MODE.  THE BASE SPRITE NUMBER IS USED AS A REQUEST ONLY.  IF THE REQUESTED
;SPRITES ARE OCCUPIED THEN THE NEXT HIGHER SPRITES WILL BE CHECKED UNTIL
;AN UNUSED BLOCK OF THE NECESSARY SIZE IS FOUND (THE SEARCH WILL WRAP AROUND
;IF NECESSARY).

;SINCE THE 1 BY 2 MODE FLAG IS HONORED IMMEDIATLY, DON'T CALL TO INIT
;SPRITES OF DIFFERENT HEIGHTS OR THE LAST INITIALIZED WILL BE THE ONE
;HONORED.

;ALL FRAMES IN THE ANIMATION MUST BE THE SAME WIDTH AND HEIGHT OR
;THIS ROUTINE WILL FAIL.   ALSO, THE DRAWING PROGRAM ALLOWS ANIMATION
;FRAMES TO NOT EXIST.  THIS ROUTINE CANNOT SUPPORT THAT CAPABILITY IN
;THE SAME MANNER SINCE THE ASSEMBLER TAKES THE ANIMATION NAME AND ATTEMPTS
;TO USE IT AS A LABEL DURING ASSEMBLY.  IF YOU WANT TO USE AN ANIMATION
;BEFORE ALL FRAMES EXIST, USE A TEXT EDITOR TO DUPLICATE THE NAMES OF
;OTHER FRAMES AND PUT THEM WHERE THE NON-EXISTING FRAMES APPEAR IN
;THE DRAW2ASM OUTPUT.

;ON RETURN FROM THIS CALL, IF THE SLOT WAS SUCCESSFULLY INITIALIZED THEN A=0 
;AND Z.  IF NZ THEN THE CALL WAS NOT SUCCESSFUL AND A HAS AN ERROR CODE:
;-1 IF THE ANIMATION SLOT # WAS INVALID (OVER RANGE).
;1 IF THE SLOT WAS ALREADY IN USE.
;2 IF NO CONTIGUOUS SPRITES WERE AVAILABLE TO BUILD THIS SPRITE BLOCK
;3 IF OBJECT ANIMATION, ITS NOT SUPPORTED.

;THIS ROUTINE MUST BE CALLED FROM 1 LEVEL ONLY.  CALL EITHER FROM NMI
;LEVEL OR FROM NON-NMI LEVEL BUT DON'T MIX IN THE SAME GAME OR ELSE
;YOU MIGHT MISALLOCATE DUE TO INTERRUPT DURING ALLOCATION.

INITSPRT:
	
	STX	SUBSVAR1
	STY	SUBSVAR2

	JSR	ANIMINDX
	BEQ	II20
	RTS			;IF BAD INDEX, RETURN TO CALLER.

II20:
	LDA	ANIM_RAM+FB,X	;GET THE ANIMATION FLAG
	BEQ	II30		;IF FREE, OK TO CONTINUE
	LDA	#1		;IF NOT FREE, RETURN 1.
	RTS

II30:  	LDA	SUBSVAR1
	STA	ANIM_RAM+PTRL,X
	LDA	SUBSVAR2       	;GET BACK INDEXES
	STA	ANIM_RAM+PTRH,X	;PUT MEMORY LOCATION INTO STRUCTURE

	LDA	ANIM_RAM+AF,X	;GET CURRENT AUX FLAGS
	AND	#$C0		;KEEP OLD DIRECTION BITS
	STA	ANIM_RAM+AF,X	;ZERO OTHER BITS IN THE AUX FLAGS
	
;GET THE PARTICULARS ABOUT THE SPRITE OR OBJECT STRUCTURE.  IF THE THING
;IS A SIMPLE SPRITE BLOCK THAN THE FIRST BYTE (FLAG BYTE) BIT 40H WILL
;BE OFF.  IF IT'S AN ANIMATION, BIT 40H WILL BE SET AND THE FLAG VALUE
;WILL BE "S" FOR A SPRITE ANIMATION AND "O" FOR AN OBJECT ANIMATION.

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET THE FLAG BYTE
	CMP	#79		;ASCII "O"?
	BNE	II90
	LDA	#0		;NOT SUPPORTED
	RTS

II90:	CMP	#83		;ASCII "S"
	BEQ	II100		;IF IT IS, GO TO INIT THAT

;ITS JUST A SPRITE BLOCK.  WE MUST SET THE FLAG FOR TYPE TO 1 AND LEAVE
;THE OTHER VARIABLES ALONE.  WE PUT THE TYPE FLAG INTO THE BASE SPRITE FOR
;NOW BECAUSE WE DON'T WANT THE NMI LEVEL TO FIND THIS STRUCTURE VALID UNTIL
;IT IS FULLY INITIALIZED.

	LDA	#$C1
	STA	ANIM_RAM+BS,X	;SET AS SIMPLE SPRITE BLOCK, BUT FROZEN
	JMP	II120		;GO SHARE ENDING CODE WITH ANIMATION SETUP.
	
;ITS A SPRITE ANIMATION.

II100:	LDA	#$82
	STA	ANIM_RAM+BS,X	;SET AS SPRITE ANIMATION
	LDA	#0
	STA	ANIM_RAM+FR,X	;ZERO THE FRAME WE ARE CURRENTLY DISPLAYING
	LDY	#2
	LDA	(SUBSVAR1),Y	;GET THE FREQUENCY
	STA	ANIM_RAM+CN,X	;SET INITIAL FREQUENCY
	STA	ANIM_RAM+RL,X	;AND SET RELOAD VALUE
	INY
	LDA	(SUBSVAR1),Y
	INY
	PHA
	LDA	(SUBSVAR1),Y	;GET FIRST ENTRY'S POINTER
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;SET OFFSET FOR SHARED INIT OF FIRST FRAME

;SEE IF WE CAN FIND A SPRITE BLOCK TO USE IT.  (SUBSVAR1) POINTS TO THE
;FIRST FRAME OR TO THE ONLY FRAME IF SPRITE BLOCK.

II120: 	TXA

	PHA			;SAVE THE SLOT INDEX
	LDY	#1
	LDA	(SUBSVAR1),Y	;GET WIDTH
	TAX
	INY
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	TAY
	JSR	MUL		;MAKE NUMBER OF SPRITES USED
	STX	MATH2		;SAVE HERE

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET RECOMMENDED BASE SPRITE
	AND	#$7F
	ASL	A
	ASL	A		;MAKE #4 POINTER TO THE BLOCK
	CLC
	ADC	BASESPRITE	;ADJUST FOR CURRENT BASE SPRITE
	BCS	II122
	CMP	#252
	BNE	II121

II122:	CLC
	ADC	#4		;IF WE WRAP, SKIP LAST SPRITE

II121:	STA	MATH1
	TAY

;MATH2 HAS COUNT OF SPRITES NEEDED, Y AND MATH1 HAVE BASE SPRITE TO START FROM.
;BIT 08 IS SET IN SPRITES IN USE, RESET IF AVAILABLE.  WE STILL HAVE THE
;INDEX TO THE SLOT ON THE STACK!


II130:	LDX	MATH2		;GET COUNT TO BE FOUND
	STY	SUBSVAR3	;SAVE INDEX WE WERE CHECKING.

II140:	LDA	SPRAM+2,Y	;GET IN USE FLAG
	STA	SUBSVAR4	;SAVE IN USE FLAG
II141:	INY
	INY
	INY	
	INY			;SKIP THIS SPRITE
	CPY	#252		;WRAP INDEX AT LAST SPRITE
	BEQ	II141		;BUT SPRITE #0 IS DEDICATED TO TOP STAT BAR
	TYA
	EOR	MATH1		;REACHED LIST END?
	BEQ	II145		;IF SO, DIDN'T FIND THE COUNT WE NEEDED.
	LDA	SUBSVAR4	;GET BACK THE IN USE FLAG
	AND	#8		;IN USE?
	BNE	II130		;IF IN USE, MUST SKIP THIS ONE
	DEX
	BNE	II140	
	JMP	II160

II145:	PLA			;DISCARD SLOT #
	LDA	#2		;IF END OF SPRITES AND NOT ENOUGH, RETURN ERR
	RTS

II160:	LDY	SUBSVAR3	;GET BACK BASE SPRITE WE CAN USE
	PLA
	TAX			;GET BACK SLOT INDEX
	LDA	MATH2		;GET BACK NUMBER OF SPRITES USED
	STA	ANIM_RAM+NS,X	;SET INTO STRUCTURE

	LDA	ANIM_RAM+BS,X	;GET FLAG TYPE WE PUT HERE FOR TEMP USAGE
	STA	SUBSVAR3	;SAVE IT
	TYA
	STA	ANIM_RAM+BS,X	;SAVE SPRITE BASE INDEX IN STRUCTURE

;WE HAVE A BASE THAT IS OK.  SET THE SPRITE DOUBLE OR NOT FLAG IN REG2000.

	LDA	REG2000	
	AND	#$DF		;ASSUME NOT DOUBLING SPRITE
	LDY	#0		
	PHA
	LDA	(SUBSVAR1),Y	;GET FLAG FROM THE SPRITE STRUCTURE
	ASL	A
	PLA
	BCC	II180
	ORA	#$20
II180:	STA	REG2000		;SET CONDITION OF SPRITE DOUBLE
	AND	#$20
	STA	DOUBLE_BIT	;AND KEEP A COPY OF IT.

;OK TO MOVE THE TYPE FLAG INTO THE SLOT AND MARK IT IN USE.

	LDA	SUBSVAR3
	STA	ANIM_RAM+FB,X

;GET THE FIRST FRAME AND INITIALIZE THIS SPRITE BLOCK.

	JSR	SPFRAME		

	LDA	#0
	RTS

;THIS ROUTINE WILL POSITION A BLOCK OF SPRITES OR AN OBJECT ANIMATION
;THAT WAS PREVIOUSLY INITIALIZED WITH A CALL TO INITSPRT.  WHEN INITSPRT
;IS CALLED, NO POSITIONING TAKES PLACE.  IF THE STRUCTURE IS AN ANIMATION,
;THE FRAME COUNTING WILL BE ACTIVATED AND CONTINUE EVEN THOUGH THE
;STRUCTURE IS "OFF SCREEN".  YOU MAY CALL HERE TO POSITION OR REPOSITION
;AS OFTEN AS DESIRED WITHOUT UPSETTING THE CURRENT ANIMATION FRAME.

;THE ALIGNMENT ANIMATION FEATURE IS SUPPORTED BY THIS CALL. IN THIS MODE
;(ACTIVATED BY CALLING ALIGNANIM) THE CURRENT ANIMATION FRAME WILL BE
;SELECTED BASED ON THE SCREEN AND BACKGROUND SCROLL POSITIONS.

;LOAD A WITH THE ANIMATION SLOT TO AFFECT, X WITH THE DESIRED COLUMN
;(PIXEL IF SPRITE, TEXT COLUMN IF OBJECT) AND LOAD Y WITH THE DESIRED ROW.

;ON RETURN, IF A=0 AND Z THEN SUCCESS.  IF NZ THEN A=-1 IF INVALID SLOT
;AND A=1 IF UNUSED SLOT.  

PUTSPRT:
	STX	SUBSVAR3
	STY	SUBSVAR4	;SAVE DESIRED X AND Y LOCATION
	JSR	ANIMINDX	;SEE IF VALID SLOT NUMBER
	BEQ	PU20
	RTS

PU20:  	LDA	ANIM_RAM+PTRL,X	
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2	;ASSUME DIRECT POINTER STORED IN SPRITE SLOT
	LDA	ANIM_RAM+FB,X	;GET TYPE OF STRUCTURE
	AND	#$7F		;REMOVE NOT POSITIONED BIT
	STA	ANIM_RAM+FB,X	;PUT BACK
	AND	#3
	BEQ	PU25		;IF NOT IN USE, BAD TYPE
	CMP	#3		;SEE IF OBJECT OR SPRITE
	BNE	PU21
	LDA	#0		;NOT SUPPORTED
	RTS		

PU21:	CMP	#1
	BEQ	PU30		;IF JUST SPRITE, OUR PTR IS GOOD
	LDY	#1
	LDA	(SUBSVAR1),Y	;ASSUME SPRITE ANIMATION, GET FRAMES IN CASE
	STA	SUBSVAR5	;OF UPDATE BY SCREEN ALIGNMENT
	LDY	#3		;OTHERWISE WE NEED TO GET A NEW PTR
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;USE FIRST FRAME OF ANIMATION AS INFO PTR
	JMP	PU30

PU25:	LDA	#1		;NOT IN USE OR UNKNOWN TYPE.
	RTS

;WE ARE DOING A SPRITE BLOCK THAT NEEDS TO BE MOVED. SUBSVAR3 AND 4 HAVE
;THE X AND Y LOCATIONS.  GET WIDTH AND HEIGHT OF THIS BLOCK.

PU30: 	LDA	SUBSVAR4	;GET SPRITE LOCATION
	CLC
	ADC	SPYADJ		;ADJUST Y ACCORDING TO USER REQUEST
	STA	SUBSVAR4	;AND PUT BACK FOR OUR USE

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET FLAG OF 1 OR 2 HIGH SPRITES
	PHA			;SAVE IT
	INY
	LDA	(SUBSVAR1),Y	;GET WIDTH
	PHA
	INY
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;SAVE BOTH

 	LDY	ANIM_RAM+BS,X	;GET BASE SPRITE INDEX
	LDA	#8		;ASSUME 1 HIGH
	STA	MATH1
	PLA			;GET FLAG OF 1 OR 2 HIGH
	BPL	PU50
	LDA	#16
	STA	MATH1		;IF 2 HIGH, USE 16 AS CORRECTION.	

;MOVE EACH SPRITE IN RELATIONSHIP TO THE REQUESTED LOCATIONS WITHOUT
;ALLOWING OVERFLOW PAST PAGE END.  

PU50: 	LDA	SUBSVAR1	;GET WIDTH
	STA	MATH2		;SAVE HERE FOR LOOP COUNT
	LDA	SUBSVAR3
	PHA			;SAVE STARTING X LOCATION FOR LOOP
	
PU55: 	LDA	SUBSVAR4	;GET Y LOCATION
	STA	SPRAM,Y		;SET CURRENT Y LOC
	LDA	SUBSVAR3
	STA	SPRAM+3,Y	;AND SET X TOO

	CLC
	ADC	#8		;MOVE RIGHT 8
	BCC	PU60
	LDA	#$FF		;WENT PAST END, FIX IT.
PU60:	STA	SUBSVAR3  	;PUT BACK CORRECTED X
PU61:	INY
	INY	
	INY
	INY
	CPY	#252		;WRAP INDEX AT LAST SPRITE
	BEQ	PU61
	DEC	MATH2		;COUNT 1 LESS ON THIS ROW
	BNE	PU55		;DO ALL OF THEM
	PLA
	STA	SUBSVAR3	;RESTORE START OF ROW X
	LDA	SUBSVAR4	;GET Y LOCATION
	CLC
	ADC	MATH1		;CORRECT Y FOR NEXT ROW ACCORDING TO HEIGHT
	BCS	PU70
	CMP	#$F9
	BCC	PU75
PU70:	LDA	#$F8		;BOTTOM IS F8
PU75:	STA	SUBSVAR4
	DEC	SUBSVAR2	;COUNT 1 LESS ROW
	BNE	PU50

;NOW SEE IF A SPRITE ANIMATION IS SELECTING FRAME BY POSITION.

PU77:	LDA	ANIM_RAM+FB,X	;GET BACK THE FLAG
	AND	#$70		;KEEP FROZEN AND ALIGNMENT BITS
	BEQ	PU90 		;IF NONE, NO NEED TO WORRY
	CMP	#$40		;BUT FROZEN?
	BCS	PU90		;IF SO, DONT UPDATE BY ANY METHOD BUT SELFRAME

;WE ARE UPDATING BY POSITION.  GET THE POSITION WE ARE USING.

	LDA	ANIM_RAM+FB,X
	AND	#3
	CMP	#1		;MAKE SURE NO ERROR (SPRITE BLOCK DOESN'T MOVE)
	BEQ	PU90
		
	LDA	ANIM_RAM+FB,X	;GET BACK X ALIGN BIT (20H)
	ROL	A
	ROL	A
	ROL	A		;GET X BIT INTO CY

	LDY	ANIM_RAM+BS,X
	LDA	YBACK		;CURY
	STA	SUBSVAR3

PU78:	LDA	SPRAM,Y		;ASSUME UPDATE BY Y
	BCC	PU80
PU79:	LDA	XBACK		;CURX
	STA	SUBSVAR3
	LDA	SPRAM+3,Y	;IF BY X, GET X

PU80: 	CLC
	ADC	SUBSVAR3
	STA	SUBSVAR3	;SAVE THE LOCATION TO USE
	LDA	ANIM_RAM+AF,X	;GET SHIFT COUNT
	AND	#$07
	TAY
	INY
PU82:	DEY
	BEQ	PU83
	LSR	SUBSVAR3	;SHIFT LOCATION DOWN BY REQUESTED AMOUNT
	JMP	PU82

PU83:  	STX	SUBSVAR4	;SAVE INDEX
	LDX	SUBSVAR3	;GET FRAME TO USE
	LDY	#0
	LDA	SUBSVAR5	;GET NUMBER OF FRAMES
	JSR	DIVIDE		;QUICKER TO DIVIDE THAN SUBTRACT ON AVERAGE

;Y NOW HAS FRAME TO USE.  BUT IF THE SPRITE HAS BEEN MIRRORED WE NEED
;TO SELECT BACKWARDS OR ELSE SOMEONE'S IMAGE WILL WALK BACKWARDS!

  	LDX	SUBSVAR4	;GET BACK INDEX
	LDA	ANIM_RAM+FB,X	;GET BACK X ALIGN BIT (20H)
	AND	#$20
	BEQ	PU85		;IF BY Y, MIRROR DOESN'T MATTER.

	LDA	ANIM_RAM+AF,X	;SEE IF MIRRORED SPRITE
	AND	#$40
	BEQ	PU85
	LDA	SUBSVAR5	;GET BACK NUMBER OF FRAMES IF SO
	STY	SUBSVAR5
	CLC
	SBC	SUBSVAR5	;MAKE BACKWARDS SELECTION IF MIRRORED
	TAY		

PU85:  	TYA			;GET REMAINDER AS FRAME TO USE
	LDY	ANIM_RAM+FR,X	;GET CURRENT FRAME
	STA	ANIM_RAM+FR,X	;SET CURRENT FRAME
	TYA
	EOR	ANIM_RAM+FR,X	;SEE IF FRAME HAS CHANGED
	BEQ	PU90		;IF NO CHANGE, DON'T WASTE TIME UPDATING.
	JSR	SPFRAME

PU90:	LDA	#0		;SIGNAL SUCCESS
	RTS			

;THIS ROUTINE WILL RETURN THE COORDINATES OF THE ANIMATION SLOT SPECIFIED
;IN A.  THEY ARE RETURNED IN X AND Y AND REPRESENT THE SAME VALUES USED
;WITH THE PUTSPRT CALL.  ON RETURN, IF A=0 AND Z THEN X AND Y ARE VALID,
;OTHERWISE A WAS INVALID ON ENTRY.

;JUST TO BE NICE, THIS ROUTINE SAVES THE CORRECTED INDEX INTO SUBSVAR5.
;IT DOES NOT CHANGE ANY OTHER SUBSVARS

;GETSPRT:
;	JSR	ANIMINDX
;	STX	SUBSVAR5
;	BEQ	GS40
;	RTS
;
;GS40:	LDY	ANIM_RAM+BS,X	;GET INDEX TO SPRITE
;	LDX	SPRAM+3,Y  	;GET THE COL ITS ON
;	LDA	SPRAM,Y		;GET THE ROW
; 	SEC
;	SBC	SPYADJ		;ADJUST Y ACCORDING TO USER REQUEST
;	TAY
;	LDA	#0
;	RTS

;THIS ROUTINE WILL TEST IF YOU CAN MOVE A SPRITE BLOCK 
;TO LOCATION IN REGISTER X AND Y WITHOUT HITTING SOLIDS.  THE
;MOVE IS TESTED FOR SLOT IN REGISTER A.   IT TAKES INTO COUNT WHETHER
;SOLID CHECKING IS ON AND IF NOT IT RETURNS QUICKLY WITHOUT WASTING
;TIME (IT RETURNS OK IN THIS CASE).  THE X AND Y YOU PASS ARE RETURNED
;IN TESTX AND TESTY BECAUSE IT WAS COMMON IN KUNGFU.ASM TO NEED THIS.

;ON RETURN, A HAS A FLAG
;0=SUCCESS.  
;1=UNUSED SLOT
;-1=BAD SLOT #
;4=MOVE REJECTED, OVER SOLID BACKGROUND.  SOLIDCHAR RETURNS FIRST SOLID HIT.

;THIS ROUTINE MUST BE CALLED SINGLE THREADED ONLY (FROM 1 LEVEL ONLY).
;DON'T CALL FROM BOTH NMI AND OUTSIDE NMI.  CURRENTLY ITS ONLY TESTED
;FOR OUTSIDE NMI.  ITS SINGLE THREADED PARTLY BECAUSE OF TESTX AND TESTY.

TESTPUT:
	STX	TESTX
	STY	TESTY		;SAVE THE LOCATION

	JSR	USEDINDX	;CHECK OUT THE SLOT, RETURN FROM THERE IF BAD
	STX	SUBSVAR5	;SET SLOT
	AND	#8		;SOLID DEFINED?		
	BNE	CS04
	LDA	#0		;RETURN OK FLAG
	RTS

CS04: 	LDA	TESTX		;GET X LOCATION
	STA	MATH1		;SAVE DESIRED NEW X LOCATION
	LDA	TESTY		;GET DESIRED Y CORRECTION
	STA	MATH4		;SAVE DESIRED NEW Y LOCATION.

;MATH1 AND MATH4 HAVE THE NEW DESIRED X AND Y LOCATIONS, 
;SUBSVAR5 HAS THE SLOT INDEX.  FIRST MAKE THE OFFSETS IN THE 
;BACKGROUND.  

	LDA	MATH1		;GET DESIRED X LOCATION
	CLC
	ADC	XBACK		;MAKE OFFSET IN BACKGROUND
	STA	FETCHCOL
	LDA	XBACK+1		
	ADC	#0
	STA	FETCHCOL+1	;FETCHCOL HAS X PIXEL LOC IN BACKGROUND
	LDA	FETCHCOL
	CLC
	ADC	#4		;MOVE RIGHT TO IGNORE 4 ON LEFT 
	STA	FETCHCOL
	LDA	FETCHCOL+1
	ADC	#0
	STA	FETCHCOL+1	;AND COUNT 4 LESS PIXELS ON LEFT.

	LSR	FETCHCOL+1
	ROR	FETCHCOL
	ROR	SUBSVAR4
	LSR	FETCHCOL+1
	ROR	FETCHCOL
	ROR	SUBSVAR4
	LSR	FETCHCOL+1
	ROR	FETCHCOL	;MAKE FETCHCOL=TEXT COL,
	ROR	SUBSVAR4	;SUBSVAR4=ODD PIXELS

;NOW MAKE THE WIDTH AND HEIGHT TO CHECK IN THOSE BACKGROUNDS.

	LDA	ANIM_RAM+PTRL,X
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2	;MAKE (SUBSVAR1) POINT TO THE ANIMATION/SPRITE

	LDA	ANIM_RAM+FB,X
	AND	#3
	CMP	#1		;JUST A SPRITE?
	BEQ	CS30		;IF IT IS, PTR IS TO A BLOCK WITH WIDTH/HEIGHT
	LDY	#3
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;IF ANIMATION, NEED POINTER TO BLOCK

CS30:	LDY	#1
	LDA	(SUBSVAR1),Y	;GET WIDTH
	STA	MATH1		;SAVE HERE
	DEC	MATH1		;COUNT 1 LESS ON WIDTH (4 PIXELS OFF EACH SIDE)
	BNE	CS31
	INC	MATH1		;IF ONLY 1 WIDE, CAN'T DO IT
CS31:	INY
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	STA	MATH2		;SAVE HEIGHT
	LDY	#0
	LDA	(SUBSVAR1),Y	;SEE IF 2 HIGH SPRITE
	BPL	CS35
	ASL	MATH2		;IF 2 HIGH, DOUBLE HEIGHT

CS35:	LDA	MATH2		;GET BACK HEIGHT IN CHARACTERS
	JSR	TIMES8		;MULTIPLY BY 8
	DEC	MATH4		;NEED TO COME UP TO BOTTOM PIXEL OF FEET
	CLC
	ADC	MATH4
	CLC
	ADC	YBACK		;MAKE OFFSET IN BACKGROUND
	STA	MATH4
	LDA	#0
	ADC	YBACK+1


	LSR	A
	ROR	MATH4
	LSR	A
	ROR	MATH4
	LSR	A		;MAKE TEXT ROW OF BOTTOM SPRITE
	ROR	MATH4
	LDA	MATH4
	STA	FETCHROW	;SAVE FOR FINDCOL

	CMP	WORLD_HEIGHT	;MAKE SURE CHECK ROW IS IN RANGE
	BCC	CS37	

;THE FOLLOWING IFDEF IS CONTROLLED BY KUNGTAB.  THE USER CAN MAKE ILLEGAL
;ROWS BE INTERPRETED AS SOLID OR NOT SOLID.

.ifdef SOLFILL;IFDEF( `SOLFILL', `		
	LDA	#-1		;THIS MAKES DATA BELOW BACKGROUND BE SOLID
 	STA	SOLIDCHAR	
	LDA	#4
	RTS
.endif;	', `
.ifndef SOLFILL
	LDA	#0		;THIS MAKES DATA BELOW BACKGROUND BE EMPTY
	RTS
.endif;	')

PAST_RIGHT:
	LDA	WORLD_WIDTH
	SEC
	SBC	#1
	STA	FETCHCOL
	LDA	WORLD_WIDTH+1
	SBC	#0
	STA	FETCHCOL+1	;IF PAST RIGHT ON CHECK, CHECK LAST COL ONLY
	LDA	#1
	STA	SUBSVAR4
	JMP	CS50B

CS37:	LDA	SUBSVAR4	;GET ODD PIXELS ON COL
	AND	#%11100000
	BEQ	CS50
	INC	MATH1		;IF THERE ARE SOME, NEED EXTRA COL CHECK

CS50:	LDA	MATH1
	STA	SUBSVAR4	;PUT COLS TO CHECK HERE
	
	LDA	WORLD_WIDTH
	SEC
	SBC	FETCHCOL
	TAY
	LDA	WORLD_WIDTH+1
	SBC	FETCHCOL+1	;FIND OUT HOW MANY REMAIN IN THIS WORLD
	BCC	PAST_RIGHT
	BNE	CS50B		;IF >256 ITS OK
	CPY	SUBSVAR4	;SEE IF WE ARE CHECKING TOO MANY
	BEQ	CS50A
	BCS	CS50B
CS50A:	STY	SUBSVAR4	;IF SO, LOWER WIDTH OF CHECK
	CPY	#0
	BEQ	PAST_RIGHT

;WE ARE GOING TO MAKE THE CHECK.  ALLOCATE ROOM FOR 16 ON THE STACK SO
;WE CAN CHECK IN ANY ROM PAGE.

CS50B:	TSX
	TXA
	SEC
	SBC	#17		;FIX THE STACK
	TAX
	TXS

;NOW SUBSVAR4 = COLS TO CHECK, AND WE ARE CHECKING 1 ROW ONLY.
;FETCHROW = ROW OF BOTTOM SPRITE PIXEL.  FETCHCOL = COL WE ARE ON.

CS53:  	JSR	FINDCOL		;FIND THIS COLUMN WITHIN THE SOLID DATA

;NOW SUBSVAR6 HAS THE COLUMN TO CHECK IN THE CURRENTLY SELECTED BACKGROUND.
;IF THIS BACKGROUND IS TOO SHORT TO MAKE THE CHECK, PUT REMAINING COLUMNS
;TO CHECK INTO SUBSVAR4.  THEN SET SUBSVAR3 TO THE NUMBER TO CHECK RIGHT NOW

	LDA	BACKWIDE
	SEC
	SBC	SUBSVAR6	;MAKE COLUMNS LEFT TO END OF BACKGROUND
	STA	SUBSVAR3
	LDA	SUBSVAR4	;GET COLUMNS TO CHECK
	SEC
	SBC	SUBSVAR3	;MAKE AMOUNT TOO MANY
	BCS	CS51
	LDA	#0		;IF WE HAVE MORE THAN ENOUGH, SET TO 0
CS51:	STA	SUBSVAR3	;SAVE AMOUNT TOO MANY HERE
	TAX			;BUT ALSO NEED A COPY

	LDA	SUBSVAR4
	SEC
	SBC	SUBSVAR3	;MAKE AMOUNT WE CAN CHECK THIS PASS
	STA	SUBSVAR3	;SET AMOUNT TO CHECK THIS PASS
	STX	SUBSVAR4	;AND PUT NEXT PASSES' AMOUNT HERE.

	CLC
	ADC	FETCHCOL
	STA	FETCHCOL
	BCC	CS52
	INC	FETCHCOL+1	;MAKE POINT TO CHECK NEXT LOOP

;MAKE (SUBSVAR1) POINT TO THE DATA IN THE BACKGROUND.

CS52: 

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		
	LDA	FETCHROW
	AND	#7		;GET ROW WITHIN BACKGROUND
	ASL	A
	ASL	A
	ASL	A		;MAKE *8
	TAX
	LDY	#0		;MAKE Y:X = POINTER WITHIN BACKGROUND
.endif
	;', `
.ifndef BLOCKMODE
	LDX	FETCHROW
	LDY	BACKWIDE
	JSR	MUL		;MAKE Y:X = POINTER WITHIN BACKGROUND
.endif ;' )

	LDA	SUBSVAR6
	JSR	ADD_WORD		;MAKE POINTER TO DATA BLOCK
	TXA
	CLC
	ADC	BACKBASE
	STA	SUBSVAR1
	TYA
	ADC	BACKBASE+1
	STA	SUBSVAR2	;MAKE (SUBSVAR1) POINT TO DATA

;GET VALUE TO CHECK AGAINST

	LDA	SUBSVAR3		;GET COUNT WE ARE GOING TO FETCH
	STA	SUBSVAR6		;SAVE IT HERE CAUSE FILLSTACK ZEROS IT
	JSR	FILLSTACK		;GET THE DATA WE WANTED

	LDY	SUBSVAR6		;GET BACK THE COUNT WE LOADED
	LDX	SUBSVAR5		;NEED TO RESTORE SLOT INDEX
	LDA	ANIM_RAM+SL,X		;GET USER'S SOLID CHARACTER VALUE
	STA	SUBSVAR6		;SAVE IT HERE FOR COMPARE
	TSX
	INX			;POINT TO DATA WE GOT IN THE STACK AREA

CS110:	LDA	$100,X		;GET A CHAR
	INX
	CMP	SUBSVAR6		;SOLID?
	BCS	CS200			;SKIP IF SO.
	DEY
	BNE	CS110

;WE PASSED THE CHECK BUT SEE IF THIS BACKGROUND DIDN'T HAVE ENOUGH TO CHECK.

CS115:	LDA	SUBSVAR4	;GET AMOUNT LEFT TO CHECK
	BNE	CS53
	
;OK TO MAKE THE MOVE.  

MS40: 	LDA	#0		;RETURN OK FLAG
	JMP	CS210

;NOT OK TO MOVE, ITS SOLID.  A HAS THE CHAR VALUE

CS200: 	STA	SOLIDCHAR	;SAVE FOR CALLER
	LDA	#4
CS210:	STA	SUBSVAR3	;SAVE THE RETURN FLAG
	TSX
	TXA
	CLC
	ADC	#17		;FIX THE STACK
	TAX
	TXS
	LDA	SUBSVAR3
	RTS

;THIS SUB READS THE CHAR UNDER THE X AND Y POSITION ON VISUAL SCREEN.
;IT READS IT FROM THE VIRTUAL BACKGROUND.  PUT THE X IN TESTX AND
;THE Y IN TESTY.

GETCHAR:
	LDA	TESTX		;GET DESIRED X LOCATION
	CLC
	ADC	XBACK		;MAKE OFFSET IN BACKGROUND
	STA	FETCHCOL
	LDA	XBACK+1		
	ADC	#0
	LSR	A
	ROR	FETCHCOL
	LSR	A
	ROR	FETCHCOL
	LSR	A
	ROR	FETCHCOL	;MAKE FETCHCOL=TEXT COL,

	LDA	TESTY
	CLC
	ADC	YBACK		;MAKE OFFSET IN BACKGROUND
	STA	FETCHROW
	LDA	#0
	ADC	YBACK+1

	LSR	A
	ROR	FETCHROW
	LSR	A
	ROR	FETCHROW
	LSR	A	
	ROR	FETCHROW	;MAKE TEXT ROW OF BOTTOM SPRITE

  	JSR	FINDCOL		;FIND THIS COLUMN WITHIN THE SOLID DATA

;MAKE (SUBSVAR1) POINT TO THE DATA IN THE BACKGROUND.

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		
	LDA	FETCHROW
	AND	#7		;GET ROW WITHIN BACKGROUND
	ASL	A
	ASL	A
	ASL	A		;MAKE *8
	TAX
	LDY	#0		;MAKE Y:X = POINTER WITHIN BACKGROUND
.endif
	;', `
.ifndef BLOCKMODE
	LDX	FETCHROW
	LDY	BACKWIDE
	JSR	MUL		;MAKE Y:X = POINTER WITHIN BACKGROUND
.endif ;' )

	LDA	SUBSVAR6
	JSR	ADD_WORD		;MAKE POINTER TO DATA BLOCK
	TXA
	CLC
	ADC	BACKBASE
	STA	SUBSVAR1
	TYA
	ADC	BACKBASE+1
	STA	SUBSVAR2	;MAKE (SUBSVAR1) POINT TO DATA

	LDA	#1
	STA	SUBSVAR3	;SET COUNT WE ARE GOING TO FETCH
	PHA			;MAKE ROOM FOR 1 ON THE STACK
	JSR	FILLSTACK	;GET THE DATA WE WANTED
	PLA			;GET THE CHAR
	RTS


;THIS ROUTINE IS USED AT BOOT TO ZERO THE SPRITE CONTROL RAM.  KILLSPRT
;CANNOT BE USED BECAUSE THE DATA WILL BE INTERPRETED AND IT IS INVALID AT
;THAT TIME.

ZERO_ANIM:
 	LDA	#0
	TAX
ZA10:	STA	ANIM_RAM,X
	INX
	CPX	#SPMEM		;SEE IF DONE
	BNE	ZA10
	RTS

;THIS ROUTINE WILL KILL (FREE UP) THE ANIMATION SLOT SPECIFIED IN A.
;A VALUE OF -1 MAY BE USED TO FREE UP ALL SLOTS. IT IS OK TO FREE UP 
;A SLOT THAT IS ALREADY FREE.   THIS ROUTINE SETS THE SPRITE RAM FOR
;THE ENTRY (IF IT WAS A SPRITE) TO ALL OFF SCREEN VALUES SO THAT
;INITSPRT DOES NOT HAVE TO DO THAT.

;ON RETURN, IF Z OR A=0 THEN SUCCESS.  IF A=-1 OR NZ THEN  THE SLOT 
;NUMBER YOU PASSED WAS INVALID (TOO HIGH).

KILLSPRT:
	CMP	#-1		;FREE ALL?
	BNE	KS10

;NEED TO FREE THEM ALL.  CALL OURSELVES UNTIL INVALID INDEX RETURNED.

KILLALL:		;THIS IS AN ALLOWED USER ENTRY POINT.

	LDA	#0
KS5:	PHA
	JSR	KILLSPRT
	BNE	KS7
	PLA
	CLC
	ADC	#1		;JUST KEEP GOING USING THIS ROUTINE.
	JMP	KS5
KS7:	PLA
	LDA	#0
	RTS

;NOT KILL ALL.  CHECK THE INDEX.

KS10:	JSR	ANIMINDX
	BNE	KS50

;ITS A VALID SLOT.  IF SPRITE BLOCK WE MUST HIDE THE SPRITES TOO.
;ITS ALSO OK TO JUMP HERE WITH A VALID SLOT INDEX IN X IF YOU WANT TO 
;KILL WITHOUT THE CALL.  USED BY AUTOKILL FROM CHECK_ANIM.  X IS PRESERVED.

MANUAL_KILL:
	LDA	ANIM_RAM+FB,X	;GET FLAG BYTE
	PHA
	LDA	#0
	STA	ANIM_RAM+FB,X	;FREE IT UP BEFORE RESETING HIDE BIT SO NMI
	PLA			;WON'T DO A FRAME UPDATE AND SET BIT AGAIN
	AND	#$3
	BEQ	KS50		;IF DONE, END
	CMP	#3		;OBJECT?
	BEQ	KS50

;ITS A SPRITE BLOCK. WE MUST MOVE THEM OFF SCREEN.

	TXA
	PHA			;SAVE INDEX
	LDA	ANIM_RAM+BS,X	;GET BASE SPRITE INDEX
	TAY
	LDA	ANIM_RAM+NS,X	;GET NUMBER TO HIDE
	TAX
	JSR	HIDE2		;USE THIS ROUTINE TO DO IT.
	PLA
	TAX
	LDA	#0
;DONE.  

KS50: 	RTS

;THIS ROUTINE WILL MOVE A BLOCK OF SPRITES OR A SPRITE ANIMATION BEHIND
;OR IN FRONT OF THE BACKGROUND.  LOAD A WITH THE SLOT NUMBER AND
;X WITH 20H TO MOVE BEHIND AND 00 TO MOVE IN FRONT.  A RETURNS Z IF
;SUCCESS, OTHERWISE A=-1 AND INVALID SLOT NUMBER (Z FLAG SET ACCORDINGLY).

;THIS ROUTINE ACTUALLY RESETS BIT 20H IN THE SPRITE PALLETTE BYTE AND
;THEN XORS THE VALUE YOU PASS IN X TO THE SPRITE'S PALETTE INFO.  YOU
;CAN USE THIS FACT TO CHANGE PALETTES WITH A CALL IF YOU HAVE A SIMPLE
;SPRITE AND KNOW WHAT THE OLD VALUES WERE. FOR ANIMATIONS THIS WOULD
;NOT WORK SINCE THE PAL DATA IS RELOADED WITH EACH ANIMATION (BUT
;THE BACK/FRONT BIT IS PRESERVED).

;NZ AND A=1 IS RETURNED IF STRUCTURE IS NOT A SPRITE STRUCTURE
;OR IS NOT IN USE.  -1 MEANS INVALID SLOT #.

INFRONT:
	STX	SUBSVAR1	;SAVE DESIRED CONDITION
	JSR	ANIMINDX
	BNE	IF4		;END IF BAD SLOT #

	LDA	ANIM_RAM+FB,X	;GET TYPE OF STRUCTURE
	AND	#$3
	CMP	#1		;IF SIMPLE ANIMATION, WE ARE OK NOW
	BEQ	IF20
     	CMP	#2
	BEQ	IF20
	LDA	#1
IF4:	RTS


IF20:	LDY	ANIM_RAM+BS,X	;GET BASE SPRITE #
	LDA	ANIM_RAM+NS,X
	TAX			;AND COUNT

IF30:	LDA	SPRAM+2,Y	;GET THE BEHIND/IN USE BITS
	AND	#$DF		;REMOVE THE BEHIND BIT
	EOR	SUBSVAR1	;PUT BACK IN IF DESIRED BY USER
	STA	SPRAM+2,Y	;SAVE BACK OUT
IF31:	INY
	INY
	INY
	INY			;SKIP TO NEXT SPRITE
	CPY	#252		;WRAP INDEX AT LAST SPRITE
	BEQ	IF31
	DEX
	BNE	IF30
	LDA	#0		;SUCCESS
	RTS

;THIS CALL WILL ACTIVATE THE SCREEN ALIGNMENT CAPABILITY OF THE ANIMATION
;ROUTINES.  WHEN ACTIVE, THE ANIMATION FRAME IS SELECTED AS A RESULT
;OF SCREEN POSITION RATHER THAN TIME.  YOU SPECIFY X OR Y ALIGNMENT
;(WHICH AXIS IS TO BE USED FOR THE ALIGNMENT) AND THE AMOUNT TO SHIFT
;THE SCREEN POSITION RIGHT TO GET THE FRAME #.  RESULTING VALUES OVER
;THE NUMBER OF FRAMES WILL WRAP.

;TO USE, LOAD A WITH THE SLOT #, LOAD Y WITH THE SHIFT RIGHT COUNT (0-7)
;AND LOAD X WITH 20H FOR X ALIGNMENT AND 10H FOR Y ALIGNMENT.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

ALIGNANIM:
	STX	SUBSVAR3
	STY	SUBSVAR4	
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	AND	#$CF		;REMOVE ANY OLD ALIGNMENT BITS
	ORA	SUBSVAR3	;SET IN THE NEW ONES
	STA	ANIM_RAM+FB,X
	LDA	SUBSVAR4	;GET ALIGNMENT VALUE
	AND	#$7		;ONLY 3 BITS VALID
	STA	SUBSVAR4
	LDA	ANIM_RAM+AF,X	;GET THE AUXILIARY FLAGS
	AND	#$F8		;REMOVE OLD BITS FOR ALIGNMENT
	ORA	SUBSVAR4
	STA	ANIM_RAM+AF,X	;SET BACK WITH NEW VALUE
	LDA	#0
	RTS

;THIS CALL ACTIVATES THE SOLID BACKGROUND FUNCTION OF THE SPRITE MOVEMENT
;ROUTINE TESTPUT.  

;TO USE THIS CALL, LOAD A WITH THE SLOT # AND LOAD X WITH THE CHAR VALUE.
;ANY BACKGROUND CHAR EQUAL TO OR ABOVE THIS VALUE IS CONSIDERED SOLID.
;TO DEACTIVATE THIS FUNCTION USE A VALUE OF 0 AS THE SOLID.

;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

SOLID:
	STX	SUBSVAR3	;SAVE SOLID VALUE
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1.
	LDA	SUBSVAR3	;GET BACK SOLID VALUE
	STA	ANIM_RAM+SL,X	;SET NEW SOLID VALUE
	LDA	ANIM_RAM+FB,X
	ORA	#8
	LDY	SUBSVAR3	;SEE IF WE NEED TO TURN IT OFF (VALUE=0)
	BNE	SOLID10
	EOR	#8
SOLID10:
	STA	ANIM_RAM+FB,X	;SET THE FLAG 
	LDA	#0
	RTS

;THIS CALL WILL CAUSE A SPRITE BLOCK OR ANIMATION TO BE DISPLAYED AS
;ITS MIRROR IMAGE OR IT WILL CANCEL THAT FUNCTION.  IT SAVES PROCESSOR
;POWER BY NOT UPDATING IF THE SAME STATE IS SELECTED.

;LOAD A WITH THE SLOT NUMBER AND X WITH 0 FOR CANCEL, <>0 FOR MIRROR IMAGE.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

MIRROR:	STX	SUBSVAR3	;SAVE FLAG
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
	PHA			;SAVE A COPY
	AND	#%10111111	;REMOVE THE MIRROR FLAG
	LDY	SUBSVAR3	;GET BACK MIRROR FLAG
	BEQ	MR10
	ORA	#$40		;IF FLAG SET, SET MIRROR BIT
MR10:	STA	ANIM_RAM+AF,X	;PUT BACK NEW STATE
	STA	SUBSVAR3	;KEEP A COPY
	PLA			;GET ORIGINAL
	EOR	SUBSVAR3	;SEE IF BITS ARE SAME
	AND	#$C0
	BEQ	MR20
	JSR	SPFRAME		;IF CHANGE, UPDATE ANIMATION
MR20:	LDA	#0
	RTS

;THIS CALL WILL CAUSE A SPRITE BLOCK OR ANIMATION TO BE DISPLAYED UPSIDE
;DOWN FROM ITS ORIGINAL SPECIFICATION.  IT SAVES PROCESSOR POWER BY NOT 
;UPDATING IF THE STATE IS THE SAME.

;LOAD A WITH THE SLOT NUMBER AND X WITH 0 FOR CANCEL, <>0 FOR UPSIDE DOWN.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

INVERT:	STX	SUBSVAR3	;SAVE FLAG
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
	PHA			;SAVE A COPY
	AND	#$7F		;REMOVE THE INVERT FLAG BIT
	LDY	SUBSVAR3	;GET BACK INVERT FLAG
	BEQ	IN10
	ORA	#$80		;IF FLAG SET, SET INVERT BIT
IN10:	JMP	MR10

;THIS CALL WILL CAUSE A SPRITE OR BACKGROUND ANIMATION TO AUTOMATICALLY
;KILL ITSELF (FREE THE SLOT) AFTER IT HAS COMPLETED THE LAST FRAME.

;LOAD A WITH THE SLOT NUMBER.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

;IF YOU WANT TO REENABLE THIS YOU MUST REMOVE SOME COMMENTS FROM
;WITHIN THE SPRITE SERVICE ROUTINE (SEE MANUAL_KILL CALL THERE).
;AUTOKILL:
;	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
;	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
;	ORA	#$20		;SET AUTOKILL FLAG
;	STA	ANIM_RAM+AF,X	;PUT BACK NEW STATE
;	LDA	#0
;	RTS

;THIS CALL WILL CAUSE A SPRITE OR BACKGROUND ANIMATION TO AUTOMATICALLY
;FREEZE ITSELF AFTER IT HAS COMPLETED THE LAST FRAME.

;LOAD A WITH THE SLOT NUMBER.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

AUTOFREEZE:
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
	ORA	#$10		;SET AUTOFREEZE FLAG
	STA	ANIM_RAM+AF,X	;PUT BACK NEW STATE
	LDA	#0
	RTS

;THIS CALL WILL FREEZE AN ANIMATION SEQUENCE.  WHEN FROZEN, NEITHER TIME
;BASED ANIMATION UPDATES NOR SCREEN ALIGNMENT BASED UPDATES WILL TAKE
;PLACE.  SELFRAME CAN BE USED TO CHANGE THE FRAME.

;LOAD A WITH THE DESIRED SLOT #.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

;FREEZE:	JSR	USEDINDX
;	ORA	#$40
;	STA	ANIM_RAM+FB,X	;IF IN USE, SET FROZEN BIT
;	LDA	#0
;	RTS

;THIS CALL WILL GET THE CURRENT FRAME NUMBER OF A SPRITE/ANIMATION 
;SLOT AND RETURN IT IN X.  IF THE SPRITE IS NOT AN ANIMATION, 0 IS
;ALWAYS RETURNED.
;LOAD A WITH THE SLOT #.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

GETFRAME:
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+FR,X	;GET FRAME NUMBER	
	TAX
	LDA	#0		;RETURN NO ERROR
	RTS

;THIS CALL WILL SELECT THE CURRENT ANIMATION FRAME AND UPDATE THE DISPLAY.
;IT IS BEST TO FREEZE THE ANIMATION OR ENABLE SCREEN ALIGNMENT OF THE 
;FRAME WILL BE OVERWRITTEN AT NEXT TIME BASED UPDATE.   DO NOT SELECT
;AN ILLEGAL FRAME #. IF YOU HAVE 4 FRAMES, YOUR CHOICES ARE 0-3.

;LOAD A WITH THE SLOT # AND X WITH THE DESIRED FRAME.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT # OR NOT ANIMATION.

;SELFRAME:
;	STX	SUBSVAR3
;	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
;	LDA	SUBSVAR3
;	STA	ANIM_RAM+FR,X	;SET CURRENT FRAME
;	LDA	ANIM_RAM+FB,X
;	BMI	SFL9		;IF NOT POSITIONED YET, NO UPDATE

;	AND	#3		;KEEP ONLY FRAME TYPE BITS
;	CMP	#2		;NOT ANIMATION?
;	BNE	SFL9		;SPRITE ANIMATION?
;	JSR	SPFRAME		;IF SO, CALL HERE
;SFL9:	LDA	#0
;	RTS

;THIS ROUTINE WILL CALL ANIMINDX AND WILL ALSO CHECK FOR AN UNUSED SLOT #.
;IF THE SLOT # IS INVALID OR UNUSED, THIS ROUTINE WILL NOT RETURN TO YOU,
;IT WILL POP THE STACK AND THEN DO A RTS.  OTHERWISE, IF IT RETURNS TO
;YOU A HAS THE FLAG BYTE AND X HAS THE INDEX.

USEDINDX:
	JSR	ANIMINDX
	BNE	UDX10
	LDA	ANIM_RAM+FB,X
	BEQ	UDX5
	RTS

UDX5:	LDA	#1	;IF UNUSED, RETURN 1 VALUE
UDX10:	TAX		;SAVE ERROR CODE
	PLA		;POP THE RETURN ADDRESS OF CALLER
	PLA		;POP THE RETURN ADDRESS OF CALLER
	TXA
	RTS		;AND RETURN TO HIS CALLER WITH CORRECT ERROR

;THIS ROUTINE WILL CONVERT A SLOT NUMBER IN A INTO AN INDEX IN X.  IT
;ALSO CHECKS FOR IN RANGE.  ON RETURN Z AND A=0 IF VALID.    A=-1 IF INVALID.

ANIMINDX:
	CMP	#SPSLOTS	;VALID VALUE TO FREE UP?
	BCS	AX40		;SKIP IF NOT

	TAX
	LDY	#ANIM_WIDE
	JSR	MUL
	LDA	#0
	RTS

AX40:	LDA	#-1
	RTS

;THIS ROUTINE WILL TAKE AN ANIMATION/SPRITE SLOT INDEX IN X AND UPDATE THE CHAR 
;AND PALETTE INFO. IT ALWAYS PRESERVES THE INUSE AND BEHIND BITS.  
;ITS ONLY FOR SPRITES, NOT OBJECT ANIMATIONS.  

;IF SBL BIT $08 TRUE, THIS ROUTINE WILL REPLACE
;THE IMAGE WITH BLANK CHARS ($FA).

;IT SAVES YOUR X IN ALL CASES.

SPFRAME:
	TXA
	PHA

  	LDA	ANIM_RAM+FB,X
	AND	#$3
	CMP	#1
	BNE	SPF5

	LDA	ANIM_RAM+PTRL,X	;IF JUST SPRITE AND NOT ANIMATION, USE PTR
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2
	JMP	SPF25

SPF5:	LDA	ANIM_RAM+FR,X	;GET CURRENT FRAME
	LDY	#0
	ASL	A
	BCC	SPF10
	LDY	#1		;MAKE Y:A=OFFSET IN ANIMATION LIST
SPF10:	CLC
	ADC	#3		;AND NEED TO SKIP FLAG BYTES
	BCC	SPF20
	INY			;MOVE UP ANY CARRY
SPF20:	CLC
	ADC	ANIM_RAM+PTRL,X	;ADD IN THE LOW POINTER
	STA	SUBSVAR1
	TYA
	ADC	ANIM_RAM+PTRH,X	;ADD IN HIGH
	STA	SUBSVAR2	;NOW HAVE POINTER TO THE NEXT FRAME'S OFFSET
	LDY	#0
	LDA	(SUBSVAR1),Y	;GET LOW
	PHA
	INY
	LDA	(SUBSVAR1),Y	;GET HIGH
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;NOW HAVE POINTER TO THE DATA

;SUBSVAR1 POINTS TO THE SPRITE DATA, X STILL HAS THE INDEX FOR THE SPRITE
;SLOT.  SET UP OUR LOOP VARIABLES BASED ON WHETHER WE ARE INVERTING OR
;MIRRORING.

;WE MAKE A VALUE TO ADD TO FOR EACH MOVEMENT UP OR DOWN, A VALUE TO
;ADD AT THE END OF EACH ROW, AND WE SET UP A COUNT OF ROWS AND A WIDTH
;FOR EACH ROW.

SPF25: 	LDY	#1		;POINT TO WIDTH OF SPRITE
	LDA	(SUBSVAR1),Y
	STA	MATH1		;SAVE HERE
	INY			;POINT TO HEIGHT
	LDA	(SUBSVAR1),Y
	STA	MATH2		;SAVE HERE AS LOOP COUNTER
	INY			;POINT TO DATA

	LDA	ANIM_RAM+AF,X	;GET INVERT/MIRROR STATE
	AND	#$C0		;KEEP THESE BITS
	STA	MATH3		;SAVE HERE
	BMI	SPF30		;SKIP

;NOT INVERTED, NOT MIRRORED

	AND	#$40		;SEE IF MIRRORED
	BNE	SPF28
	LDA	#4
	STA	SUBSVAR3	;4 BEFORE EACH SPRITE
	LDA	#0
	STA	SUBSVAR4	;0 AT EACH ROW'S END
	STA	SUBSVAR5	;AND SET TO ADD IT
	LDA	ANIM_RAM+BS,X	
SPF26:	SEC
	SBC	#4		;START 4 DOWN
	BCC	SPF26		;BUT NEED TO SKIP FC IF WE END UP ON IT.
	TAX
	JMP	SPF50		;GO DO IT

;NOT INVERTED, BUT IT IS MIRRORED.

SPF28:	LDA	#-4
	STA	SUBSVAR3	;-4 BEFORE EACH SPRITE
	LDA	MATH1
	ASL	A
	ASL	A		;MAKE WIDTH*4
	STA	MATH4
	ASL	A
	STA	SUBSVAR4	;2*WIDTH*4 PER SPRITE AT EACH ROW'S END
	LDA	#0
	STA	SUBSVAR5	;SET TO ADD IT
	LDA	MATH4		;GET WIDTH*4
	CLC
	ADC	ANIM_RAM+BS,X	;START 1 ROW UP
	BCS	SPF29
	CMP	#252		;BUT WE MUST SKIP THIS ONE
	BNE	SPF29A	
SPF29:	CLC
	ADC	#4		;IF PASS 0, SKIP FC
SPF29A:	TAX
	JMP	SPF50		;GO DO IT

;INVERTED

SPF30:	AND	#$40		;SEE IF MIRRORED
	BNE	SPF35	

	LDA	#4
	STA	SUBSVAR3	;4 BEFORE EACH SPRITE
	LDA	MATH1
	ASL	A
	ASL	A
	STA	MATH4
	ASL	A
	STA	SUBSVAR4	;-2*WIDTH AT EACH ROW'S END

	LDA	ANIM_RAM+NS,X
	ASL	A
	ASL	A
	SEC
	SBC	MATH4
	SEC
	SBC	#4		;MAKE END-WIDTH*4-4
	STA	SUBSVAR5	;SAVE FOR SUBTRACTING

	LDA	ANIM_RAM+BS,X	;POINT TO END
	CLC
	ADC	SUBSVAR5
	BCS	SPF31
	CMP	#252		;BUT WE MUST SKIP THIS ONE
	BNE	SPF31A	
SPF31:	CLC
	ADC	#4		;IF PASS 0, SKIP FC
SPF31A:	TAX	     		;START AT END-WIDTH*4-4

	LDA	#-1
	STA	SUBSVAR5	;SET FLAG TO SUBTRACT THE SUBSVAR4 VALUE
	JMP	SPF50		;GO DO IT

;INVERTED AND MIRRORED

SPF35:	LDA	#-4
	STA	SUBSVAR3	;-4 BEFORE EACH SPRITE
	LDA	#0
	STA	SUBSVAR4	;0 AT EACH ROW'S END
	STA	SUBSVAR5	;SET TO ADD IT.
	LDA	ANIM_RAM+NS,X
	ASL	A
	ASL	A
	CLC
	ADC	ANIM_RAM+BS,X	;POINT TO END
	BCS	SPF36
	CMP	#252		;BUT WE MUST SKIP THIS ONE
	BNE	SPF36A	
SPF36:	CLC
	ADC	#4		;IF PASS 0, SKIP FC
SPF36A:	TAX	     		;START AT END

;NOW:
;X POINTS TO THE STARTING SPRITE (BEFORE START OF LOOP CORRECTION),
;MATH1=WIDTH
;MATH2=HEIGHT
;MATH3=INVERT/MIRROR BITS
;SUBSVAR3=CORRECTION BEFORE EACH SPRITE (+ OR - 4)
;SUBSVAR4=END OF ROW CORRECTION.  SUBSVAR5=0 IF ADDED, -1 IF SUBTRACTED.

SPF50: 	LDA	MATH1
	STA	MATH4		;SET A LOOP COUNT FOR THE ROW

SPF60:	TXA
	CLC
	ADC	SUBSVAR3	;CORRECT TO NEXT SPRITE
	CMP	#252		;WE ONLY HAVE 63 SPRITES CAUSE OF TOPSPRITE
	BNE	SPF61
	CLC
	ADC	SUBSVAR3	;CORRECT TO NEXT SPRITE
SPF61:	TAX
	LDA	(SUBSVAR1),Y	;GET CHAR TO USE
	STA	SPRAM+1,X	;SET CHAR INTO SPRITE
	INY			;POINT TO PAL/FLIP INFO
	LDA	SPRAM+2,X	;GET THE BEHIND BIT
	AND	#$20		;KEEP IT
	ORA	#8		;ALWAYS SET IN USE FOR INITSPRT
	ORA	(SUBSVAR1),Y	;MOVE INTO PAL INFO
	EOR	MATH3		;TOGGLE MIRROR/INVERT BITS CONDITION
	STA	SPRAM+2,X	;SAVE BACK OUT
	INY			;SKIP TO NEXT SPRITE
	DEC	MATH4		;COUNT 1 MORE ON THIS ROW
	BNE	SPF60

	TXA			;TIME TO CORRECT FOR ROW
	LDX	SUBSVAR5	;SEE IF ADD OR SUBTRACT THIS VALUE
	BPL	SPF61A
	SEC
	SBC	SUBSVAR4	;WE NEED TO SUBTRACT IT
	BCS	SPF62		;A CARRY MEANS IT WAS OK
	SEC
	SBC	#4		;OTHERWISE WE NEED ADJUSTMENT
	JMP	SPF62

SPF61A:	CLC
	ADC	SUBSVAR4
	BCS	SPF61B		;IF CARRY, GO ADD 4.
	CMP	#252		;IF NO CARRY, IS IT EXACTLY THE ILLEGAL VALUE?
	BNE	SPF62
SPF61B:	CLC
	ADC	#4

SPF62:	TAX
	DEC	MATH2		;WHEN ROW IS DONE, COUNT 1 MORE ROW
	BNE	SPF50

	PLA
	TAX
	RTS

;THIS ROUTINE WILL CHECK IF ANY ANIMATIONS NEED SERVICING.  IT GOES THROUGH
;THE ANIMATION SLOTS AND LOOKS FOR THOSE ACTIVE WITH AN ANIMATION.  IT
;SHOULD BE CALLED EACH NMI.

CHECK_ANIM:

	LDX	#0		;POINT TO THE SLOTS
	LDY	#SPSLOTS	;GET COUNT TO CHECK

;CHECK AND PROCESS EACH SLOT.

CA10: 	TYA
	PHA			;SAVE LOOP COUNT
	LDA	ANIM_RAM+FB,X	;GET THE FLAG BYTE
	AND	#$3		;KEEP ONLY ID BITS
	TAY			;KEEP COPY HERE
	BNE	CA20		;SKIP IF TRUE.  MEANS SLOT IN USE.

CA15: 	PLA
	TAY			;GET BACK LOOP COUNT
	TXA
	CLC
	ADC	#ANIM_WIDE	;SKIP TO NEXT
	TAX
	DEY
	BNE	CA10
	RTS

;FOUND A USED SLOT.  IF JUST SPRITE (1) DO NOTHING.

CA20:	TYA
 	CMP	#1
	BEQ	CA15

;ITS AN ANIMATION.  SEE IF FROZEN OR IF ALIGNMENT BY X OR Y.  IF NOT, COUNT 
;IT DOWN.

	LDA	ANIM_RAM+FB,X
	AND	#$70
	BEQ	CA25
	TYA				;GET BACK TYPE
	JMP	CA37			;IF NOT COUNTING, NEED UPDATE ANYWAY?	

CA25:	DEC	ANIM_RAM+CN,X
	BNE	CA37

;ANIMATION WENT TO ZERO.  IF BACKGROUND ANIMATION, SET REFRESH NEEDED FLAG.

	TYA
	CMP	#3
	BNE	CA30
	LDA	ANIM_RAM+NS,X
	ORA	#$80
	STA	ANIM_RAM+NS,X

;RELOAD THE FREQUENCY AND MOVE FRAME TO NEXT.

CA30: 	LDA	ANIM_RAM+RL,X
	STA	ANIM_RAM+CN,X
	LDA	ANIM_RAM+PTRL,X
	STA	NMI_PTR
	LDA	ANIM_RAM+PTRH,X
	STA	NMI_PTR+1

	INC	ANIM_RAM+FR,X	;INC FRAME
	LDA	ANIM_RAM+FR,X	;GET IT
	LDY	#1		;POINT TO THE FRAMES IN DEFFINITION
	CMP	(NMI_PTR),Y	;HIT END OF LIST?
	BNE	CA35
	LDA	ANIM_RAM+AF,X	;SEE IF AUTOFREEZE
	AND	#$10
	BEQ	CA32
	LDA	ANIM_RAM+FB,X
	ORA	#$40
	STA	ANIM_RAM+FB,X	;FREEZE IT IF SO
	DEC	ANIM_RAM+FR,X	;AND FIX IT, WE CHANGED IT LAST TIME.
	JMP	CA15	     	

CA32:	LDA	#0
	STA	ANIM_RAM+FR,X	;RESET IF TOO BIG
;	LDA	ANIM_RAM+AF,X	;IF HAVE TO WRAP, AUTOKILL ENABLED?
;	AND	#$20		;AUTOKILL?
;	BEQ	CA35
;	JSR	MANUAL_KILL	
;	JMP	CA15

;WE COUNTED DOWN.  IF SPRITE, UPDATE FRAME.

CA35:	LDA	ANIM_RAM+FB,X
	AND	#3
	CMP	#2
	BNE	CA37
	JSR	SPFRAME		;THIS ROUTINE WILL DO IT
CA37:	JMP	CA15		;AND NOT A BACKGROUND FOR SURE.

;THESE ARE THE 2 BYTES TO LOAD INTO THE LOW REGISTERS FOR A GIVEN INSTRUMENT.
;THE SOUND FLAG BYTES SPECIFY THE INSTRUMENT AND THAT IS CONVERTED INTO
;A *2 INDEX FOR USE HERE.  IF THE VOICE IS 3 OR 4 THEN THESE VALUES DO NOT
;REALLY MAKE SENSE. 

INSTRUMENTS:	

.byte	$C0,$00          		;BASE_HARPSI
.byte	$C0,$00          		;HARPSI
.byte	$C0,$00          		;HIGH_HARPSI    
.byte	$80,$00          		;BASE_STRING
.byte	$80,$00          		;STRING
.byte	$80,$00          		;HIGH_STRING    
.byte	$00,$00          		;BASE_ELECPIANO
.byte	$00,$00          		;ELECPIANO
.byte	$00,$00          		;HIGH_ELECPIANO
.byte	$80,$FF          		;BASE_SLIDER
.byte	$80,$FF          		;SLIDER
.byte	$80,$FF          		;HIGH_SLIDER   
.byte	$00,$D6          		;BASE_BEE
.byte	$00,$D6          		;BEE
.byte	$00,$D6          		;HIGH_BEE
.byte	$40,$00          		;BASE_PIANO
.byte	$40,$00          		;PIANO
.byte	$40,$00          		;HIGH_PIANO
.byte 	$80,$C9			;BASE_ARCADE
.byte 	$80,$C9			;ARCADE
.byte 	$80,$C9			;HIGH ARCADE

;THIS ROUTINE WILL GO THROUGH THE SOUND SLOTS AND WILL FEED THE NEXT
;CORRECT DATA TO THE SOUND CHIP ACCORDING TO THE ACTIVE SLOTS.  IT SHOULD
;BE CALLED EACH NMI.

FEED_SOUND:

	TSX
	TXA
	SEC
	SBC	#6		;MAKE ROOM TO HOLD DATA FOR SOUND COMMANDS
	TAX
	TXS
	INX			;POINT TO WHERE IT WILL GO
	STX	TMP_NMIE	;MAKE THIS A POINTER TO THE DATA WE GOT

	LDX	#0		;START WITH THE LOWEST SOUND SLOT.
	STX	FOUNDSOME	;SET FLAG OF DIDN'T FIND AN ACTIVE ONE	
FS20:	LDA	SND_RAM+SF,X	;GET THE SOUND FLAG
	BPL	FS30		;IF NOT IN USE, SKIP IT

;FOUND A SOUND THAT IS RUNNING.  COUNT DOWN ITS TIMER.

	STA	FOUNDSOME	;SET FLAG OF FOUND ONE

	DEC	SND_RAM+ST,X	;COUNT IT DOWN
	BEQ	FS50		;IF REACHES ZERO, TIME FOR MORE PROCESSING	

;DONE WITH THIS SOUND, OR NOT IN USE.

FS30:	TXA
	CLC
	ADC	#SND_WIDE
	TAX
	CMP	#SND_WIDE*SNDSLOTS	;END OF LIST?
	BCC	FS20			;IF NOT, CONTINUE

;SEE IF ANY SLOTS AT ALL WERE RUNNING. IF NOT, WE DISABLE ALL VOICES
;IN THE SOUND REGISTER.  THIS IS BECAUSE NOW WITH PERCUSSION WE NEVER
;DISABLE THEM WHEN THEY FINISH.

	LDA	FOUNDSOME
	BNE	FS31
	LDA	#0
	STA	DRUMLOCK	;UNLOCK DRUMS IN CASE USER FORGETS ALLOWDRUMS
	STA	REG4015
	STA	$4015		;DISABLE ALL WHEN NO SLOTS ACTIVE.
FS31: 	TSX
	TXA
	CLC
	ADC	#6		;REMOVE EXTRA ROOM WE MADE IN STACK
	TAX
	TXS			;FIX STACK
	RTS

;THIS SOUND NEEDS TO BE UPDATED.  ITS TIMER RAN OUT.

FS50:	LDA	SND_RAM+SOL,X		;GET LOW OFFSET OF NEXT BYTE TO USE
	STA	SUBSVAR1
	LDA	SND_RAM+SOH,X		;GET HIGH
	STA	SUBSVAR2		;MAKE POINTER TO THE NEXT BYTE
	STX	TMP_NMID		;SAVE OUR INDEX
	LDA	#5
	STA	SUBSVAR3
	JSR	FILLSTACK		;GET THE LARGEST POSSIBLE COMMAND
	LDX	TMP_NMID		;GET BACK OUR INDEX

;PROCESS NEXT COMMAND FOR THIS SOUND SLOT.  THE DATA IS AT $100,TMP_NMIE.

	LDY	TMP_NMIE		;POINT TO THE DATA
FS60:	LDA	$100,Y
	AND	#%11100000		;SEE IF JUST A NOTE
	CMP	#%10100000		;NOTES END BELOW THIS
	BCS	FS200

;JUST ANOTHER NOTE TO PLAY.  BUT IF THE REGISTER BASE IS $1F WE DO THINGS 
;DIFFERENTLY BECAUSE ITS A PERCUSSION INSTRUMENT.

	LDA	$100,Y			;GET BACK DURATION
	JSR	SET_DURATION		;SET DURATION, RESTORE INSTRUMENT
	BNE	FS70			;IF SUSPENDED, DON'T WASTE TIME
	
	LDA	NMI_PTR			;SEE IF PERCUSSION INSTRUMENT FLAG
	CMP	#$1F
	BEQ	FS100			;SKIP IF IT IS (PERCUSSION)

	LDA	SND_RAM+SI,X		;GET INSTRUMENT TYPE
	ASL	A			;MAKE *2 POINTER
	TAY
	LDA	FREQBASES,Y		;GET LOW BASE OF FREQUENCY TABLE
	STA	NMI_PTR
	LDA	FREQBASES+1,Y
	STA	NMI_PTR+1		;MAKE POINTER TO FREQUENCY TABLE
	LDY	TMP_NMIE
	LDA	$100,Y			;GET NOTE TO USE
	AND	#$1F
	CMP	#PAUSE			;SILENCE?
	BEQ	FS70
	ASL	A			;MAKE INDEX FROM IT
	TAY
	LDA	(NMI_PTR),Y
	STA	SUBSVAR3
	INY
	LDA	(NMI_PTR),Y
	STA	SUBSVAR4		;SET FREQUENCY TO USE
	JSR	SET_FREQUENCY
FS70:  	JSR	INC_INDX
	JMP	FS30
     
;ITS A PERCUSSION INSTRUMENT
	
FS100:	TXA
	PHA			;SAVE OUR INDEX
	LDA	$100,Y		;GET LOW 5 BITS TO FIND BASE OF PERCUSSION
	AND	#$1F		;IN THE PERCUSSION TABLE.
	AND	#$1F
	CMP	#PAUSE			;SILENCE?
	BEQ	FS115
	STA	SUBSVAR4	;SAVE A COPY
	ASL	A
	ASL	A		;MAKE *4 POINTER
	CLC
	ADC	SUBSVAR4	;MAKE *5 POINTER
	TAX
FS110:	LDA	PERCTABLE,X
	STA	NMI_PTR		;SET CORRECT BASE FROM FIRST BYTE
	INX
	JSR	FINISH_BIT	;MAKE TEST BIT FOR DRUMLOCK
	AND	DRUMLOCK
	BNE	FS115

	LDY	#0
FS111:	LDA	PERCTABLE,X
	STA	(NMI_PTR),Y	;SET THE INSTRUMENT
	INX
	INY
	CPY	#4
	BNE	FS111
FS115:	PLA
	TAX
	JMP	FS70

;ITS A SPECIAL COMMAND.

FS200:	CMP	#%10100000	;SELECT INSTRUMENT?
	BNE	FS220
	LDA	$100,Y		;GET BACK INSTRUMENT
	AND	#$1F
	STA	SND_RAM+SI,X	;PUT INTO SLOT
	LDA	SND_RAM+SF,X	;SEE IF SUSPENDED OR NO BASE
	AND	#$60
	BNE	FS210
	JSR	INITSND		;INITIALIZE FOR THIS INSTRUMENT

;DONE WITH THIS SOUND AND NEED TO INC THE POINTER AND PUT IN A 1 NMI DELAY.

FS210:	JSR	INC_INDX
	LDA	#1
	STA	SND_RAM+ST,X	;SET TIMER FOR NEXT NMI
	JMP	FS30
	
;CONTROL COMMAND?

FS220:	LDA	$100,Y
 	CMP	#SOUNDLOOP	;SOUND LOOP?
	BNE	FS230

	LDA	SND_RAM+LOP,X	;SEE IF WE ARE ALREADY LOOPING
	BNE	FS221
	LDA	$101,Y
	STA	SND_RAM+LOP,X	;SET LOOP COUNT FOR A NEW TIME
FS221:	DEC	SND_RAM+LOP,X	;LOWER COUNT OF TIMES LEFT TO LOOP
	BEQ	FS222
	LDA	$102,Y		;GET LOW ADDRESS TO LOOP TO
	STA	SND_RAM+SOL,X
	LDA	$103,Y
	STA	SND_RAM+SOH,X	;SET US BACK TO THAT ADDRESS
	JMP	FS50		;AND RUN NEW LOCATION SO THIS TAKES NO TIME

FS222:	JSR	INC_INDX	;WE ARE DONE LOOPING
	JSR	INC_INDX
	JSR	INC_INDX
	JSR	INC_INDX
	JMP	FS50

;DRUMS INTERFERENCE CONTROL.  USER SHOULD ISSUE THIS AFTER VOICE SELECTION
;(SUCH AS VOICE3) TO PREVENT DRUMS FROM INTERFERING.  UNLOCK IT WITH
;ALLOWDRUMS BEFORE YOU ENDPLAY.

FS230:	CMP	#NODRUMS
	BNE	FS235
	JSR	ENABLE_BIT
	ORA	DRUMLOCK
	STA	DRUMLOCK	;SET BIT TO LOCK OUT THE DRUM
	JMP	FS210

FS235:	CMP	#ALLOWDRUMS
	BNE	FS240
	JSR	ENABLE_BIT
	PHA
	ORA	DRUMLOCK
	STA	DRUMLOCK
	PLA
	EOR	DRUMLOCK
	STA	DRUMLOCK
	JMP	FS210

;EXTENDED COMMAND.

FS240:	LDA	$100,Y		;GET THE EXTENDED BITS
	AND	#%00011111	;KEEP THEM AND THE DATA BITS TOO.
	CMP	#%00000011+1	;SEE IF SPECIFY VOICE COMMAND
	BCS	FS260

	AND	#3		;GET THE VOICE TO USE
	ASL	A
	ASL	A		;MAKE *4 BASE POINTER

FS245: 	PHA			;SAVE VOICE BASE BITS
	LDA	SND_RAM+SF,X	;GET CURRENT VALUE
	AND	#$E0		;REMOVE THE BITS THAT SELECT THE BASE REG
	STA	SND_RAM+SF,X
	PLA
	ORA	SND_RAM+SF,X	;PUT NEW REGISTER BASE INTO THE FLAG BYTE
	AND	#$9F		;REMOVE REGISTER NOT SELECTED BIT AND SUSPEND
	STA	TMP_NMI1	;SAVE HERE FOR CHECK FOR OTHER'S USING IT
	STA	SND_RAM+SF,X
	STX	TMP_NMI2	;SAVE OUR INDEX

	LDX	#0
FS250:	LDA	SND_RAM+SF,X	;GET A FLAG BYTE
	EOR	TMP_NMI1	;SEE IF THAT SOUND SLOT IS USING THIS VOICE
	BNE	FS255
      	LDA	SND_RAM+SF,X
	ORA	#$20		;IF SO, SUSPEND HIM
	STA	SND_RAM+SF,X
FS255:	TXA
	CLC
	ADC	#SND_WIDE
	TAX
	CMP	#SND_WIDE*SNDSLOTS	;DONE?
	BCC	FS250

	LDX	TMP_NMI2	;GET BACK OUR INDEX
	LDA	TMP_NMI1	;AND OUR FLAG BYTE
	STA	SND_RAM+SF,X	;PUT BACK OUR FLAG CAUSE OUR LOOP SUSPENDED US
	JSR	ENABLE_VOICE	;AND ENABLE OUR VOICE
	JMP	FS210

FS260:	CMP	#%00000111+1	;REPEAT LIST?
	BCS	FS280
	LDA	SND_RAM+SBL,X
	STA	SND_RAM+SOL,X
	LDA	SND_RAM+SBH,X
	STA	SND_RAM+SOH,X	;IF SO, JUST RESET POINTER
	JMP	FS210		;AND SKIP THIS COMMAND.


FS280:	CMP	#%00001011+1	;END LIST?
	BCS	FS300
	TXA
	PHA
	JSR	S20		;USE THE SILENCE ROUTINE'S SPECIAL ENTRY PNT.
	PLA
	TAX
	JMP	FS210

FS300:	CMP	#%00001111+1	;ABSOLUTE REG LOAD?
	BCS	FS320

	LDA	SND_RAM+SF,X
	AND	#$60
	BNE	FS311		;SKIP IT IF NOT SELECTED OR SUSPENDED

FS310:	LDA	SND_RAM+SF,X	;GET REG BASE FOR THIS VOICE
	AND	#$1F		;KEEP THE REG OFFSET
	STA	SUBSVAR3
	LDY	TMP_NMIE
	LDA	$100,Y		;GET LOW 2 BITS OF REG TO USE
	AND	#3
	CLC
	ADC	SUBSVAR3	;MAKE IT INTO A POINTER
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;AND POINT TO THE REG AT 40XX
	LDY	TMP_NMIE
	LDA	$101,Y		;GET VALUE TO USE
	LDY	#0
	STA	(NMI_PTR),Y	;PUT IT OUT THERE
FS311:	JSR	INC_INDX		;SKIP THE EXTRA BYTE WE USED
	JMP	FS210	

FS320:	CMP	#%00010011+1	;DISABLE SOUND?
	BCS	FS340
	JSR	DISABLE_VOICE
	JMP	FS210

FS340:	CMP	#%00010111+1	;ENABLE SOUND?
	BCS	FS360
	JSR	ENABLE_VOICE
	JMP	FS210

FS360:	CMP	#PERCUSSION & %00011111 	;USE PERCUSSION INSTRUMENTS?
	BNE	FS365
	LDA	SND_RAM+SF,X	;GET CURRENT VALUE
	AND	#$E0		;REMOVE THE BITS THAT SELECT THE BASE REG
	ORA	#$1F		;SET ALL BITS TO FLAG PERCUSSION
	AND	#$9F		;REMOVE REGISTER NOT SELECTED BIT AND SUSPEND
	STA	SND_RAM+SF,X	;PUT IT BACK FOR THE NOTE COMMANDS TO DETECT
	JSR	ENABLE_VOICE	;ENABLE OUR VOICES
	JMP	FS210

FS365:	CMP	#LOADALL & %00011111	;LOAD ALL REGS?
	BNE	FS380

	LDA	SND_RAM+SF,X
	AND	#$60
	BNE	FS367		;SKIP IT IF NOT SELECTED OR SUSPENDED

	LDA	SND_RAM+SF,X	;GET REG BASE FOR THIS VOICE
	AND	#$1F		;KEEP THE REG OFFSET
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;AND POINT TO THE REG AT 40XX

	LDA	TMP_NMIE
	STA	TMP_NMIC
	LDY	#0
FS366: 	STY	TMP_NMID
	INC	TMP_NMIC
	LDY	TMP_NMIC
	LDA	$100,Y		;GET VALUE TO USE
	LDY	TMP_NMID
	STA	(NMI_PTR),Y	;PUT IT INTO THE CORRECT REGISTER
	INY
	CPY	#5
	BNE	FS366

FS367:	JSR	INC_INDX		;SKIP THE EXTRA BYTES WE USED
	JSR	INC_INDX		
	JSR	INC_INDX		
	JSR	INC_INDX		
	JMP	FS210	

FS380:	CMP	#WAIT & %00011111	;FIXED DELAY?
	BNE	FS390
	LDY	TMP_NMIE
	LDA	$101,Y		;GET VALUE TO USE FOR THE DELAY
	STA	SND_RAM+ST,X	;RELOAD THE TIMER
	JSR	INC_INDX
	JSR	INC_INDX
	JMP	FS30

;COMMAND NOT RECOGNIZED.  JUST SKIP IT.

FS390:	JMP	FS210

;THIS ROUTINE WILL TAKE A SOUND SLOT INDEX IN X AND ENABLE THE APPROPRIATE
;BIT IN THE SOUND ENABLE REGISTER TO MAKE THOSE REGISTERS ACTIVE.

ENABLE_VOICE:

	JSR	ENABLE_BIT
	ORA	REG4015
	STA	REG4015
	STA	$4015		;ENABLE IT AND SAVE VALUE FOR OTHERS TO REF.
	RTS

;THIS ROUTINE WILL DISABLE A VOICE SIMILAR TO ENABLE VOICE.
;ACTUALLY, NOW IT JUST TEMPORARILY STOPS AND THEN RE-ENABLES THAT VOICE
;BECAUSE PERCUSSION NEEDS TO KEEP IT GOING.

DISABLE_VOICE:
	JSR	ENABLE_BIT
	CMP	#PERCENABLE	;PERCUSSION INSTRUMENT?
	BEQ	DVC10		;IF SO, DON'T DO IT.
	EOR	#$FF
	AND	REG4015
	STA	$4015
	LDA	REG4015
	STA	$4015		;DISABLE IT AND SAVE STATE	
DVC10:	RTS

;THIS ROUTINE WILL PUT AN ENABLE REGISTER BIT VALUE INTO A FOR THE SOUND
;SLOT INDEX IN X.  THIS VALUE IS FOR REG4015.

ENABLE_BIT:
	LDA	SND_RAM+SF,X	;GET THE REGISTERS TO USE
	AND	#$1F
	CMP	#$1F		;PERCUSSION?
	BEQ	EB30

FINISH_BIT:			;CALL HERE WITH YOUR OWN BASE REG TO MAKE
				;BIT IN A.J  ONLY A AND Y ARE CHANGED.
	LSR	A
	LSR	A		;MAKE INTO UNIQUE NUMBER 0-4
	TAY
	LDA	ENABIT,Y	;GET THE BIT POSITION
	RTS

ENABIT:	.byte	1,2,4,8,$10

EB30:	LDA	#PERCENABLE	;IF PERCUSSION, ENABLE THOSE USED.
	RTS

;THIS TABLE HAS A 2 BYTE VALUE FOR EACH NOTE DURATION.  THIS FIRST IS
;THE NUMBER OF NMI CYCLES WE SHOULD WAIT FOR THE NOTE TO COMPLETE.
;THE SECOND IS THE VALUE TO PUT INTO THE SOUND CHIP DURATION REGISTER BITS.

TIME_BASE:
.byte	8,1			;1/16 NOTE
.byte	16,5			;1/8 NOTE
.byte	32,8			;1/4 NOTE
.byte	64,15			;1/2 NOTE
.byte	128,31			;WHOLE NOTE



PERCTABLE:
.byte	$00,$80,$86,$FF,$0C	;BSD0
.byte	$08,$38,$F0,$E0,$19	;BSD1
.byte	$00,$80,$84,$00,$8B	;TOM0
.byte	$04,$80,$84,$00,$8B	;TOM1
.byte	$00,$80,$84,$FF,$0B
.byte	$0C,$1F,$FF,$6D,$18	;SN1 
.byte	$0C,$00,$00,$08,$02
.byte	$0C,$01,$01,$03,$09	;BRUSH
.byte	$0C,$0F,$00,$92,$C7
.byte	$0C,$05,$00,$81,$08
.byte	$0C,$80,$98,$10,$00	;HI HAT
.byte	$08,$03,$00,$F5,$30	;TOM2
.byte	$00,$80,$84,$00,$89	;HIGH TOM
.byte	$04,$80,$84,$00,$89
.byte	$00,$80,$84,$00,$8E	;LOW TOM
.byte	$04,$80,$84,$00,$8E

;THIS ROUTINE WILL TAKE A NOTE DURATION (1/16, 1/8, 1/4, ETC) AS SPECIFIED
;IN THE TOP 3 BITS OF A AND WILL SET THE TIME COUNTER VALUE IN
;THE SOUND SLOT AND WILL ALSO SET UP THE SOUND REGISTER RESPONSIBLE FOR
;THE TIME.  THE SLOT INDEX MUST BE IN X.  THE VALUES IN THE HIGH 3 BITS OF 
;A SHOULD RANGE FROM %000 TO %100.  IF THE SLOT IS SUSPENDED OR THE
;REGISTERS ARE NOT SELECTED, THIS ROUTINE WILL SET UP ONLY THE TIME
;BASE AND WILL NOT DO AN ACTUAL LOAD.  

;THIS ROUTINE NOT ONLY SETS IN THE DURATION, BUT ALSO PUTS BACK THE
;SECOND REGISTER VALUE AS SELECTED FOR THE CURRENT INSTRUMENT.  THIS
;IS BECAUSE THE PERCUSSION NOTES OVERWRITE ANY REGISTER SET AND
;DESTROY THE INSTRUMENT SELECTION.  THE NOTE PLAYING ROUTINE ALWAYS
;CALLS HERE AND THUS THIS ROUTINE RESTORES THE INSTRUMENT FOR IT.

;X IS SAVED BUT Y IS NOT.  SUBSVARs ARE NOT DISTURBED.    NMI LEVEL
;ROUTINE ONLY!  THIS ROUTINE RETURNS NZ IF THE SOUND SLOT WAS SUSPENDED.
;IF Z THEN (NMI_PTR) POINTS TO THE BASE OF THE SOUND REGISTERS AND Y=0.

SET_DURATION:

	LSR	A
	LSR	A
	LSR	A
	LSR	A		;MOVE BITS DOWN TO MAKE *2 INDEX
	AND	#$FE		;MAKE SURE INDEX IS EVEN
	TAY			;USE INDEX HERE
	LDA	TIME_BASE,Y	;GET THE TIME BASE FOR OUR SOUND STRUCTURE
	STA	SND_RAM+ST,X	;RELOAD THE TIMER

	JSR	SELECTED	;SEE IF SUSPENDED OR NO REGS SELECTED
	BNE	SD60

	INY
	LDA	TIME_BASE,Y	;GET THE RELOAD BITS FOR THE LOW REGISTER
	STA	TMP_NMI1	;SAVE IT HERE

	JSR	MAKEBASE	;MAKE (NMI_PTR) TO THE SOUND REGS

	LDA	SND_RAM+SI,X	;GET INSTRUMENT
	ASL	A		;MAKE *2 POINTER FROM IT
	TAY
	LDA	INSTRUMENTS+1,Y	;GET SECOND REGISTER THAT SPECIFIES INSTRUMENT
	PHA			;SAVE IT
	LDA	INSTRUMENTS,Y	;GET REGISTER VALUE TO LOAD
	ORA	TMP_NMI1	;OR IN THE TIME BASE
	LDY	#0
	STA	(NMI_PTR),Y	;PUT INTO THE SOUND CHIP
	INY
	PLA
	STA	(NMI_PTR),Y	;PUT SECOND REG THERE TOO
	LDY	#0
SD60:	RTS

;THIS ROUTINE WILL SET NMI_PTR TO THE BASE OF THE SOUND SLOT

MAKEBASE:
	LDA	SND_RAM+SF,X	;GET REGISTER BASE
	AND	#$1F		;MAKE BASE REG
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;INTO A POINTER WE CAN USE
	RTS

;THE FOLLOWING TABLE HAS A 1 WORD PTR TO THE FREQUENCY TABLE TO USE
;FOR A GIVEN INSTRUMENT.  THE INSTRUMENTS REPEAT THEIR RANGES IN 3'S
;SO ACTUALLY THE TABLE REPEATS A WHOLE LOT.

FREQBASES:

.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word	LOW_FREQ,MID_FREQ

;THIS TABLE CONTAINS THE FREQUENCIES TO USE FOR SPECIFIC NOTES IN
;A MULTI-OCTIVE RANGE.  THERE ARE 3 REFERENCE POINTS INTO THE TABLE
;FOR USE WITH THE VARIOUS INSTRUMENTS.

LOW_FREQ:
.word	$352		;C	
.word	$325		;C#	
.word	$2FD		;D	
.word	$2CC		;Eb	
.word	$2A7		;E	
.word	$27C		;F	
.word	$25A		;F#	
.word	$23B		;G	
.word	$213		;Ab	
.word	$1FD		;A	
.word	$1DE		;Bb	
.word	$1C6		;B	

MID_FREQ:
.word	$1AB		;C	
.word	$191		;C#	
.word	$17A		;D	
.word	$167		;Eb	
.word	$151		;E	
.word	$13F		;F	
.word	$12C		;F#	
.word	$11C		;G	
.word	$10D		;Ab	
.word	$FE 		;A	
.word	$EF 		;Bb	
.word	$E2 		;B	

HIGH_FREQ:
.word	$D5  		;MIDDLE C	
.word	$C8		;C#	
.word	$BE		;D	
.word	$B3		;Eb	
.word	$A9		;E	
.word	$9F		;F	
.word	$96		;F#	
.word	$8E		;G	
.word	$86		;Ab	
.word	$7E		;A	
.word	$77		;Bb	
.word	$70		;B	
.word	$6A		;C	
.word	$64		;C#	
.word	$5E		;D	
.word	$59		;Eb	
.word	$54		;E	
.word	$4F		;F	
.word	$4B		;F#	
.word	$46		;G	
.word	$42		;Ab	
.word	$3F		;A	
.word	$3B		;Bb	
.word	$38		;B	
.word	$34		;C	
.word	$32		;C#	
.word	$2F		;D	
.word	$2C		;Eb	
.word	$29		;E	
.word	$27		;F	
.word	$24		;F#	
.word	$23		;G	

;THIS ROUTINE WILL TAKE A FREQUENCY IN SUBSVAR3 AND 4 AND WILL LOAD
;IT INTO THE SOUND CHIP POINTED TO BY THE SLOT INDEX IN X.  IT JUST
;RETURNS IF THE REGISTERS ARE NOT SELECTED OR THE SOUND IS SUSPENDED.

SET_FREQUENCY:

	JSR	SELECTED	;SEE IF SUSPENDED OR NO REGS SELECTED
	BNE	SQ60

	JSR	MAKEBASE

	LDY	#2		;START WITH LOW REG LOAD
	LDA	SUBSVAR3
	STA	(NMI_PTR),Y
	INY
	LDA	SUBSVAR4	;THEN GET HIGH
	ORA	#8		;OR IN THE BIT TO USE DURATION REG
	STA	(NMI_PTR),Y
SQ60:	RTS

;THIS ROUTINE WILL INCREMENT THE CURRENT SOUND OFFSET POINTER IN THE
;SOUND SLOT SPECIFIED BY INDEX IN X.

INC_INDX:
	INC	SND_RAM+SOL,X	;DONE, MOVE INDEX ALONG
	BNE	IX5
	INC	SND_RAM+SOH,X
IX5:	RTS

;THIS SUB WILL RETURN NZ IF SOUND SLOT X IS SUSPENDED OR HAS NO VOICE
;SELECTED.

SELECTED:
	LDA	SND_RAM+SF,X	;GET BACK THE FLAG
	AND	#$60		;SEE IF SUSPENDED OR NO REGS SELECTED
	RTS

;THIS ROUTINE WILL TAKE A SLOT INDEX IN X (NOT A SLOT #) AND WILL USE
;THE INSTRUMENT SPECIFICATION TO INITIALIZE THAT REGISTER SET.  MAKE SURE
;THAT THE REGISTER SET SPECIFICATION IS VALID, NOT SUSPENDED, AND THAT
;THE INSTRUMENT IS VALID, THIS ROUTINE DOES NOT CHECK THAT.
;YOU MAY WANT TO CALL ENABLE_VOICE AFTER CALLING THIS ROUTINE.

;YOUR INDEX IN X IS SAVED.  SUBSVARs ARE ALL CHANGED.

INITSND:
	LDA	SND_RAM+SI,X	;GET INSTRUMENT
	ASL	A		;MAKE *2 POINTER FROM IT
	STA	SUBSVAR4	;SAVE IT HERE
	LDA	SND_RAM+SF,X	;GET BASE
	AND	#$1F
	STA	SUBSVAR1
	LDA	#$40
	STA	SUBSVAR2	;MAKE FULL POINTER TO IT IN MEMORY

 	LDY	SUBSVAR4
	LDA	INSTRUMENTS,Y	;GET REGISTER VALUE TO LOAD
	LDY	#0
	STA	(SUBSVAR1),Y	;PUT INTO CORRECT REGISTER
	LDY	SUBSVAR4
	INY			;GET NEXT REGISTER VALUE
	LDA	INSTRUMENTS,Y
	LDY	#1
	STA	(SUBSVAR1),Y	;PUT INTO NEXT REG
	RTS

;THIS ROUTINE WILL CONVERT A SOUND SLOT NUMBER IN A INTO AN INDEX IN X.  IT
;ALSO CHECKS FOR IN RANGE.  ON RETURN Z AND A=0 IF VALID.    

SNDINDX:
	CMP	#SNDSLOTS	;VALID VALUE?
	BCS	SX40		;SKIP IF NOT

	TAX
	LDY	#SND_WIDE
	JSR	MUL
	LDA	#0
	RTS

SX40:	LDA	#-1
	RTS

;THIS ROUTINE IS CALLED EACH NMI TO PROCESS THE CURRENT PALETTE.  IT
;MUST BE CALLED AHEAD OF OTHER ROUTINES THAT WRITE TO SCREEN IN ORDER
;TO GUARANTEE IT CAN PUT ITS DATA (40 MAX) INTO THE SCREEN BUFFER.

DOPAL:	LDA	NEW_PAL		;SEE IF NEED INIT OF NEW PAL
	AND	#1
	BEQ	DP100

;INITIALIZING A NEW BACKGROUND PALETTE.

	EOR	NEW_PAL
	STA	NEW_PAL		;RESET BIT OF NEED INIT OF BACKGROUND
	LDY	#0
	LDA	(BPAL_BASE),Y
	STA	BPAL_BLINK	;SET BLINK FOR BACKGROUND
	INY
	LDA	(BPAL_BASE),Y
	STA	BPAL_DEPTH	;SET DEPTH OF BLINK
	INY
	LDA	#1
	STA	BPAL_INDX	;SET BLINK INDEX TO NEXT FRAME CAUSE 0 BOOTS.
	LDA	(BPAL_BASE),Y
	STA	BPAL_FREQ	;SET FREQUENCY
	STA	BPAL_CNT	;AND SET TIMER COUNT
	
	CLC
	LDA	BPAL_BASE
	ADC	#3
	STA	BPAL_BASE
	LDA	BPAL_BASE+1
	ADC	#0
	STA	BPAL_BASE+1	;POINT BASE DIRECTLY TO DATA

	LDX	SCCNT		;GET SCREEN BUFFER COUNT
	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	#$3F
	STA	SCNBUF,X
	INX
	LDA	#$00
	STA	SCNBUF,X
	INX
	LDA	#16
	STA	SCNBUF,X		;QUE UP WRITE LOCATION AND COUNT
	INX
	STA	TMP_NMI1	;AND MAKE A LOOP COUNT
	LDY	#0
DP10:	LDA	(BPAL_BASE),Y
	INY
	STA	SCNBUF,X	
	INX
	DEC	TMP_NMI1
	BNE	DP10
	STX	SCCNT
	RTS

;INITIALIZING A NEW SPRITE PALETTE.

DP100: 	LDA	NEW_PAL
	BEQ	DP200
	LDA	#0
	STA	NEW_PAL		;RESET FLAG, BOTH ARE INITIALIZED NOW

	LDY	#0
	LDA	(SPAL_BASE),Y
	STA	SPAL_BLINK	;SET BLINK FOR BACKGROUND
	INY
	LDA	(SPAL_BASE),Y
	STA	SPAL_DEPTH	;SET DEPTH OF BLINK
	INY
	LDA	#1
	STA	SPAL_INDX	;WE BOOT WITH BLINK 0, SO NEXT IS 1
	LDA	(SPAL_BASE),Y
	STA	SPAL_FREQ	;SET FREQUENCY
	STA	SPAL_CNT	;AND SET TIMER COUNT
	
	CLC
	LDA	SPAL_BASE
	ADC	#3
	STA	SPAL_BASE
	LDA	SPAL_BASE+1
	ADC	#0
	STA	SPAL_BASE+1	;POINT BASE DIRECTLY TO DATA

	LDX	SCCNT		;GET SCREEN BUFFER COUNT
	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	#$3F
	STA	SCNBUF,X
	INX
	LDA	#$11		;SKIP PAST THE LOWEST REG WHICH OVERLAPS WITH
	STA	SCNBUF,X	;THE BACKGROUND COLOR AND WOULD MESS IT UP.
	INX
	LDA	#15
	STA	SCNBUF,X		;QUE UP WRITE LOCATION AND COUNT
	INX
	STA	TMP_NMI1	;AND MAKE A LOOP COUNT
	LDY	#1

DP110:	LDA	(SPAL_BASE),Y
	INY
	STA	SCNBUF,X	
	INX
	DEC	TMP_NMI1
	BNE	DP110
	STX	SCCNT
	RTS			;AND DONE INITIALIZING PALETTE

;NOT INITIALIZING.  SEE IF BACKGROUND PALETTE BLINKS.
		
DP200:	LDA	BPAL_BLINK
	BEQ	DP300
      	DEC	BPAL_CNT
	BNE	DP300		;IF IT BLINKS, TIME TO UPDATE PALETTE?
	LDA	BPAL_FREQ
	STA	BPAL_CNT	;IF SO, RELOAD COUNT

	LDA	BPAL_BLINK
	ASL	A
	ASL	A		;MAKE *4 NUMBER OF BYTES PER BLINK INFO
	STA	TMP_NMI1	;AND SAVE AS NUMBER OF BYTES TO WRITE OUT.
	TAX
	LDY	BPAL_INDX	;GET THE FRAME WE ARE DOING
	JSR	MUL		;MAKE OFFSET TO THE COLORS
	LDA	#16
	SEC
	SBC	TMP_NMI1	;MAKE POINTER TO FIRST BLINKING PALETTE
	STA	TMP_NMI2	;SAVE FOR LATER
	JSR	ADD_WORD 	;AND ADD DEPTH INTO THE BLINKING ARRAY
	STX	NMI_PTR
	STY	NMI_PTR+1
	LDA	BPAL_BASE
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	LDA	BPAL_BASE+1
	ADC	NMI_PTR+1
	STA	NMI_PTR+1	;ADD BASE TO THE LOCATION WE WANT

	LDX	SCCNT		;POINT WITHIN BUFFER AT WHICH TO STORE
	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	#$3F
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI2	;GET FIRST PAL REG TO UPDATE
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI1	;GET COUNT
	STA	SCNBUF,X
	INX

DP210:	LDA	(NMI_PTR),Y	;GET DATA
	STA	SCNBUF,X		;PUT IN BUFFER FOR UPDATE NEXT PASS
	INY
	INX
	DEC	TMP_NMI1	;DO THE NUMBER WE CALCULATED
	BNE	DP210
	STX	SCCNT		;UPDATE COUNT FOR NEXT PASS
	
	INC	BPAL_INDX	;UPDATE FOR NEXT TIME
	LDA	BPAL_INDX
	CMP	BPAL_DEPTH 	;SEE IF WENT TOO HIGH
	BNE	DP300
	LDA	#0
	STA	BPAL_INDX	;IF TOO HIGH, GO BACK TO 0

;SEE IF SPRITE PALETTE BLINKS

DP300: 	LDA	SPAL_BLINK
	BEQ	DP400
      	DEC	SPAL_CNT
	BNE	DP400		;IF IT BLINKS, TIME TO UPDATE PALETTE?
	LDA	SPAL_FREQ
	STA	SPAL_CNT

	LDA	SPAL_BLINK
	ASL	A
	ASL	A		;MAKE *4 NUMBER OF BYTES PER BLINK INFO
	STA	TMP_NMI1	;AND SAVE AS NUMBER OF BYTES TO WRITE OUT.
	TAX
	LDY	SPAL_INDX	;GET THE FRAME WE ARE DOING
	JSR	MUL		;MAKE OFFSET TO THE COLORS
	LDA	#16
	SEC
	SBC	TMP_NMI1	;MAKE POINTER TO FIRST BLINKING PALETTE
	STA	TMP_NMI2	;SAVE FOR LATER
	JSR	ADD_WORD	;AND ADD DEPTH INTO THE BLINKING ARRAY
	STX	NMI_PTR
	STY	NMI_PTR+1
	LDA	SPAL_BASE
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	LDA	SPAL_BASE+1
	ADC	NMI_PTR+1
	STA	NMI_PTR+1	;ADD BASE TO THE LOCATION WE WANT


	LDX	SCCNT		;POINT WITHIN BUFFER AT WHICH TO STORE
	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	#$3F
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI2	;GET FIRST PAL REG TO UPDATE
	CLC
	ADC	#$10		;SPRITE REGS ARE HERE
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI1	;GET COUNT
	STA	SCNBUF,X
	INX

	LDY	#0		;SET RETRIEVE INDEX.  
DP310:	LDA	(NMI_PTR),Y	;GET DATA
	STA	SCNBUF,X		;PUT IN BUFFER FOR UPDATE NEXT PASS
	INY
	INX
	DEC	TMP_NMI1	;DO THE NUMBER WE CALCULATED
	BNE	DP310
	STX	SCCNT		;UPDATE COUNT FOR NEXT PASS
	
	INC	SPAL_INDX	;UPDATE FOR NEXT TIME
	LDA	SPAL_INDX
	CMP	SPAL_DEPTH 	;SEE IF WENT TOO HIGH
	BNE	DP400
	LDA	#0
	STA	SPAL_INDX	;IF TOO HIGH, GO BACK TO 0

DP400:	RTS

;THIS ROUTINE WILL DO A SCROLL OF THE BACKGROUND THAT WAS STARTED WITH
;SCRLX OR SCRLY.  IT SHOULD BE CALLED EVERY NMI AND IT WILL CHECK AND MAINTAIN
;ITS OWN FLAGS.

;IMPORTANT TECHNICAL NOTE:  BECAUSE THIS ROUTINE ONLY BUILDS DATA
;TO WRITE TO SCREEN AND DOES NOT ACTUALLY WRITE IT, IT CANNOT UPDATE
;THE SCREEN SCROLL REGISTERS UNTIL THE DATA HAS BEEN WRITTEN OUT.
;WHEN A NEW ROW OR COLUMN IS ADDED, THERE IS A SAFE (LOWEST POSSIBLE
;VALUE) POSITION WITHIN THE NEW ROW.  THIS ROUTINE MOVES THERE BUT
;DOES NOT UPDATE THE SCROLL REGISTER.  THEN THE NEXT PASS WILL MOVE
;TO THE CORRECT LOCATION AND UPDATE THE SCROLL REGISTER TOO.  ONE
;SIDE EFFECT IS THAT IF THE USER MOVES A LOT USING THE SCROLL FUNCTION
;INSTEAD OF INIT AS RECOMMENDED, THE SCREEN WILL HOLD UNTIL ALL SCROLL
;DATA IS UPDATED.

DOSCRL:	LDA	MOVEBACK
	BNE	DOS10
DOS5:	RTS			;IF FLAG NOT SET, NOTHING TO DO.

DOS10:	JSR	FIXSCROLL	;FIX THE USER'S SCROLL VARIABLES

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		
	LDA	DIDX
	BNE	DOS20
	LDA	#-1
	STA	DIDX
	JSR	DOXSCROLL
	JSR	DOYSCROLL
	RTS

DOS20:	LDA	#0
	STA	DIDX
	JSR	DOYSCROLL
	.endif ;' )
	JSR	DOXSCROLL
	RTS

;THIS SUB WILL CHECK IF WE NEED AN X SCROLL.  IF WE ARE ON PIXEL 0, 
;A MOVEMENT EITHER DIRECTION NEEDS A NEW COLUMN.  OTHERWISE, THE 
;DIFFERENCE MUST BE 8 OR MORE PIXELS.

DOXSCROLL:
	LDA	MOVEBACK
	AND	#1		;X SCROLL NEEDED?
	BEQ	DOS55		;IF NOT, SKIP TO Y LOGIC
	
	LDA	#8
	STA	SCRLDIF		;SET FOR LOCATION CORRECTION OF 8.

 	LDA	CURX 		;GET CURRENT POSITION
	SEC
	SBC	XBACK		;MAKE DIFFERENCE TO NEW DIRECTION
	TAY
	LDA	CURX+1
	SBC	XBACK+1
	BCC	DOS30

;WE HAVE TO LOWER OUR X LOCATION (SCROLL TO THE LEFT).  

DOS25:	BNE	DOS60		;IF HIGH DIFFERENCE NON-ZERO, IT IS A SCROLL
	TYA			;IF TOP BYTE 0, SEE IF LOW BYTE IS ZERO TOO
	BEQ	DOS50		;IF NO SCROLL NEEDED, RESET X SCROLL BIT
	CMP	#8		;SEE IF DIF 8 OR GREATER 
	BCS	DOS60		;ALWAYS SCROLL IF SO
	STA	SCRLDIF

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	XBACK
	AND	#7
	STA	SUBSVAR1
	LDA	CURX
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DOS40
	JMP	DOS60		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;WE HAVE TO INCREASE OUR X LOCATION (SCROLL TO THE RIGHT).

DOS30:	CMP	#$FF		;SEE IF HIGH BYTE WAS MORE THAN -1
	BEQ	DOS35
	JMP	DOS100		;IF SO, DIFFERENCE WAS MORE THAN 8

DOS35:	TYA			;GET BACK LOW BYTE OF DIFFERENCE
	CMP	#$F9		;SEE IF MORE THAN 8	
	BCC	DOS39		;IF SO, ALWAYS NEED SCROLL
	EOR	#$FF
	ADC	#0		;MAKE THE ACTUAL DIFFERENCE IF <8
	STA	SCRLDIF		;SET AS SCROLL CORRECTION AMOUNT

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	CURX
	AND	#7
	STA	SUBSVAR1
	LDA	XBACK
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DOS40
DOS39:	JMP	DOS100		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;X DOES NOT NEED ANY NEW DATA COLUMNS.  JUST SET OUR SCROLL AS THE SAME

DOS40:	LDA	XBACK
	STA	CURX
	LDA	XBACK+1
	STA	CURX+1

;SCROLL CORRECTED WITHOUT ADDING NEW COLUMNS.  RESET THE NEED X SCROLL BIT.

DOS50:	LDA	MOVEBACK
	AND	#$FE		;TURN OFF X NEEDS SCROLLING BIT
	STA	MOVEBACK
DOS55:	RTS

;ITS A NEGATIVE SCROLL.  WE NEED TO ADD A COL TO THE LEFT OF THE SCREEN.

DOS60: 	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#80
	BCS	DOS70
	RTS		;IF NOT ENOUGH TO SCROLL, FORGET IT THIS PASS

DOS70:	LDX	CURX
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE CURRENT STARTING COL
	TXA
	SEC
	SBC	#1
	STA	FETCHCOL
	TYA
	SBC	#0
	STA	FETCHCOL+1	;MAKE FETCHCOL = 1 TO THE LEFT

	LDA	CURX
	SEC
	SBC	SCRLDIF
	STA	CURX
	LDA	CURX+1
	SBC	#0
	STA	CURX+1		;MOVE LEFT AMOUNT WE MADE EARLIER

	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE ROW TO START FROM
	STX	FETCHROW	;SAVE ROW HERE
	JSR	FINDCOL		;FIND THE COLUMN WITHIN THE BACKGROUND
	JSR	BUILD_COL	;MAKE DATA FOR THIS COLUMN
	JMP	DOS150		;AND DONE FOR NOW.  NEXT NMI WILL FIX PIXELS.

;ITS A POSITIVE SCROLL.  WE NEED TO ADD A COL TO THE RIGHT OF THE SCREEN.
;WE'LL ADD THAT BEFORE WE MOVE THE SCROLL BECAUSE THE NUMBER OF
;CHARS ON SCREEN IS USUALLY 33 SINCE WE GET PART OF THE FIRST AND LAST.

DOS100:	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#80
	BCS	DOS105
	RTS			;IF NOT ENOUGH TO SCROLL, FORGET IT THIS PASS

DOS105:	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE CURRENT DATA ROW
	STX	FETCHROW

	LDX	CURX		;GET CURRENT LOCATION
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE INTO COLUMN #
	TXA	
	CLC
	ADC	#33		;POINT TO NEW COL TO WRITE OUT
	STA	FETCHCOL
	TYA
	ADC	#0
	STA	FETCHCOL+1	;MAKE FETCHCOL=1 TO RIGHT OF SCREEN

	LDA	FETCHCOL
	SEC
	SBC	WORLD_WIDTH
	LDA	FETCHCOL+1
	SBC	WORLD_WIDTH+1	;SEE IF PAST RIGHT
	BCS	DOS107
	
	JSR	FINDCOL
	JSR	BUILD_COL	;MAKE DATA FOR THIS COL

DOS107:	LDA	CURX		;GET CURRENT LOCATION
	CLC
	ADC	SCRLDIF
	STA	CURX
	LDA	CURX+1
	ADC	#0
	STA	CURX+1

;WE DID HAVE TO DO A NEW COLUMN.  BUT THE DATA ISN'T WRITTEN OUT YET
;SO WE CAN'T UPDATE THE SCREEN SCROLL VALUES.  LEAVE THE X SCROLL BIT
;SET AND NEXT PASS WE WILL UPDATE THE SCROLL REGISTER.  NO NEED TO TRY
;TO DO Y NOW BECAUSE THE BUFFER IS FULL.

DOS150:	RTS		


.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;SEE IF WE NEED A Y SCROLL.  IF WE ARE ON PIXEL 0, A MOVEMENT EITHER
;DIRECTION NEEDS A NEW ROW.  OTHERWISE, THE DIFFERENCE MUST BE 8 OR 
;MORE PIXELS.

DOYSCROLL:

	LDA	MOVEBACK
	AND	#2		;Y SCROLL NEEDED?
	BEQ	DYS55		;IF NOT, DONE

	LDA	#8
	STA	SCRLDIF		;SET FOR LOCATION CORRECTION OF 8.

 	LDA	CURY 		;GET CURRENT POSITION
	SEC
	SBC	YBACK		;MAKE DIFFERENCE TO NEW DIRECTION
	TAY
	LDA	CURY+1
	SBC	YBACK+1
	BCC	DYS30

;WE HAVE TO LOWER OUR Y LOCATION (SCROLL UP).  

DYS25:	BNE	DYS60		;IF HIGH DIFFERENCE NON-ZERO, IT IS A SCROLL
	TYA			;IF TOP BYTE 0, SEE IF LOW BYTE IS ZERO TOO
	BEQ	DYS50		;IF NO SCROLL NEEDED, RESET Y SCROLL BIT
	CMP	#8		;SEE IF DIF 8 OR GREATER 
	BCS	DYS60		;ALWAYS SCROLL IF SO
	STA	SCRLDIF

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	YBACK
	AND	#7
	STA	SUBSVAR1
	LDA	CURY
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DYS40
	JMP	DYS60		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;WE HAVE TO INCREASE OUR Y LOCATION (SCROLL TO THE RIGHT).

DYS30:	CMP	#255		;SEE IF HIGH BYTE WAS MORE THAN -1
	BEQ	DYS35
	JMP	DYS100		;IF SO, DIFFERENCE WAS MORE THAN 8

DYS35:	TYA			;GET BACK LOW BYTE OF DIFFERENCE
	CMP	#249		;SEE IF MORE THAN 8	
	BCC	DYS39		;IF SO, ALWAYS NEED SCROLL
	EOR	#255
	ADC	#0		;MAKE THE ACTUAL DIFFERENCE IF <8
	STA	SCRLDIF		;SET AS SCROLL CORRECTION AMOUNT

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	CURY
	AND	#7
	STA	SUBSVAR1
	LDA	YBACK
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DYS40
DYS39:	JMP	DYS100		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;Y DOES NOT NEED ANY NEW DATA COLUMNS.  JUST SET OUR SCROLL AS THE SAME

DYS40:	LDA	YBACK
	STA	CURY
	LDA	YBACK+1
	STA	CURY+1

;SCROLL CORRECTED WITHOUT ADDING NEW COLUMNS.  RESET THE NEED Y SCROLL BIT.

DYS50:	LDA	MOVEBACK
	AND	#253		;TURN OFF Y NEEDS SCROLLING BIT
	STA	MOVEBACK
DYS55:	RTS			;DONE

;ITS A NEGATIVE SCROLL.  WE NEED TO ADD A ROW TO THE TOP OF THE SCREEN.

DYS60: 	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#60
	BCS	DYS70
	RTS		;IF NOT ENOUGH TO SCROLL, FORGET IT THIS PASS

DYS70:	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE CURRENT STARTING COL
	TXA
	SEC
	SBC	#1
	STA	FETCHROW

	LDA	CURY
	SEC
	SBC	SCRLDIF
	STA	CURY
	LDA	CURY+1
	SBC	#0
	STA	CURY+1		;MOVE LEFT AMOUNT WE MADE EARLIER

	LDX	CURX
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE ROW TO START FROM
	STX	FETCHCOL	;SAVE ROW HERE
	STY	FETCHCOL+1
	JSR	FINDCOL		;FIND THE COLUMN WITHIN THE BACKGROUND
	JSR	BUILD_ROW	;MAKE DATA FOR THIS ROW
	JMP	DYS150		;AND DONE FOR NOW.  NEXT NMI WILL FIX PIXELS.

;ITS A POSITIVE SCROLL.  WE NEED TO ADD A ROW TO THE BOTTOM OF THE SCREEN.

DYS100:	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#60
	BCS	DYS105
	RTS			;IF NOT ENOUGH TO SCROLL, FORGET IT THIS PASS

DYS105:	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE CURRENT DATA ROW
	TXA
	CLC
	ADC	#30		;ADD 1 COLUMN TO BOTTOM
	STA	FETCHROW

	LDX	CURX
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE ROW TO START FROM
	STX	FETCHCOL	;SAVE ROW HERE
	STY	FETCHCOL+1
	JSR	FINDCOL		;FIND THE COLUMN WITHIN THE BACKGROUND
	JSR	BUILD_ROW	;MAKE DATA FOR THIS ROW

	LDA	CURY		;GET CURRENT LOCATION
	CLC
	ADC	SCRLDIF
	STA	CURY
	LDA	CURY+1
	ADC	#0
	STA	CURY+1

;WE DID HAVE TO DO A NEW ROW.  BUT THE DATA ISNT WRITTEN OUT YET
;SO WE CANT UPDATE THE SCREEN SCROLL VALUES.  LEAVE THE Y SCROLL BIT
;SET AND NEXT PASS WE WILL UPDATE THE SCROLL REGISTER.  

DYS150:	RTS		

	.endif ;' )

;THIS ROUTINE WILL TAKE THE CURRENT WINDOW POINTER (CURX AND CURY) AND
;UPDATE THE SCROLL REGISTERS USED BY NMI.

MAKE_SCROLL:
	LDA	BACKVALID	;MAKE SURE THERE IS A BACKGROUND TO USE
	BEQ	MKS20
	LDA	REG2000
	AND	#$FE		;REMOVE OLD PAGE SELECT BIT
	STA	REG2000
	LDA	CURX+1
	AND	#1		;MAKE NEW ONE FROM BIT 9 OF X SCROLL
	ORA	REG2000
	STA	REG2000			
	LDA	CURX
	STA	XSCROLL		;AND USE THE ACTUAL SCROLL AS THE X SCROLL

	LDA	CURY
	CLC
	ADC	SHAKEAMT
	TAX
	LDA	CURY+1
	ADC	#0
	TAY
	LDA	#240
	JSR	DIVIDE		;FIND OUT WHERE TO PUT THE SCROLL MOD 1 SCREEN
	STY	YSCROLL
MKS20:	RTS			

;THIS ROUTINE WILL DISPLAY A GIVEN ROW IN THE VIRTUAL (BIG) BACKGROUND
;CREATED FROM BLOCKS.  IT IS NOT USED FOR STRIP MODE.  
;ON ENTRY, FETCHCOL (WORD) HAS THE DESIRED STARTING COLUMN ON THE ROW.
;FETCHROW (BYTE) HAS THE ROW TO DISPLAY.  (CHANGED ON RETURN)

;THIS ROUTINE DOES NOT RANGE CHECK YOUR VALUES SO MAKE SURE THEY ARE OK.

;SCNBUF MUST HAVE 60 BYTES OF AVAILABLE ROOM IN THE SCREEN BUFFER.
;THIS ROUTINE WILL NOT CHECK THIS FOR YOU.

BUILD_ROW:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

	LDA	WORLDSPOT
	STA	TMP_NMI9	
	LDA	WORLDSPOT+1
	STA	TMP_NMIA	;NEED COPY OF STARTING BACKGRND FOR PAL BYTES

.ifdef INDIRECT;IFDEF( `INDIRECT', `
 	LDA	#1		;SKIP 1 ONLY IF 1 BYTE BLOCK FORMAT
.endif;	', `
.ifndef INDIRECT
	LDA	#2		;IF WORD BLOCK MODE, 2 BYTES PER BLOCK SPEC
.endif ;' )
	STA	TMP_NMI3
	LDA	#0
	STA	TMP_NMI4	;MAKE 1 WORD CORRECTION TO NEXT BLOCK COLUMN

;NOW WORLDSPOT POINTS TO THE BLOCK WE SHOULD START FETCHING FROM.  
;TMP_NMI9 AND A ALSO HAVE THAT ADDRESS FOR WHEN WE FETCH PALETTE INFO.
;TMP_NMI3 AND 4 HAVE THE AMOUNT TO ADD TO SKIP TO THE NEXT BLOCK.
;MAKE THE VIDEO RAM ADDRESS.

	LDA	FETCHCOL
	AND	#31		;MAKE SCREEN COLUMN WITHIN THE VIDEO PAGE
	STA	TMP_NMID	;SAVE TO MAKE AMOUNT WE CAN WRITE TO END

	LDX	#32		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	LDA	#32
	AND	FETCHCOL	;TEST TO GET PAGE NUMBER 
	BEQ	BR20
	LDX	#36		;IF ODD BIT ABOVE WIDTH, PAGE 2

BR20:	STX	TMP_NMI8	;SAVE STARTING PAGE
	LDX	FETCHROW
	LDY	#0
	LDA	#30
	JSR	DIVIDE		;MAKE REMAINDER FROM MOD 30 (SCREEN HEIGHT)
	STX	TMP_NMIB	;SAVE PAGE WRAP WE ARE IN FOR SHIFT COUNT.
	STY	SUBSVAR6	;SAVE REMAINDER ROW HERE FOR PALETTE FIGURING
	LDX	#32
	JSR	MUL		;MAKE ROW WITHIN SCREEN BUFFER
	STX	TMP_NMI7	;SAVE ROW 0 LOCATION FOR NEXT PAGE WRITE
	TXA
	CLC
	ADC	TMP_NMID	;ADD TO GET COLUMN IN THIS VIDEO ROW AND PAGE
	STA	TMP_NMI5
	TYA
	ADC	TMP_NMI8
	STA	TMP_NMI6	
	TYA
	CLC
	ADC	TMP_NMI8
	EOR	#4		;MAKE NEXT PAGE ADDRESS AT COLUMN 0
	STA	TMP_NMI8
.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;NOW TMP_NMI5 AND 6 POINT TO THE SCREEN POSITION TO WRITE DATA AT IN THE
;SCREEN BUFFER.  TMP_NMI7 AND 8 POINT TO THE CORRESPONDING ROW AT COLUMN 0
;IN THE NEXT VIDEO PAGE.  TMP_NMIB HAS THE VIDEO PAGE WE ARE IN VERTICALLY
;SO WE CAN CALCULATE THE SHIFT WE NEED WHEN WE WRITE PALETTE DATA.
;SUBSVAR6 HAS THE ROW WITHIN THE SCREEN BUFFER WE ARE ON.  TMP_NMID HAS
;THE COLUMN WE ARE ON.

;TMP_NMID WILL BE MADE INTO AMOUNT TO WRITE IN FIRST HALF OF SCREEN
;BUFFER ADDRESSING, TMP_NMIE INTO AMOUNT FOR SECOND HALF.

	LDA	WORLD_WIDTH	;WE ALWAYS WRITE OUT 33
	SEC
	SBC	FETCHCOL	;MAKE DISTANCE TO RIGHT OF BACKGROUND
	STA	TMP_NMIE
	LDA	WORLD_WIDTH+1
	SBC	FETCHCOL+1
	BEQ	BR21
     	LDA	#-1
	STA	TMP_NMIE	;IF MORE THAN 256, USE MAX
BR21:	LDA	TMP_NMIE
	CMP	#33		;33 IS ALL WE WANT
	BCC	BR22
	LDA	#33		;IF MORE THAN THAT, JUST WRITE 33
BR22:	STA	TMP_NMIE	;SET HERE AS MAXIMUM WE COULD WRITE OUT

	LDA	#32
	SEC
	SBC	TMP_NMID	;MAKE DISTANCE TO RIGHT OF THIS VIDEO PAGE
	CMP	TMP_NMIE	;MAKE SURE THERES ENOUGH TO FILL TO BOTTOM
	BCC	BR24
     	LDA	TMP_NMIE	;IF NOT, USE HOW MUCH IS LEFT.
BR24:	STA	TMP_NMID	;SAVE AMOUNT TO BOTTOM OF THIS VIDEO PAGE
	LDA	TMP_NMIE	;GET TOTAL WE ARE WRITING
	SEC
	SBC	TMP_NMID	;MAKE INTO AMOUNT TO WRITE IN SECOND PAGE
	STA	TMP_NMIE	;AND SAVE HERE FOR LOOPING.

;SET UP INITIAL ADDRESSING TO START THE LOOP.

	JSR	ROWBACK		;MAKE (NMI_PTR) TO THE DATA AT ROW WE WANT
	LDA	FETCHCOL
	AND	#7		;GET COL WE ARE ON IN THIS BLOCK
	STA	TMP_NMIC	;SAVE A COPY
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	BCC	BR28
	INC	NMI_PTR+1	;FOR FIRST ADDRESSING, START AT ODD ROW
BR28:	LDA	#8
	SEC
	SBC	TMP_NMIC	;MAKE AMOUNT LEFT IN THIS BACKGROUND.
	STA	TMP_NMIC	;PUT WHERE LOOP WANTS IT TO BE

;ADDRESS AND WRITE OUT THE AMOUNT.

	LDX	SCCNT		;GET THE INDEX
BR30:	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI6
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI5
	STA	SCNBUF,X
	INX

	LDA	TMP_NMID	
	STA	SCNBUF,X	;STORE THE COUNT TO WRITE FOR THE FIRST HALF
	INX

;WRITE DATA FROM THE BACKGROUND LIST FOR LENGTH TMP_NMID.  WHEN DONE,
;IF TMP_NMIE HAS NON-ZERO WE READDRESS USING TMP_NMI3 AND 4 AND
;START OVER.  TMP_NMIC HAS THE AMOUNT LEFT IN THE CURRENTLY SELECTED
;BACKGROUND (USING ROWBACK) THAT WE HAVE IN THIS COLUMN.

BR32: 	LDA	TMP_NMIC	;GET AMOUNT LEFT IN THIS BACKGROUND
	BNE	BR34		;IF THERE IS SOME, USE IT
	JSR	NEXTBACK	;SKIP TO THE NEXT BACKGROUND IN THE BLOCK
  	JSR	ROWBACK		;SET UP FOR NEW BACKGROUND
	LDA	#8
	STA	TMP_NMIC	;RESET AMOUNT WE CAN WRITE FROM THERE

BR34:	CMP	TMP_NMID	;DO WE NEED THAT MUCH?
	BCC	BR35
	LDA	TMP_NMID	;IF NOT, USE AS MUCH AS WE NEED
	BEQ	BR50		;IF NONE LEFT, DONE WITH THIS WRITE
BR35:	STA	TMP_NMI1	;SET UP TO FETCH THIS DATA
	LDA	TMP_NMIC
	SEC	
	SBC	TMP_NMI1	;MAKE AMOUNT LEFT IN THIS BACKGROUND
	STA	TMP_NMIC
	LDA	TMP_NMID
	SEC
	SBC	TMP_NMI1	;AND AMOUNT LEFT TO WRITE OUT WITH THIS ADDRESS
	STA	TMP_NMID
 
				;USES TMP_NMI1 = LENGTH
	JSR	LOADROW		;AND (NMI_PTR) = DATA.  X=PLACE IN SCNBUF.
	JMP	BR32		;KEEP WRITING TILL TMP_NMID IS DONE

;DONE WRITING OUT TMP_NMID. SEE IF MORE TO WRITE WITH NEW ADDRESS IN
;TMP_NMIE.

BR50:	LDA	TMP_NMIE
	BEQ	BR100
	STA	TMP_NMID
	LDA	#0
	STA	TMP_NMIE	;ZERO SECOND WRITE FOR NEXT PASS

	LDA	TMP_NMI7
	STA	TMP_NMI5
	LDA	TMP_NMI8
	STA	TMP_NMI6
	JMP	BR30		;GO SHARE ADDRESS AND LENGTH CODE

.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;DONE WITH DATA.  WRITE PALETTE INFO.  WE STILL HAVE:
;TMP_NMI9 AND A HAVE ORIGINAL STARTING BACKGROUND PTR
;SUBSVAR6 HAS ROW WITHIN THIS SCREEN BUFFER
;TMP_NMIB HAS VIDEO PAGE WE ARE ON VERTICALLY.

BR100:	STX	SCCNT		;SAVE THE COUNT WE WROTE

;WE DONT WRITE PALETTE DATA UNTIL MOST OF THAT PALETTE BYTE IS VISIBLE
;ON OUR SCREEN.  DECIDE NOW IF WE ARE GOING TO.  THE RULES ARE:
;DO IT IF IN TOP HALF OF PALETTE BYTE.

	LDA	SUBSVAR6	;GET ROW WITHIN SCREEN BUFFER
	AND	#2		;THIS IS THE DESTINGUISHING VALUE
	BEQ	BR101
	JMP	BR400	

;NOW SET UP THE BACKGROUND TO POINT TO WHEN WE GET THE INFO.  WE NEED TO
;MOVE UP A BACKGROUND IF WE ARE IN AN ODD PAGE.  THATS BECAUSE WE NEED
;TO SHIFT THE PALETTE DATA.  WE SHIFT A NIBBLE OUT. THUS WE NEED TO 
;BACK UP 2 ROWS IN THE PALETTE DATA.  IF WE ARE IN THE FIRST 2 ROWS THAT
;MEANS NEED TO MOVE UP IN THE BACKGROUND LIST

;PALETTE BYTE (FIRST 2 CHARS OUT OF THE 4 HIGH) WE WOULD SHIFT OUR DATA
;OUT AND THUS WE NEED TO MOVE DOWN.  WHEN WE SHIFT NEW DATA IN WE WILL
;MOVE AHEAD TO THE CORRECT LOCATION AND GET THE NEEDED DATA.

BR101:	LDA	#0
	STA	WORLDSPOT
	STA	WORLDSPOT+1	;ASSUME NO BACKUP CORRECTION NEEDED

	LDA	TMP_NMIB	;GET BACK PAGE WE ARE IN
	AND	#1
	BEQ	BR110

	LDA	FETCHROW
	AND	#7		;GET WHAT ROW WITHIN THE 8 HIGH BACKGROUND
	CMP	#2
	BCS	BR105		

 	LDA	BLOCK_WIDTH	;IF ROW 0 OR 1, WE NEED TO BACK UP A BACKGRND
	STA	WORLDSPOT

BR105:	LDA	FETCHROW
	SEC
	SBC	#2
	STA	FETCHROW	;MOVE UP 2 ROWS SO ROWPAL CAN GET THE DATA

;IFDEF( `INDIRECT', `
			;NO CORRECTION IF 1 BYTE TABLE FORMAT
.ifndef INDIRECT;	', `
	ASL	WORLDSPOT
	ROL	WORLDSPOT+1	;MAKE 1 WORD CORRECTION TO NEXT BLOCK ROW
.endif ;' )

BR110:	LDA	TMP_NMI9
	SEC
	SBC	WORLDSPOT
	STA	WORLDSPOT
	LDA	TMP_NMIA
	SBC	WORLDSPOT+1
	STA	WORLDSPOT+1	;POINT TO NEXT BLOCK ROW IF NEEDED.

;NOW WORLDSPOT POINTS TO THE BLOCK WE SHOULD START FETCHING FROM.  
;TMP_NMI9 AND A ALSO HAVE THAT ADDRESS FOR WHEN WE NEED TO SHIFT DOWN DATA.
;TMP_NMI3 AND 4 HAVE THE AMOUNT TO ADD TO SKIP TO THE NEXT BLOCK.
;MAKE THE VIDEO RAM ADDRESS.

	LDX	#35		;ASSUME PAGE AT 23C0H STARTS THE COLUMN
	LDA	#32
	AND	FETCHCOL	;TEST TO GET PAGE NUMBER 
	BEQ	BR120

	LDX	#39		;IF ODD BIT ABOVE WIDTH, PAGE 2 AT 27C0H

BR120:	STX	TMP_NMI8	;SAVE STARTING PAGE

	LDA	SUBSVAR6	;GET REMAINDER WITHIN THIS SCREEN BUFFER
	AND	#252		;REMOVE LOW 2 BITS TO MAKE EVERY 4 COUNT
	ASL	A		;AND MULTIPLY BY 2 CAUSE 8 PER ROW IN PAL BUF
	CLC
	ADC	#192		;ADD C0H  TO GET THIS ROWS BASE
	STA	TMP_NMI7	;SAVE ROW 0 LOCATION IN BUFFER.

	LDA	FETCHCOL	;GET COLUMN WE ARE ON
	AND	#31		;IN THIS BUFFER
	LSR	A
	LSR	A		;MAKE PALETTE BYTE WE ARE ON
	CLC
	ADC	TMP_NMI7	;ADD TO GET COLUMN IN THIS PALETTE VIDEO PAGE
	STA	TMP_NMI5
	LDA	TMP_NMI8
	STA	TMP_NMI6	;MAKE 6 AND 5 BE ADDRESS IN FIRST PAGE

	LDA	TMP_NMI8
	EOR	#4		;MAKE NEXT PAGE ADDRESS AT COLUMN 0
	STA	TMP_NMI8	;SO 7 AND 8 POINT TO COLUMN 0 OF NEXT PAGE
	.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;NOW TMP_NMI5 AND 6 POINT TO THE SCREEN POSITION TO WRITE DATA AT IN THE
;SCREEN BUFFER.  TMP_NMI7 AND 8 POINT TO THE CORRESPONDING PAL ROW AT COLUMN 0
;IN THE NEXT VIDEO PAGE.  TMP_NMIB HAS THE VIDEO PAGE WE ARE IN VERTICALLY
;SO WE CAN CALCULATE THE SHIFT WE NEED WHEN WE WRITE PALETTE DATA.

;TMP_NMID WILL BE MADE INTO AMOUNT TO WRITE IN FIRST HALF OF SCREEN
;BUFFER ADDRESSING, TMP_NMIE INTO AMOUNT FOR SECOND HALF.

	LDA	FETCHCOL
	AND	#31
	LSR	A
	LSR	A		;MAKE PALETTE BYTE IN BUFFER
	JSR	NEGATE
	CLC
	ADC	#8		;MAKE DISTANCE TO END
	STA	TMP_NMID	;SET FIRST WRITE AMOUNT

	LDA	#9		;IF NOT ON LAST COLUMN WE ALWAYS WRITE 9
	STA	TMP_NMIE
	LDA	END_COL
	SEC
	SBC	FETCHCOL	
	BNE	BR121
      	LDA	END_COL+1
	SBC	FETCHCOL+1
	BNE	BR121
	DEC	TMP_NMIE	;IF AT EXACT END, WRITE OUT 8 ONLY.

BR121:	LDA	TMP_NMIE
	SEC
	SBC	TMP_NMID	;MAKE AMOUNT FOR SECOND PAGE WRITE
	STA	TMP_NMIE

;SET UP INITIAL ADDRESSING TO START THE LOOP.

	JSR	ROWPAL		;MAKE (NMI_PTR) TO THE DATA AT ROW WE WANT

	LDA	#2		;ASSUME 2 LEFT IN THIS BACKGROUND
	STA	TMP_NMIC
	LDA	FETCHCOL
	AND	#4		;SEE IF WE ARE IN THE SECOND PALETTE BYTE
	BEQ	BR128
	DEC	TMP_NMIC	;IF SO, ONLY 1 LEFT IN THIS BACK
	INC	NMI_PTR
	BNE	BR128
	INC	NMI_PTR+1	;AND WE NEED SECOND PALETTE BYTE

;ADDRESS AND WRITE OUT THE AMOUNT.

BR128:	LDX	SCCNT		;GET THE INDEX

BR130:	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI6
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI5
	STA	SCNBUF,X
	INX

	LDA	TMP_NMID	
	STA	SCNBUF,X	;STORE THE COUNT TO WRITE FOR THE FIRST HALF
	INX

	.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;WRITE DATA FROM THE BACKGROUND LIST FOR LENGTH TMP_NMID.  WHEN DONE,
;IF TMP_NMIE HAS NON-ZERO WE READDRESS USING TMP_NMI3 AND 4 AND
;START OVER.  TMP_NMIC HAS THE AMOUNT LEFT IN THE CURRENTLY SELECTED
;BACKGROUND (USING ROWBACK) THAT WE HAVE IN THIS COLUMN.

BR132: 	LDA	TMP_NMIC	;GET AMOUNT LEFT IN THIS BACKGROUND
	BNE	BR134		;IF THERE IS SOME, USE IT
	JSR	NEXTBACK	;SKIP TO THE NEXT BACKGROUND IN THE BLOCK
  	JSR	ROWPAL		;SET UP FOR NEW BACKGROUND
	LDA	#2
	STA	TMP_NMIC	;RESET AMOUNT WE CAN WRITE FROM THERE

BR134:	CMP	TMP_NMID	;DO WE NEED THAT MUCH?
	BCC	BR135
	LDA	TMP_NMID	;IF NOT, USE AS MUCH AS WE NEED
	BEQ	BR150		;IF NONE LEFT, DONE WITH THIS WRITE
BR135:	STA	TMP_NMI1	;SET UP TO FETCH THIS DATA
	LDA	TMP_NMIC
	SEC	
	SBC	TMP_NMI1	;MAKE AMOUNT LEFT IN THIS BACKGROUND
	STA	TMP_NMIC
	LDA	TMP_NMID
	SEC
	SBC	TMP_NMI1	;AND AMOUNT LEFT TO WRITE OUT WITH THIS ADDRESS
	STA	TMP_NMID
 
				;USES TMP_NMI1 = LENGTH
	JSR	LOADROW		;AND (NMI_PTR) = DATA.  X=PLACE IN SCNBUF.
	JMP	BR132		;KEEP WRITING TILL TMP_NMID IS DONE

;DONE WRITING OUT TMP_NMID. SEE IF MORE TO WRITE WITH NEW ADDRESS IN
;TMP_NMIE.

BR150:	LDA	TMP_NMIE
	BEQ	BR200
	STA	TMP_NMID
	LDA	#0
	STA	TMP_NMIE	;ZERO SECOND WRITE FOR NEXT PASS

	LDA	TMP_NMI7
	STA	TMP_NMI5
	LDA	TMP_NMI8
	STA	TMP_NMI6
	JMP	BR130		;GO SHARE ADDRESS AND LENGTH CODE

;NOW WE MUST SEE IF THE DATA NEEDED TO BE SHIFTED UP.  IF SO, WE HAVE
;TO START OVER REPEATING THE PROCESS BUT UP 4 DOWN IN THE BACKGROUND.
;THEN WE HAVE TO SHIFT THE BYTES IN INSTEAD OF STORE THEM.  THIS IS NEEDED
;ONLY WHEN WE ARE IN AN ODD NUMBER VIDEO PAGE VERTICALLY.

BR200:	LDA	TMP_NMIB	;GET BACK PAGE WE ARE IN
	AND	#1
	BNE	BR210
	JMP	BR400		;IF EVEN PAGE, DATA IS CORRECT.

;YEP, WE HAVE TO DO IT ALL OVER AGAIN AND SHIFT IN THE NEW DATA.

BR210:	STX	TMP_NMI5	;SAVE RESULTING END POSITION

	LDA	FETCHROW
	CLC
	ADC	#2		;PUT FETCHING ROW BACK TO CORRECT VALUE
	STA	FETCHROW

	LDA	#0
	STA	WORLDSPOT
	STA	WORLDSPOT+1	;ASSUME WE HAVE TO MOVE DOWN A BACKGROUND
	LDA	FETCHROW
	AND	#7		;WE DO IF WE ARE ON THE LAST PALETTE ROW
	CMP	#6
	BCC	BR211
 	LDA	BLOCK_WIDTH
	STA	WORLDSPOT	;THE BYTE WE WANT IS IN THE NEXT BACKGROUND.

BR211:

;IFDEF( `INDIRECT', `
			;NO CORRECTION IF 1 BYTE TABLE FORMAT
.ifndef INDIRECT;	', `
	ASL	WORLDSPOT
	ROL	WORLDSPOT+1	;MAKE 1 WORD CORRECTION TO NEXT BLOCK ROW
.endif ;' )

	LDA	TMP_NMI9
	CLC
	ADC	WORLDSPOT
	STA	WORLDSPOT
	LDA	TMP_NMIA
	ADC	WORLDSPOT+1
	STA	WORLDSPOT+1	;POINT TO NEXT BLOCK ROW IF NEEDED.

	LDA	FETCHROW
	CLC
	ADC	#2
	STA	FETCHROW	;MOVE OUR POINTER AHEAD.

.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;NOW WORLDSPOT POINTS TO THE BLOCK WE SHOULD SHIFT DOWN INTO OUR CURRENT DATA.
;TMP_NMI3 AND 4 HAVE THE AMOUNT TO ADD TO SKIP TO THE NEXT BLOCK.

;TMP_NMID WILL BE MADE INTO AMOUNT TO WRITE IN FIRST HALF OF SCREEN
;BUFFER ADDRESSING, TMP_NMIE INTO AMOUNT FOR SECOND HALF.

	LDA	SCCNT		;GET ORIGINAL POINTER
	CLC
	ADC	#4		;SKIP THE HEADER, POINT TO DATA WE PUT THERE
	STA	TMP_NMI7	;SET AS FIRST PLACE TO WRITE DATA
	TAX
	DEX			;GET LENGTH BYTE
	LDA	SCNBUF,X
	STA	TMP_NMID	;SAVE COUNT
	CLC
	ADC	TMP_NMI7	;AND SKIP THAT TO POINT TO NEXT DATA
	ADC	#4		;ALSO SKIP THAT HEADER
	STA	TMP_NMI8	;MAKE IN CASE OF SECOND WRITE
	CMP	TMP_NMI5	;SEE IF WE DID WRITE A SECOND TIME.
	BCS	BR213		;TMP_NMIE=0 FROM BEFORE SO WE CAN SKIP IF NOT
  	TAX			
	DEX
	LDA	SCNBUF,X
	STA	TMP_NMIE	;SET AMOUNT WE WROTE SECOND PASS

;NOW TMP_NMI7 AND 8 HAVE THE 2 PLACES TO SHIFT THE DATA IN.  TMP_NMID
;HAS FIRST ADDRESSING AMOUNT, TMP_NMIE HAS SECOND OR 0 IF WE ARE EXACTLY
;ON A ROW START OR AT A VIDEO PAGE EXACT END.

BR213:	JSR	ROWPAL		;MAKE (NMI_PTR) TO THE DATA AT ROW WE WANT

	LDA	#2		;ASSUME 2 LEFT IN THIS BACKGROUND
	STA	TMP_NMIC
	LDA	FETCHCOL
	AND	#4		;SEE IF WE ARE IN THE SECOND PALETTE BYTE
	BEQ	BR228
	DEC	TMP_NMIC	;IF SO, ONLY 1 LEFT IN THIS BACK
	INC	NMI_PTR
	BNE	BR228
	INC	NMI_PTR+1	;AND WE NEED SECOND PALETTE BYTE

BR228:	LDX	TMP_NMI7	;FOR THE FIRST PASS WE USE THIS LOCATION

;SHIFT IN DATA FROM THE BACKGROUND LIST FOR LENGTH TMP_NMID.  WHEN DONE,
;IF TMP_NMIE HAS NON-ZERO WE READDRESS USING TMP_NMI8
;START OVER.  TMP_NMIC HAS THE AMOUNT LEFT IN THE CURRENTLY SELECTED
;BACKGROUND (USING ROWBACK) THAT WE HAVE IN THIS COLUMN.

BR232: 	LDA	TMP_NMIC	;GET AMOUNT LEFT IN THIS BACKGROUND
	BNE	BR234		;IF THERE IS SOME, USE IT
	JSR	NEXTBACK	;SKIP TO THE NEXT BACKGROUND IN THE BLOCK
  	JSR	ROWPAL		;SET UP FOR NEW BACKGROUND
	LDA	#2
	STA	TMP_NMIC	;RESET AMOUNT WE CAN WRITE FROM THERE

BR234:	CMP	TMP_NMID	;DO WE NEED THAT MUCH?
	BCC	BR235
	LDA	TMP_NMID	;IF NOT, USE AS MUCH AS WE NEED
	BEQ	BR250		;IF NONE LEFT, DONE WITH THIS WRITE
BR235:	STA	TMP_NMI1	;SET UP TO FETCH THIS DATA
	LDA	TMP_NMIC
	SEC	
	SBC	TMP_NMI1	;MAKE AMOUNT LEFT IN THIS BACKGROUND
	STA	TMP_NMIC
	LDA	TMP_NMID
	SEC
	SBC	TMP_NMI1	;AND AMOUNT LEFT TO WRITE OUT WITH THIS ADDRESS
	STA	TMP_NMID
 
	JSR	SHIFTROW	
	JMP	BR232		;KEEP WRITING TILL TMP_NMID IS DONE

;DONE WRITING OUT TMP_NMID. SEE IF MORE TO WRITE WITH NEW ADDRESS IN
;TMP_NMIE.

BR250:	LDA	TMP_NMIE
	BEQ	BR400
	STA	TMP_NMID
	LDA	#0
	STA	TMP_NMIE	;ZERO SECOND WRITE FOR NEXT PASS

	LDX	TMP_NMI8
	JMP	BR232		;GO BACK AND DO ANOTHER BUNCH

;ALL DONE. 

BR400:	STX	SCCNT		;SAVE THE COUNT WE WROTE
 	RTS

	.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;CALL HERE TO TAKE A ROW WITHIN A BACKGROUND IN FETCHROW (LOW 3 BITS).  
;(WORLDSPOT) SHOULD POINT TO THE BACKGROUND.  ON RETURN (NMI_PTR) POINTS 
;TO THAT CHARACTER IN THE BACKGROUND AT COL 0 OF THE BACKGROUND.  THIS 
;ROUTINE IS FOR BLOCK MODE ONLY.  FETCHROW IS UNCHANGED.

ROWBACK:		
	LDA	FETCHROW
	AND	#7
	ASL	A
	ASL	A
	ASL	A		;MAKE *8
	ADC	#3		;SKIP HEADER BYTES
	JMP	FINISH_COL

;CALL HERE TO TAKE A ROW WITHIN A BACKGROUND IN FETCHROW.
;(WORLDSPOT) SHOULD POINT TO THE BACKGROUND (8 X 8 BACKGROUNDS ONLY)
;ON RETURN (NMI_PTR) POINTS TO THE PALETTE BYTE OF COLUMN 0 IN THAT 
;BACKGROUND. THIS ROUTINE IS FOR BLOCK MODE ONLY.  FETCHROW IS NOT CHANGED.

ROWPAL:		
	LDA	FETCHROW
	AND	#4		;SECOND PALETTE ROW IS FOR ROW 4 IN BACKGROUND
	LSR	A		;BUT THAT ONLY SKIPS 2 BYTES
	CLC
	ADC	#67		;SKIP HEADER BYTES AND BACKGROUND DATA
	JMP	FINISH_COL

	.endif ;' )

;THIS ROUTINE WILL DISPLAY A GIVEN COLUMN IN THE VIRTUAL (BIG) BACKGROUND
;CREATED FROM THE STRIPS OR BLOCKS.  ON ENTRY, FETCHCOL (WORD) HAS THE
;DESIRED COLUMN FROM THE WORLD.  FETCHROW (BYTE) HAS THE TOP ROW TO
;PAINT IN THAT COLUMN (NOT USED IF STRIP MODE).  SUBSVAR6 HAS THE DATA COLUMN
;IN THE REAL BACKGROUND SET UP BY FINDCOL.

;REMEMBER THAT A WORLD CONSISTS OF SMALLER BACKGROUNDS LINKED 
;TOGETHER.  IN THE CASE OF STRIP MODE, THIS ROUTINES ASSUMES
;THAT THE CORRECT BACKGROUND HAS BEEN SET UP BUT IT NEEDS TO KNOW WHERE IN
;THE SCREEN BUFFER TO PUT THE DATA.  IT IS ASSUMED THAT COLUMN 0 IS THE
;LEFTMOST COLUMN OF SCREEN 0.  THEN ALL COLUMNS ARE ASSUMED TO BE LAYED
;DOWN TO THE RIGHT OF THAT ONE WITH WRAP AT THE END OF PAGE 2.  THUS
;FETCHCOL AND FETCHROW ARE THE COLUMN AND ROW IN THE VIRTUAL BACKGROUND
;AND X IS THE PLACE TO GET IT IN THE REAL BACKGROUND CURRENTLY
;SELECTED IF STRIP MODE IS IN EFFECT.   IN BLOCK MODE, MULTIPLE CALCULATIONS
;MUST BE MADE TO FIND THE DATA.

;THIS ROUTINE DOES NOT RANGE CHECK YOUR VALUES SO MAKE SURE THEY ARE OK.

;SCNBUF MUST HAVE 80 BYTES OF AVAILABLE ROOM IN THE SCREEN BUFFER.
;THIS ROUTINE WILL NOT CHECK THIS FOR YOU.

BUILD_COL:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;BLOCK MODE LOGIC.

	LDA	WORLDSPOT
	STA	TMP_NMI9	
	LDA	WORLDSPOT+1
	STA	TMP_NMIA	;NEED COPY OF STARTING BACKGRND FOR PAL BYTES

	LDA	BLOCK_WIDTH
	STA	TMP_NMI3
	LDA	#0
	STA	TMP_NMI4

;IFDEF( `INDIRECT', `
			;NO CORRECTION IF 1 BYTE TABLE FORMAT
.ifndef INDIRECT;	', `
	ASL	TMP_NMI3
	ROL	TMP_NMI4	;MAKE 1 WORD CORRECTION TO NEXT BLOCK ROW
.endif ;' )

;NOW WORLDSPOT POINTS TO THE BLOCK WE SHOULD START FETCHING FROM.  
;TMP_NMI9 AND A ALSO HAVE THAT ADDRESS FOR WHEN WE FETCH PALETTE INFO.
;TMP_NMI3 AND 4 HAVE THE AMOUNT TO ADD TO SKIP TO THE NEXT BLOCK.
;MAKE THE VIDEO RAM ADDRESS.

	LDA	FETCHCOL
	AND	#31		;MAKE SCREEN COLUMN WITHIN THE VIDEO PAGE
	STA	TMP_NMI7

	LDX	#32		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	LDA	#32
	AND	FETCHCOL	;TEST TO GET PAGE NUMBER 
	BEQ	BC20
	LDX	#36		;IF ODD BIT ABOVE WIDTH, PAGE 2

BC20:	STX	TMP_NMI8	;SAVE STARTING PAGE
	LDX	FETCHROW
	LDY	#0
	LDA	#30
	JSR	DIVIDE		;MAKE REMAINDER FROM MOD 30 (SCREEN HEIGHT)
	STX	TMP_NMIB	;SAVE PAGE WRAP WE ARE IN FOR SHIFT COUNT.
	STY	TMP_NMID	;SAVE REMAINDER FOR COUNT WE CAN WRITE TO BOTTOM
	STY	SUBSVAR6	;SAVE HERE FOR PALETTE FIGURING
	LDX	#32
	JSR	MUL		;MAKE ROW WITHIN SCREEN BUFFER
	TXA
	CLC
	ADC	TMP_NMI7
	STA	TMP_NMI5
	TYA
	ADC	TMP_NMI8
	STA	TMP_NMI6	

	.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;NOW TMP_NMI5 AND 6 POINT TO THE SCREEN POSITION TO WRITE DATA AT IN THE
;SCREEN BUFFER.  TMP_NMI7 AND 8 POINT TO THE CORRESPONDING COLUMN AT
;THE TOP OF THE PAGE.  TMP_NMIE HAS THE ROW WITHIN THIS SCREEN BUFFER AT
;WHICH WE ARE STARTING.  TMP_NMIB HAS THE VIDEO PAGE WE ARE IN VERTICALLY
;SO WE CAN CALCULATE THE SHIFT WE NEED WHEN WE WRITE PALETTE DATA.
;SUBSVAR6 HAS THE ROW WITHIN THE SCREEN BUFFER WE ARE ON.

;TMP_NMID WILL BE MADE INTO AMOUNT TO WRITE IN FIRST HALF OF SCREEN
;BUFFER ADDRESSING, TMP_NMIE INTO AMOUNT FOR SECOND HALF.

	LDA	WORLD_HEIGHT
	SEC
	SBC	FETCHROW	;MAKE DISTANCE TO BOTTOM OF BACKGROUND
	CMP	#30
	BCC	BC23
     	LDA	#30		;BUT WE ONLY CAN FIT 30 IN A SCREEN
BC23:	STA	TMP_NMIE	;SET HERE AS MAXIMUM WE COULD WRITE OUT
	LDA	#30
	SEC
	SBC	TMP_NMID	;MAKE DISTANCE TO BOTTOM OF THIS VIDEO PAGE
	CMP	TMP_NMIE	;MAKE SURE THERES ENOUGH TO FILL TO BOTTOM
	BCC	BC24
     	LDA	TMP_NMIE	;IF NOT, USE HOW MUCH IS LEFT.
BC24:	STA	TMP_NMID	;SAVE AMOUNT TO BOTTOM OF THIS VIDEO PAGE
	LDA	TMP_NMIE	;GET TOTAL WE ARE WRITING
	SEC
	SBC	TMP_NMID	;MAKE INTO AMOUNT TO WRITE IN SECOND PAGE
	STA	TMP_NMIE	;AND SAVE HERE FOR LOOPING.

;SET UP INITIAL ADDRESSING TO START THE LOOP.

	JSR	COLBACK		;MAKE (NMI_PTR) TO THE DATA AT COLUMN WE WANT
	LDA	FETCHROW
	AND	#7		;GET ROW WE ARE ON IN THIS BLOCK
	STA	TMP_NMIC	;SAVE A COPY
	ASL	A
	ASL	A
	ASL	A
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	BCC	BC28
	INC	NMI_PTR+1	;FOR FIRST ADDRESSING, START AT ODD ROW
BC28:	LDA	#8
	SEC
	SBC	TMP_NMIC	;MAKE AMOUNT LEFT IN THIS BACKGROUND.
	STA	TMP_NMIC	;PUT WHERE LOOP WANTS IT TO BE

;ADDRESS AND WRITE OUT THE AMOUNT.

	LDX	SCCNT		;GET THE INDEX
BC30:	LDA	#4
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI6
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI5
	STA	SCNBUF,X
	INX

	LDA	TMP_NMID	
	STA	SCNBUF,X	;STORE THE COUNT TO WRITE FOR THE FIRST HALF
	INX

;WRITE DATA FROM THE BACKGROUND LIST FOR LENGTH TMP_NMID.  WHEN DONE,
;IF TMP_NMIE HAS NON-ZERO WE READDRESS USING TMP_NMI3 AND 4 AND
;START OVER.  TMP_NMIC HAS THE AMOUNT LEFT IN THE CURRENTLY SELECTED
;BACKGROUND (USING COLBACK) THAT WE HAVE IN THIS COLUMN.

BC32: 	LDA	TMP_NMIC	;GET AMOUNT LEFT IN THIS BACKGROUND
	BNE	BC34		;IF THERE IS SOME, USE IT
	JSR	NEXTBACK	;SKIP TO THE NEXT BACKGROUND IN THE BLOCK
  	JSR	COLBACK		;SET UP FOR NEW BACKGROUND
	LDA	#8
	STA	TMP_NMIC	;RESET AMOUNT WE CAN WRITE FROM THERE

BC34:	CMP	TMP_NMID	;DO WE NEED THAT MUCH?
	BCC	BC35
	LDA	TMP_NMID	;IF NOT, USE AS MUCH AS WE NEED
	BEQ	BC50		;IF NONE LEFT, DONE WITH THIS WRITE
BC35:	STA	TMP_NMI1	;SET UP TO FETCH THIS DATA
	LDA	TMP_NMIC
	SEC	
	SBC	TMP_NMI1	;MAKE AMOUNT LEFT IN THIS BACKGROUND
	STA	TMP_NMIC
	LDA	TMP_NMID
	SEC
	SBC	TMP_NMI1	;AND AMOUNT LEFT TO WRITE OUT WITH THIS ADDRESS
	STA	TMP_NMID
 
	LDA	#8
	STA	TMP_NMI2	;USES TMP_NMI1 = LENGTH, TMP_NMI2 = WIDTH
	JSR	LOADCOL		;AND (NMI_PTR) = DATA.  X=PLACE IN SCNBUF.
	JMP	BC32		;KEEP WRITING TILL TMP_NMID IS DONE

;DONE WRITING OUT TMP_NMID. SEE IF MORE TO WRITE WITH NEW ADDRESS IN
;TMP_NMIE.

BC50:	LDA	TMP_NMIE
	BEQ	BC100
	STA	TMP_NMID
	LDA	#0
	STA	TMP_NMIE	;ZERO SECOND WRITE FOR NEXT PASS

	LDA	TMP_NMI7
	STA	TMP_NMI5
	LDA	TMP_NMI8
	STA	TMP_NMI6
	JMP	BC30		;GO SHARE ADDRESS AND LENGTH CODE

	.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;DONE WITH DATA.  WRITE PALETTE INFO.  WE STILL HAVE THE STARTING
;BLOCK IN TMP_NMI9 AND A AND THE SHIFT FLAG FOR VERTICAL PALETTE SKEW
;IN TMP_NMIB.  TMP_NMI3 AND 4 HAVE THE SKIP TO NEXT BLOCK WORD AMOUNT.

BC100:	STX	SCCNT		;SAVE THE COUNT WE WROTE

	LDA	TMP_NMI9
	STA	WORLDSPOT
	LDA	TMP_NMIA
	STA	WORLDSPOT+1	;POINT BACK TO THE FIRST BLOCK WE USED
	LDA	TMP_NMIB
	AND	#1
	STA	TMP_NMI2	;SAVE THE SHIFT FLAG HERE.  ODD SCREENS SHIFT

;FIRST WE FETCH AS MANY PALETTE BYTES AS WE WILL NEED FOR THE FULL JOB.

	LDA	WORLD_HEIGHT
	SEC
	SBC	FETCHROW	;MAKE DISTANCE TO BOTTOM OF BACKGROUND
	CMP	#36		;SEE IF TOO MUCH.  WE CAN ONLY FETCH 9 MAX.
	BCC	BC110
	LDA	#36		;IF SO, WE WOULD HAVE FETCHED 30 ONLY
BC110:	CLC
	ADC	#3		;ROUND IT UP IN CASE OF ODD AMOUNT
	LSR	A
	LSR	A		;DIVIDE BY 4 TO GET NUMBER OF PALETTE BYTES
	STA	TMP_NMI5	;SAVE BYTES TO FETCH HERE.
	STA	SUBSVAR5	;AND OUT OF VARIABLES SO SAVE A COPY HERE.

	LDA	#2		;ASSUME FETCHING 2 FROM FIRST BACKGROUND
	STA	TMP_NMI1	;PUT IT HERE FOR THE CALL
	JSR	INPAL		;POINT TO THE PALETTE BYTE IF AT TOP

	LDA	TMP_NMI2	;SEE IF WE ARE GOING TO SHIFT THE BACKGROUND
	BEQ	BC111
      	LDA	FETCHROW
	AND	#2		;IF SO, ARE WE ON SECOND HALF OF A PAL BYTE?
	BNE	BC111		;IF SO, SHIFT IS OK. IF NOT, WE NEED PREV BYTE
	LDA	FETCHROW
	AND	#4
	BNE	BC115		;JUST USE FIRST PAL BYTE IF WE ARE ON SECOND
	JSR	PREVBACK	;IF ON FIRST, BACK UP TO LAST BACKGROUND
	JSR	INPAL
	JMP	BC112		;AND GET SECOND BYTE OF IT.

BC111: 	LDA	FETCHROW	;SEE IF ON SECOND ROW OF PALETTE ROWS
	AND	#4
	BEQ	BC115
BC112: 	LDA	#1		;IF SO, WE ARE FETCHING ONLY 1
	STA	TMP_NMI1
	LDA	NMI_PTR
	CLC
	ADC	#2
	STA	NMI_PTR
	BCC	BC115
	INC	NMI_PTR+1	;AND WE MUST SKIP THE FIRST ROW IN PAL BUFFER

BC115:	LDX	#0		;GET THE BYTES INTO BUFFER TMP_NMI6

BC120:	LDA	TMP_NMI5	;GET BYTES REMAINING TO FETCH
	BEQ	BC130
	SEC
	SBC	TMP_NMI1	;SUBTRACT NUMBER WE ARE GETTING NOW
	STA	TMP_NMI5
	JSR	LOADPCOL	;GETS DATA INTO TMP_NMI6,X FOR LENGTH TMP_NMI1
				;AT LOCATION X IN TMP_NMI6.
	JSR	NEXTBACK
  	JSR	INPAL		;SET UP FOR NEW BACKGROUND
	LDA	#2
	STA	TMP_NMI1	;SET AMOUNT TO FETCH NEXT TIME TO 2
	CMP	TMP_NMI5	;MAKE SURE ITS NOT MORE THAN WE NEED
	BCC	BC120
	LDA	TMP_NMI5
	STA	TMP_NMI1	;IF WE WERE GETTING TOO MANY, GET MAX
	JMP	BC120

;WE HAVE THE PALETTE BYTES IN THE BUFFER.  SHIFT THEM IF NECESSARY.  

BC130:	LDA	TMP_NMI2	;GET SHIFT FLAG
	BEQ	BC140
	LDY	#4		;MUST SHIFT 4 BITS DOWN
BC132:	CLC	
	ROR	TMP_NMIE
	ROR	TMP_NMID
	ROR	TMP_NMIC
	ROR	TMP_NMIB
	ROR	TMP_NMIA
	ROR	TMP_NMI9
	ROR	TMP_NMI8
	ROR	TMP_NMI7
	ROR	TMP_NMI6
	DEY
	BNE	BC132

;SEE IF WE FETCHED MORE THAN ARE POSSIBLE TO STORE IN THE BUFFER.  WE CAN
;STORE 9 IF WE ARE ON A PARTIAL PALETTE BYTE. IF EXACTLY STARTING AT PALETTE
;BYTE TOP, WE ONLY NEED 8.

BC140: 	LDA	SUBSVAR6
	AND	#3
	BNE	BC145		;IF NOT EXACTLY AT START OF BUFFER, ITS A SPLIT
	LDA	SUBSVAR5	;GET BACK NUMBER WE WROTE
	CMP	#8
	BCC	BC145
	LDA	#8
	STA	SUBSVAR5	;IF MORE THAN 8, JUST USE 8

	.endif ;' )
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;THE BYTES ARE ALL THERE.  ADDRESS EACH SEPERATELY AND WRITE IT OUT TO VIDEO.

BC145:	LDA	FETCHCOL	;GET COLUMN WITHIN BUFFER
	AND	#31
	LSR	A
	LSR	A		;DIVIDE BY 4 TO FIND BYTE IN PALETTE ROW
	STA	TMP_NMI3	;SAVE ADDRESS OF COLUMN HERE
	LDA	SUBSVAR6	;GET ROW WITHIN VIDEO PAGE
	AND	#252		;REMOVE LOW 2 BITS
	ASL	A		;TO MAKE EVERY 4 ROWS SKIP 8 BYTES IN PAL RAM
	ADC	TMP_NMI3
	ADC	#192		;ADD HEX C0 CAUSE PALETTE STUFF STARTS THERE
	STA	TMP_NMI3	

	LDX	#35		;ASSUME PAGE 0 PALETTE ADDRESS
	
	LDA	#32
	AND	FETCHCOL	;TEST TO GET PAGE NUMBER 
	BEQ	BC150
	LDX	#39		;IF ODD BIT ABOVE WIDTH, PAGE 1

BC150:	STX	TMP_NMI4	;SAVE STARTING PAGE

	LDX	SCCNT
 	LDY	#0		;GET FIRST BYTE AT TMP_NMI6 FOR LEN SUBSVAR5
BC160:	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI4
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI3
	STA	SCNBUF,X
	INX
	LDA	#1		;WE ALWAYS JUST QUE 1 IN THIS CASE
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI6,Y	;GET NEXT PALETTE BYTE
	INY
	STA	SCNBUF,X	;QUE IT UP
	INX
	LDA	TMP_NMI3	;SKIP TO NEXT PALETTE ROW
	CLC
	ADC	#8
	ORA	#192		;KEEP C0 SET IN CASE OF WRAP
	STA	TMP_NMI3
	BCC	BC170
	TYA
	PHA
 	LDY	#4     	
BC165:	CLC	     		;IF BUFFER WRAP, NEED TO SHIFT THE NIBBLES
	ROL	TMP_NMI6	;BACK UP CAUSE THE LAST ONE WAS THROWN
	ROL	TMP_NMI7	;OUT BY THE HARDWARE.
	ROL	TMP_NMI8
	ROL	TMP_NMI9
	ROL	TMP_NMIA
	ROL	TMP_NMIB
	ROL	TMP_NMIC
	ROL	TMP_NMID
	ROL	TMP_NMIE
	DEY
	BNE	BC165
	PLA
	TAY
BC170:	DEC	SUBSVAR5	;COUNT 1 MORE QUED UP
	BNE	BC160	
	STX	SCCNT		;SET COUNT WE STORED

;ALL DONE. 

 	RTS

.endif ;' )

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

;CALL HERE TO TAKE A COLUMN WITHIN A BACKGROUND IN FETCHCOL (LOW 3 BITS).  
;(WORLDSPOT) SHOULD POINT TO THE BACKGROUND.  ON RETURN (NMI_PTR) POINTS 
;TO THAT CHARACTER IN THE BACKGROUND AT ROW 0 OF THE BACKGROUND.  THIS 
;ROUTINE IS FOR BLOCK MODE ONLY.  FETCHCOL IS UNCHANGED.

COLBACK:		
	LDA	FETCHCOL
	AND	#7
	CLC
	ADC	#3		;SKIP HEADER BYTES

FINISH_COL:
	LDY	#0
.ifdef INDIRECT;IFDEF( `INDIRECT', `
	PHA
	LDA	(WORLDSPOT),Y	;IF INDIRECT, THIS IS 1 BYTE OFFSET IN BLOCKS
	STA	NMI_PTR
	LDA	#0
	STA	NMI_PTR+1
	ASL	NMI_PTR
	ROL	NMI_PTR+1	;MAKE BLOCK POINTER
	LDA	#BLOCKS & 255
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	LDA	#BLOCKS >> 8
	ADC	NMI_PTR+1
	STA	NMI_PTR+1
	PLA
	CLC
	ADC	(NMI_PTR),Y
	PHA
	INY
	LDA	(NMI_PTR),Y
	ADC	#0
	STA	NMI_PTR+1
	PLA
	STA	NMI_PTR
.endif;	', `
.ifndef INDIRECT
	ADC	(WORLDSPOT),Y	;IF WORD BLOCK MODE THEN THIS POINTS TO 
	STA	NMI_PTR		;THE BACKGROUND OFFSET
	TYA
	INY
	ADC	(WORLDSPOT),Y
	STA	NMI_PTR+1	;MAKE DIRECT POINTER TO THE DATA WE WANT
.endif ;' )
	RTS

;CALL HERE TO TAKE A COLUMN WITHIN A BACKGROUND IN FETCHCOL (LOW 3 BITS).  
;(WORLDSPOT) SHOULD POINT TO THE BACKGROUND.  ON RETURN (NMI_PTR) POINTS 
;TO THE PALETTE BYTE IN THE BACKGROUND AT ROW 0 FOR THAT COLUMN.
;FETCHCOL IS UNCHANGED.

INPAL:
	LDA	FETCHCOL
	ROR	A
	ROR	A
	ROR	A		;SET CARRY IF PAST FIRST PALETTE BYTE
	LDA	#67		;SKIP THE DATA BYTES AND THE HEADER
	ADC	#0
	JMP	FINISH_COL

;THIS ROUTINE ADDS TMP_NMI4:TMP_NMI3 TO WORLDSPOT.  THIS IS USED TO POINT
;TO THE NEXT BACKGROUND IN BOTH COLUMN AND ROW WRITE AFTER SETTING
;UP TMP_NMI4 AND 3.

NEXTBACK:
	LDA	WORLDSPOT	;NOW POINT TO NEXT BACKGROUND
	CLC
	ADC	TMP_NMI3
	STA	WORLDSPOT
	LDA	WORLDSPOT+1
	ADC	TMP_NMI4
	STA	WORLDSPOT+1	;SKIP TO NEXT BLOCK
	RTS

;THIS ROUTINE SUBTRACTS TMP_NMI4:TMP_NMI3 TO WORLDSPOT.  THIS IS USED TO POINT
;TO THE PREVIOUS BACKGROUND IN BOTH COLUMN AND ROW WRITE AFTER SETTING
;UP TMP_NMI4 AND 3.

PREVBACK:
	LDA	WORLDSPOT	;NOW POINT TO NEXT BACKGROUND
	SEC
	SBC	TMP_NMI3
	STA	WORLDSPOT
	LDA	WORLDSPOT+1
	SBC	TMP_NMI4
	STA	WORLDSPOT+1	;SKIP TO NEXT BLOCK
	RTS
.endif;	' , )

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', , `		

;STRIP MODE LOGIC

	LDA	SUBSVAR6	;GET COLUMN IN CURRENT BACKGROUND
	CLC
	ADC	BACKBASE
	STA	NMI_PTR
	LDA	#0
	ADC	BACKBASE+1
	STA	NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO DATA, SUBSVAR6 HAS COL.  ROW IS FIXED AT 0.

	LDA	FETCHCOL
	AND	#31		;MAKE SCREEN COLUMN MOD WIDTH
	STA	TMP_NMI3	

	LDX	#32		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	LDA	#32
	AND	FETCHCOL	;TEST TO GET PAGE NUMBER 
	BEQ	BC20
	LDX	#36		;IF ODD BIT ABOVE WIDTH, PAGE 2

BC20:	STX	TMP_NMI4	;SAVE STARTING PAGE

;NOW TMP_NMI3 AND 4 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  
;LOAD THE DATA INTO SCNBUF.

	LDX	SCCNT		;GET THE INDEX
	LDA	#4
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI4
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI3
	STA	SCNBUF,X
	INX

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT

	LDA	#30		;GET MAX HEIGHT WE CAN WRITE
	CMP	BACKHIGH	;SEE IF THERE REALLY IS THAT MUCH
	BCC	BC30
     	LDA	BACKHIGH	;IF NOT, WRITE OUT MAX
BC30:	STA	SCNBUF,X
	INX
	STA	TMP_NMI1	;SET COUNT TO WRITE OUT

;NOW THE ACTUAL DATA

	LDA	BACKWIDE
	STA	TMP_NMI2	;SET WIDTH FOR THE CALL
	JSR	LOADCOL
 	STX	SCCNT		;SAVE OFFSET IN BUFFER

;DONE QUEING DATA.  QUE THE PALETTE INFO

	LDA	SUBSVAR6	;GET COL WE ARE ON
	LSR	A
	LSR	A		;MAKE PALETTE BYTE IN THAT COLUMN WE ARE ON
	CLC
	ADC	BPBASE
	STA	NMI_PTR
	LDA	BPBASE+1
	ADC	#0
	STA	NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

.endif ;' )

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', , `		

;NMI_PTR POINTS TO PAL DATA WE ARE TO USE.  MAKE POINTERS TO THE
;PALETTE BYTE IN THE PALETTE RAM.

	LDA	TMP_NMI3	;GET BACK COL WITHIN SCREEN
	LSR	A
	LSR	A		;AND MAKE INTO PALETTE BYTE
	CLC
	ADC	#192		;ADD LOW OFFSET TO IT
	STA	TMP_NMI3	;SAVE BYTE IN PALETTE BUFFER

	LDX	#35		;ASSUME PAGE 0 PALETTE ADDRESS
	
	LDA	#32
	AND	FETCHCOL	;TEST TO GET PAGE NUMBER 
	BEQ	BC40
	LDX	#39		;IF ODD BIT ABOVE WIDTH, PAGE 1

BC40:	STX	TMP_NMI4	;SAVE STARTING PAGE

;NOW TMP_NMI3 AND 4 POINT TO THE PLACE TO PUT THE DATA IN THE PALETTE BUFFER
;LOAD THE PAL INTO SCNBUF.

	LDA	BACKHIGH
	CLC
	ADC	#3		;ROUND UP HEIGHT IN ROWS
	LSR	A
	LSR	A		;MAKE HEIGHT IN PALETTE BYTES
	STA	TMP_NMI1	;SAVE HERE	
	LDA	#8		;GET HEIGHT IF FULL SCREEN.
	CMP	TMP_NMI1	;SEE IF WE CAN DO IT
	BCC	BC50		;IF THERE ARE ENOUGH, OK
	LDA	TMP_NMI1
BC50:	STA	TMP_NMI1
	LDA	BPWIDE
	STA	TMP_NMI2	

	LDX	SCCNT		;GET THE INDEX
	JSR	LOADPCOL	;QUE THE DATA
	STX	SCCNT		;UPDATE COUNT IN BUFFER

;ALL DONE. 

 	RTS

.endif ;' )

;THIS ROUTINE WILL RETURN THE AMOUNT OF FREE SPACE IN SCNBUF.  IT IS
;RETURNED IN A.  ONLY A IS CHANGED.

GET_ROOM:
	LDA	#SCSIZE
	SEC
	SBC	SCCNT
	RTS

;THIS ROUTINE WILL FIX XBACK AND YBACK TO KEEP THEM IN RANGE WITH THE
;CURRENTLY SPECIFIED BACKGROUND.  IT ASSUMES THAT INITBACK HAS ALREADY 
;SET RIGHTLIMIT.

FIXSCROLL:

 	LDA	RIGHTLIMIT
	SEC
	SBC	XBACK
	LDA	RIGHTLIMIT+1	
	SBC	XBACK+1		;SEE IF XBACK IS TOO BIG
	BCS	FX6
	LDA	RIGHTLIMIT
	STA	XBACK
	LDA	RIGHTLIMIT+1
	STA	XBACK+1		;IF TOO BIG, SET AS LAST POSITION

FX6:	LDA	BOTLIMIT
	SEC
	SBC	YBACK
	LDA	BOTLIMIT+1	
	SBC	YBACK+1		;SEE IF XBACK IS TOO BIG
	BCS	FX7
	LDA	BOTLIMIT
	STA	YBACK
	LDA	BOTLIMIT+1
	STA	YBACK+1		;IF TOO BIG, SET AS LAST POSITION

	JSR	MAKEDING

FX7:	RTS


;THIS ROUTINE WILL TAKE A VALID PIXEL COLUMN OR ROW LOCATION IN Y:X AND MAKE 
;IT INTO AN ACTUAL DATA COLUMN OR ROW POINTER WITHIN A BACKGROUND.  
;IT SHIFTS THE VALUE DOWN.

ADJ_BACK:
	JSR	SHIFTDOWN
	JSR	SHIFTDOWN
	JSR	SHIFTDOWN
	RTS

;THIS ROUTINE WILL TAKE A DATA ROW OR COLUMN POSITION IN Y:X AND
;MAKE IT INTO AN ACTUAL PIXEL ROW OR COLUMN LOCATION WITHIN A BACKGROUND.
;IT SHIFTS UP ACCOUNTING FOR BACKGROUND SIZE.

BACK_PIX:
	JSR	SHIFTUP
	JSR	SHIFTUP
	JSR	SHIFTUP
	RTS

;THIS SUBROUTINE WILL SHIFT A WORD VALUE IN Y:X DOWN 1 BIT.

SHIFTDOWN:
	TYA
	LSR	A
	TAY
	TXA
	ROR	A
	TAX
	RTS

;THIS SUBROUTINE WILL SHIFT A WORD VALUE IN Y:X UP 1 BIT.

SHIFTUP:	
	TXA
	ASL	A
	TAX
	TYA
	ROL	A
	TAY
	RTS

;THIS ROUTINE WILL MULTIPLY REGISTER X BY REGISTER Y AND STORE THE RESULT
;LOW BYTE IN X AND HIGH IN Y.  THIS ROUTINE MAY BE CALLED FROM
;ANY LEVEL AND IT USES ITS OWN VARIABLES.  THIS ROUTINE DOES NOT CHANGE
;MATH4.

MUL: 	STY	MATH1		;SAVE MULTIPLIER
	STX	MATH3		;SAVE MULTIPLICAND
	LDA	#0
	STA	MATH2		;ZERO HIGH RESULT
	LDX	#8		;THERE ARE 8 BITS TO TEST FOR

M10:	ASL	A		;SHIFT PRODUCT 1 TO DOUBLE IT.  FIRST LOOP=0
	ROL	MATH2		;AND MOVE BIT UP INTO RESULT HIGH BYTE

	ASL	MATH1		;SEE IF WE NEED TO ADD FOR THIS BIT
	BCC	M20
	CLC
	ADC	MATH3		;IF SO, ADD IN THE VALUE
	BCC	M20
	INC	MATH2		;IF CARRY, BRING UP TO HIGH RESULT
M20:	DEX
	BNE	M10
	TAX			;SAVE LOW BYTE IN RETURN REG	
	LDY	MATH2		;AND GET HIGH
	RTS

;THIS ROUTINE WILL DIVIDE THE 1 WORD VALUE IN Y:X BY THE 1 BYTE VALUE IN 
;A.  THE RESULT IS STORED IN X WITH THE REMAINDER IN Y.  THE 1 WORD
;VALUE MUST BE LESS THAN 8000H AND THE RESULT MUST FIT INTO 1 BYTE.

DIVIDE:	STA	MATH3		;PUT DIVISOR WHERE WE CAN SUBTRACT IT
	STX	MATH4		;SAVE COPY OF LOW DIVIDEND IN WORKING REG
	TYA			;GET HIGH	
	LDX	#8		;MAKE LOOP COUNT
D10:  	ASL	MATH4		;SHIFT UP LOW TO SEE IF WE CAN SUBTRACT
	ROL	A		;ROL THE BITS UP AND INTO THE CARRY
	BCS	D15		;IF CARRY, WE CAN ALWAYS SUBTRACT
	CMP	MATH3		;BUT SEE IF ITS BIG ENOUGH ON ITS OWN
	BCC	D20
D15:	SBC	MATH3
	INC	MATH4		;SHIFT IN A 1 BIT, WE DID SUBTRACT
D20:	DEX
	BNE	D10
	TAY			;PUT REMAINDER IN Y
	LDX	MATH4		;AND GET RESULT
	RTS

;THIS ROUTINE WILL ADD THE 1 BYTE VALUE IN A TO THE 2 BYTE VALUE IN
;X AND Y (X LOW BYTE).  THIS ROUTINE MAY BE CALLED FROM ANY LEVEL AND 
;IT USES ITS OWN VARIABLES.  ONLY MATH1 IS CHANGED.

ADD_WORD:
	STX	MATH1
	CLC
	ADC	MATH1
	TAX
	BCC	AW10
	INY
AW10:	RTS

;THIS ROUTINE WILL NEGATE A.

NEGATE:
	EOR	#$FF
	CLC
	ADC	#1
	RTS

;THIS ROUTINE WILL TAKE ANY DATA IN SCNBUF AND WRITE IT TO VIDEO. IT
;ASSUMES YOU HAVE ALREADY DISABLED VIDEO AND IT IS OK TO WRITE.  IT
;RESETS SCCNT WHEN DONE.  ITS OK FOR SCNBUF TO BE EMPTY.

;THIS ROUTINE HONORS THE VERTICAL WRITE BIT BUT WILL ALWAYS RESET
;THIS WHEN DONE.  THE VERTICAL WRITE BIT IS IN REG $2000.

;THIS ROUTINE DOES NOT USE TMP_NMI2 OR ABOVE.

WRITE_SCNBUF:

	LDX	#0		;IF DATA, WRITE FROM BUFFER START
W20:	CPX	SCCNT
	BEQ	W90

	LDA	SCNBUF,X	;GET VERTICAL WRITE FLAG BYTE
	STA	$2000
	INX
	LDA	SCNBUF,X	;GET HIGH ADDRESS
	STA	$2006
	INX
	LDA	SCNBUF,X	;GET LOW
	STA	$2006		;AND USE BOTH TO SET UP THE INDEX REG
	INX
	LDY	SCNBUF,X	;GET THE LENGTH TO WRITE OUT
	INX			;POINT TO THE DATA TO WRITE

W40:	LDA	SCNBUF,X
	INX
	STA	$2007		;WRITE OUT A DATA BYTE
	DEY
	BNE	W40
	JMP	W20	

W90:	LDA	#0
	STA	SCCNT

STOP_NMI:			;CALL HERE TO DISABLE NMI

W100:	LDA	REG2000
	STA	$2000		;REMOVE POSSIBLE VERTICAL WRITE BIT
 	RTS

;THIS ROUTINE WILL WAIT FOR THE NEXT VERTICAL RETRACE.  IT IS NOT
;CLEAR WHETHER IT WILL FUNCTION WITH NMI ENABLED SO DON'T CALL UNLESS
;NMI IS DISABLED.

VERT_WAIT:
	LDA	$2002
	BPL	VERT_WAIT
	RTS

;THIS ROUTINE WILL HIDE ALL SPRITES BY PUTTING THEM ON THE LAST SCAN
;LINE OF THE SCREEN. IT ALSO RESETS OUR SPRITE IN USE FLAG BIT. IT
;SHOULD BE CALLED ONLY AT BOOT TIME.

HIDESPRITES:
	LDA	#$F8
	STA	STATSPR		;HIDE THE TOP OF SCREEN STATUS SPRITE
	LDA	#8		
	STA	STATSPR+2	;AND MARK AS IN USE

HIDEONLY:
	LDY	#0
	LDX	#63

;CALL HERE WITH YOUR OWN Y STARTING INDEX AND X COUNT TO HIDE JUST 
;WHAT YOU WANT.  IT SKIPS SPRITE #0 AND IT WRAPS THE INDEX AT 7F.

HIDE2:

HS10:	LDA	#$F8
	STA	SPRAM,Y		;MOVE OFF SCREEN
	LDA	#0		;AND FREE UP THE SPRITE, RESET PALETTE BITS
	STA	SPRAM+2,Y
HS11:	INY
	INY
	INY
	INY
	CPY	#252		;WRAP INDEX AT LAST SPRITE
	BEQ	HS11
	DEX
	BNE	HS10
	RTS

;********************************************************************************************
;End of moved content - Evenball
;********************************************************************************************
;HERE ARE THE SOUND SLOTS.  EACH PARTICULAR FUNCTION HAS A DEDICATED
;SLOT.

;0-3 ARE THE MUSIC SLOTS 0-3

.include "DRAWDATA.ASM";INCLUDE( DRAWDATA.ASM)		;THIS IS THE SPRITE AND PALETTE DEFFINITIONS
.include "KUNGTAB.ASM";INCLUDE( KUNGTAB.ASM)		;THIS IS THE WORLD FLAGS AND CONTROL DATA

				;AND OTHER DRAWING PROGRAM OUTPUT.  
				;BACKGROUNDS ARE USUALLY IN YOURBACK.ASM BUT
				;IF THERE'S ROOM SOME CAN BE PUT HERE TOO.

;			WORLD FLAGS DESCRIPTION
;
;THE WORLD FLAGS ARE PUT INTO KUNGTAB.ASM AT THE BOTTOM IN THE TABLES
;THAT CONTROL EACH WORLD.  EACH COMMAND OCCUPIES 6 BYTES EVEN IF THEY
;ARE NOT NEEDED IN ORDER TO SPEED UP INDEXING DURING GAME PLAY.  IN
;THE COMMAND TABLES, EACH 6 BYTE SEQUENCE MUST BE PRECEEDED BY A 1
;WORD COLUMN NUMBER ON SCREEN.  THUS EACH COMMAND THERE TAKES 8 BYTES.

;HERE IS A SAMPLE COMMAND TO LAUNCH A HERO ENTITY:
;
;	.word	2
;       .byte	$F0,HEROID,9+54,$00,-1,-1	;LAUNCH HERO

;SOMETIMES THE COMMANDS ARE FOR THINGS PASSED TO AN ENTITY SUCH AS CLIMB
;COMMANDS.  YOU CAN SET BIT $8000 IN THE SCREEN COLUMN WORD TO DOUBLE
;THE COMMAND.  WHEN SET THIS IS THE SAME AS IF YOU PUT 2 OF THE COMMANDS
;WITH THE SECOND HAVING A COLUMN 1 MORE THAN THE FIRST:

;	.word	3
;	.byte     77,157,CLIMB,0,0,0
;	.word	4
;	.byte     77,157,CLIMB,0,0,0
;
;	IS THE SAME AS:

;	.word	$8003
;	.byte     77,157,CLIMB,0,0,0
;
;DONT USE THIS WITH COMMANDS $F0 AND ABOVE, ITS ONLY VALID FOR
;COMMANDS PASSED TO THE ENTITY AS DESCRIBED BELOW.
;
;SOME COMMANDS ARE ACTIVATED WHEN THE SCREEN SCROLLS ONTO THEM (LAUNCH ENEMY,
;SCREEN SCROLL LIMIT, ETC.) AND SOME ARE ACTIVATED WHEN AN ENTITY STEPS
;ONTO THEM.  THE SCREEN SCROLL COMMANDS ARE SCANNED FOR WHEN A SCREEN
;FIRST COMES UP.  THERE AFTER, SCROLLING THE SCREEN CAUSES ANY NEW COMMANDS
;THAT SCROLL IN TO BE USED.  THEY ARE ONLY CONSIDERED SCROLLED ONTO WHEN
;PIXEL 0 OF THAT COLUMN IS COMPLETELY VISIBLE (THIS IS TO MAKE SURE THAT
;LAUNCHED ENTITIES CAN BE PLACED DOWN ACCURATELY TO THE PIXEL LEVEL).
;
;ENTITY ACTIVATED COMMANDS ARE IGNORED UNTIL
;AN ENTITY STEPS INTO THEIR COLUMN AND ROW RANGE.  THERE IS ONLY 1
;ENTITY ACTIVATED COMMAND, IT REPORTS TO A GENERIC ANIMATION/MOVEMENT 
;FUNCTION IN THE ENTITIES TABLE AND THAT MOVEMENT ROUTINE DECIDES WHAT
;TO DO ABOUT IT (A DOOR, CLIMB, ETC).  THE ENTITY HAS A "HOT SPOT"
;THAT IS USED TO DECIDED WHEN HE FALLS INTO THE ROW AND COLUMN RANGE 
;OF THE COMMAND.  AS STATED ABOVE, YOU CAN DOUBLE THESE COMMANDS BY
;SETTING BIT $8000 IN THE COLUMN WORD SPECIFICATION.

;HERE IS A "PICTURE" SHOWING THE "HOT SPOT" OF THE ENTITY 
;(Xs REPRESENT ENTITY):
;
;
;           XXX	
;	    XXX	    
;	    XxX	
;	     ^
;	     ONLY THE CENTER BOTTOM POINT IS ACTIVE 

;THE FIRST BYTE OF EACH COMMAND DETERMINES WHAT THE COMMAND DOES.
;THE REMAINING BYTES (5 MORE) ARE SPECIFIC TO THE COMMAND.  HERE
;ARE THE COMMANDS:

;00 = NO ACTION OR TARGET.  MUST REMAIN 0.  USED INTERNALLY.
;
;01 TO $EF = WORLD EVENT COMMAND.  
;		COMMANDS IN THIS RANGE ARE ACTUALLY TOP OF SCREEN ROW
;		SPECIFICATIONS FOR A SCREEN RANGE IN WHICH YOUR ENTITY
;		WILL BE NOTIFIED IF IT STEPS INTO THAT RANGE.  IN ORDER
;		TO SAVE PROCESSOR POWER, EACH ENTITY HAS A BIT TO DETERMINE
;		IF IT WILL CHECK FOR COMMANDS OR NOT CHECK.  WHEN THE BIT
;		IS SET (IN ENTITYTAB) THEN THE ENTITY WILL BE TOLD WHEN
;		HE WALKS ONTO THIS COMMAND.   HE IS CONSIDERED HAVING 
;		WALKED ONTO THE COMMAND IF HIS HOTSPOT (HIS BOTTOMMOST PIXEL
;		IN THE CENTER OF HIS BODY) FALLS BETWEEN THE TOP ROW SPECIFIED
;		IN THE FIRST BYTE AND THE BOTTOM ROW SPECIFIED IN THE 
;		SECOND BYTE.  SOME OF THE REMAINING BYTES ARE PASSED TO
;		YOUR MOVEMENT CODE IN KUNGTAB.ASM TO DECIDE WHAT THIS
;		COMMAND IS SUPPOSED TO DO.  SOME EQUATES HAVE BEEN
;		DEFINED FOR THE FIRST OF THE PASSED BYTES IN ORDER TO
;		ESTABLISH A STANDARD FOR DOORS OR CLIMBING BUT ACTUALLY
;		YOU CAN USE ANY VALUE FROM 0-255 FOR EITHER OF THE COMMAND
;		BYTES AND YOUR CODE CAN DECIDE BASED ON THE VALUE OR
;		ON THE EQUATES PROVIDED.  
;
;		YOU CAN TEST IN YOUR CODE TO SEE IF THE UP OR DOWN ARROW
;		KEY HAS BEEN PRESSED.  THE STATE MACHINE WILL RE-REPORT
;		THE COLUMN TO YOU IF THE UP OR DOWN KEY IS PRESSED WHILE YOU
;		ARE ON THE COLUMN EVEN IF THE COLUMN HAS ALREADY BEEN
;		REPORTED.  THIS IS DONE SO YOU CAN HAVE PIPES LIKE IN
;		SUPER MARIO OR CAN HAVE DOORS THAT YOU HAVE TO PRESS UP
;		TO GO INTO.  BUT FOR THIS TYPE OF USAGE ITS BEST TO USE
;		THE QUALIFYING BYTE FIELDS TO KEEP THE COMMAND FROM BEING
;		REPORTED IF THE CORRECT KEYS ARE NOT PRESSED.  OTHERWISE
;		YOU HERO WILL "STAGGER" AS HE RUNS OVER THE COMMANDS  AND USES
;		UP PROCESSOR POWER ONLY TO DECIDE THE UP KEY WAS NOT PRESSED.
;		IF YOU USE THE QUALIFYING BYTES HERE'S HOW THEY WORK:  THE
;		"AND" MASK IS ANDED TO THE JOYSTICK BITS AS USED IN THE
;		<BUTTON> COMMAND DESCRIBED IN KUNGTAB.  THEN THE RESULTING
;		VALUE IS COMPARED TO THE MATCH VALUE.  THE COMMAND IS ONLY
;		REPORTED IF THERE IS A MATCH.  SET BOTH TO 0 TO DISABLE THIS
;		FUNCTION.

;
;		HERE IS THE FULL COMMAND FORMAT:
;		 1 BYTE TOP TILE (PIXELS\8) ROW (1 ORIGIN!)
;		 1 BYTE BOTTOM ROW (1 ORIGIN!)
;		 1 BYTE TO PASS TO THE MOVEMENT CODE AS PARAM1 (WORLDCMD).
;		 1 BYTE TO PASS TO THE MOVEMENT CODE AS PARAM2.
;		 1 BYTE JOYSTICK BITS TO MATCH (IF ENTITY IS ATTACHED TO
;			A JOYSTICK).   USE 0 TO DISABLE THIS FUNCTION.
;		 1 BYTE AND MASK TO APPLY TO JOYSTICK BITS BEFORE COMPARING
;			TO THE MATCH VALUE.  USE 0 TO DISABLE THIS FUNCTION.
;


;F0 = LAUNCH ENTITY.  
;		          THIS COMMAND WILL LAUNCH THE ENEMY TYPE YOU SPECIFY
;			  FROM THE LOCATION YOU SPECIFY.  IT IS ILLEGAL
;			  TO LAUNCH AN ENEMY FROM COLUMN 65535.
;
;	             	BYTE 1 = ENEMY NUMBER FROM ENTITYTAB
;			BYTE 2 = TEXT ROW TO LAUNCH FROM (USES TEXT COL
;			  	 OF COMMAND LOCATION).
;			BYTE 3 = PLACED INTO PARAM2 OF THE ENTITY. NOTE:
;				 ENTITIES LAUNCHED FROM OTHER ENTITIES HAVE
;				 -1 PLACED HERE SINCE THERE IS NO BYTE 3.
;			BYTE 4 = -1 TO LAUNCH ENTITY IMMEDIATLY WHEN HIS
;				 LAUNCH COLUMN COMES FULLY ONTO SCREEN.
;				 ANY OTHER VALUE IS THE COLUMN ON SCREEN
;			         TO LAUNCH HIM FROM WHEN HIS ORIGIN COLUMN
;				 REACHES THAT POINT.  FOR EXAMPLE, SET THIS
;				 TO 16.  THEN AS THE WORLD SCROLLS HE WILL
;				 POP UP IN THE CENTER OF THE SCREEN.  WHILE
;				 WAITING TO COME TO THE CORRECT POINT HE WILL
;				 BE IN "SLEEP" MODE.  THIS MODE TAKES UP
;				 AN ENTITY SLOT BUT THE ENTITY ITSELF DOES
;				 NOT EXECUTE CODE AND IS NOT VISIBLE.
;			BYTE 5 = PERMANENT MEMORY INDEX TO USE FOR THIS ENTITY.
;				 USED IN CONJUNCTION WITH THE ENMEMORY
;				 COMMAND.  SET THIS TO -1 TO LAUNCH THE 
;				 ENTITY EVERYTIME THE COMMAND SCROLLS INTO
;				 THE LAUNCH POINT.  SET TO ANY OTHER VALUE
;				 TO LAUNCH THIS ENTITY ONLY IF IT HAS NOT
;				 PREVIOUSLY BEEN KILLED.  THIS ALLOWS UP TO
;				 255 PERMANENT MEMORY ENEMIES WHO ONCE DEAD
;				 WILL NOT COME BACK.  SEE COMMAND <ENMEMORY>. 
;
;			UP TO 16 ENEMIES CAN BE LAUNCHED AT THE SAME TIME.
;			IF ALL ENEMIES ARE ALREADY ACTIVE, 
;			THIS COMMAND IS IGNORED.  
;
;F1 = LEFT WORLD LIMIT.	
;
;	WHEN THIS COMMAND IS SCROLLED INTO THE LEFTMOST SCREEN POSITION,
;	NO FURTHER LEFTWARDS SCROLLING WILL BE POSSIBLE IF THIS COMMAND
;	IS ENCOUNTERED SCROLLING LEFT.

;	THIS COMMAND IS PLACED ON THE ACTUAL BACKGROUND COLUMN AT WHICH
;	YOU WANT LEFTWARDS SCROLLING TO STOP.  IT "STICKS" TO THE LEFT
;	OF THE SCREEN WHEN HIT AND WILL NOT MOVE INTO A RIGHTWARDS 
;	VIEWABLE SCREEN POSITION (BUT THE SCROLLING TO THE RIGHT WILL NOT
;	BE AFFECTED). THE REMAINING 3 BYTES OF THIS COMMAND ARE UNUSED.
;
;F2 = RIGHT WORLD LIMIT
;
;	THIS COMMAND FUNCTIONS LIKE THE LEFT WORLD LIMIT COMMAND EXCEPT
;	THAT IT PREVENTS RIGHTWARDS MOVEMENT. THE REMAINING 3 BYTES OF 
;	THIS COMMAND ARE UNUSED.

;F3 = CONDITIONAL LEFT WORLD LIMIT
;
;	THIS COMMAND FUNCTIONS THE SAME AS F1 EXCEPT THAT THE SCREEN SCROLL
;	IS STOPPED LEFTWARDS ONLY IF ENTITIES MARKED AS MUST DEFEAT 
;	(BIT 04 IN ENTITYTAB FLAG BITS) ARE STILL ALIVE (ON SCREEN).

;F4 = CONDITIONAL RIGHT WORLD LIMIT
;
;	THIS COMMAND FUNCTIONS THE SAME AS F2 EXCEPT THAT THE SCREEN SCROLL
;	IS STOPPED LEFTWARDS ONLY IF ENTITIES MARKED AS MUST DEFEAT 
;	(BIT 04 IN ENTITYTAB FLAG BITS) ARE STILL ALIVE (ON SCREEN).
;
;


;TOP LEGAL USAGE = ECNT*50.  AFTER THAT YOU MUST MOVE THE EBASE EQUATE DOWN.

;***************** USER WRITTEN BOOT CODE ********************
;
USER_BOOT:
	LDA	#0
	STA	BPAUSE		
	STA	ENABLE_SELECT	;DISALLOW THE DEBUG WORLD SELECT FEATURE
	STA	PAUSEFLG	;DISABLE PAUSE
	STA	SCROLLFLG
	STA	SILENCEIT
	STA	SPECGOTO
	STA	CHEATMODE
	STA	STATLEN
	STA	NEEDCOL

	LDA	#CLOCKPHASE
	STA	CLOCKP		;SET USER MODIFIABLE CLOCK PHASE
	STA	TIMETICK	;INITIALIZE THE COUNTER FOR NMI.

	LDA	#-1
	STA	WORLD_REQUEST	;REQUEST WORLD 0
	STA	SAVEDWORLD	;RESET STATREQUEST
	STA	RESETFLG	;SET RESET TRUE
	STA	RNDPTR		;SET RANDOM NUMBER POINTER
	JSR	SEEDRANDOM

	LDA	DEFTOPSTAT
	STA	DATA1
	LDA	DEFTOPSTAT+1
	STA	DATA2
	LDA	DEFTOPSTAT+2
	STA	DATA3
	LDA	DEFTOPSTAT+3
	STA	DATA4	
	JMP	INITSTAT

;***************** USER WRITTEN NON-NMI CODE *****************
;
;WE CHANGE WORLDS, SCROLL, AND MOVE ENTITIES HERE.  THIS ACCOUNTS FOR 
;VIRTUALLY ALL OF THE STATE MACHINE LOGIC.  

USER_MAINLINE:

	LDA	WORLD_REQUEST		;WORLD CHANGE REQUEST?
	BNE	UM10
	JMP	REAL_WORLD		;IF NOT, DO THE WORLD PROCESSING CODE

;WORLD CHANGE REQUEST.  THERE ARE 2 TYPES.  -1 = BOOT SCREEN.
;1-FE MEANS NEW WORLD.  

;FIRST KILL ANY OLD STUFF LYING AROUND.

UM10: 	JSR	CLEAR_BOTH	;CLEAR BOTH SCREEN BUFFERS AND DISABLE NMI

	JSR	INSTAT		;IF STATREQUEST IN PROGRESS, DON'T KILL
	BNE	UM15		;HIDDEN SPRITES

	LDA	SPECGOTO	;SEE IF SPECIAL WORLDGOTO
	BEQ	UM20
	JSR	NONJOYGONE	;ITS WORLDGOTO. REMOVE ALL BUT JOYSTICK ONES
	JMP	UM25

UM15: 	LDA	#-1
	STA	JOYENEMY
	STA	JOYENEMY+1	;FREE UP THE JOYSTICKS IN CASE NOT RETURN
	LDA	SPECGOTO
	BEQ	UM15A		;UNLESS WE ARE RETURNING, DON'T RESTORE STICKS
	LDA	SAVEJOY		;ITS A RETURN FROM A STATUS SCREEN WORLD
	STA	JOYENEMY
	LDA	SAVEJOY+1
	STA	JOYENEMY+1	;RESTORE WHO HAS THE JOYSTICKS

	LDA	SAVESEL
	STA	SELKEY
	LDA	SAVESEL+1	
	STA	SELKEY+1	;RESTORE WHAT SELECT DOES

UM15A:	LDA	#ECNT-1
	STA	SAFEBYTE
UM16: 	LDX	SAFEBYTE
	JSR	HIDDEN		;SEE IF A HIDDEN ENTITY
	BNE	UM17		;IF SO, JUST RESTORE IT
	JSR	ENEMYGONE	;IF NOT, KILL IT
	JMP	UM18

UM17: 	LDA	SPECGOTO
	BEQ	UM18		;DON'T UNHIDE UNLESS RETURN
	LDA	ENEMYJSTAT,X
	EOR	#$20
	STA	ENEMYJSTAT,X	;IF HIDDEN, JUST LET NMI SHOW IT
UM18:	DEC	SAFEBYTE
	BPL	UM16
	JMP	UM25

UM20: 	JSR	KILLALL		;KILL ALL SPRITES IMMEDIATLY UNLESS STAT WORLD
	JSR	HIDEONLY	;FOR ERROR RECOVERY, ALSO USE FULL ERASE

	LDA	#-1
	STA	JOYENEMY
	STA	JOYENEMY+1	;FREE UP THE JOYSTICKS
	LDX	#0
UM22:	STA	ENEMY0,X	;MARK ALL ENEMIES AS UNUSED
	INX
	CPX	#ECNT
	BNE	UM22

UM25:	LDA	SILENCEIT
	BEQ	UM11
	JSR	ALLSILENCE
	LDA	#0
	STA	SILENCEIT

UM11:	LDA	WORLD_REQUEST				      
	STA	CURWORLD	;SET THIS TO THE CURRENT WORLD
	CMP	#-1		;BUT BOOT SCREEN IS SPECIAL CASE
	BNE	UM100
	LDA	#0
	STA	CURWORLD	;IF BOOT SCREEN, SET TO WORLD 0.

;********************************************************************	
;ITS A WORLD INIT.  THIS ALWAYS WORKS THE SAME EXCEPT IN ONE CASE.  IF
;THE WORLDGOTO COMMAND WAS USED WE NEED TO NOT TAKE OUT JOYSTICK SPRITES AND
;WE NEED TO IGNORE THE NORMAL LEFTMOST SCREEN POSITION INFO.

UM100:	ASL	A
	STA	WORLD_INDX	;SAVE AS USEABLE INDEX

;INITIALIZE THE PALETTES AND CHARACTER SETS

	JSR	INIT_SETS

;PUT UP THE APPROPRIATE BACKGROUND.

	LDA	LEFTCOL+1
	STA	XBACK+1
	LDA	LEFTCOL		;IF SPECIAL GOTO WORLD, THIS IS THE LEFT
	STA	XBACK
	LDA	SPECGOTO
	BNE	UM110

.ifdef NOLEFT;IFDEF( `NOLEFT', `	 	;SEE IF WE HAVE A STARTING X POSITION
	STA	XBACK		;USE ZERO WE MADE ABOVE AND JUST START THERE
	STA	XBACK+1
.endif;	', `
.ifndef NOLEFT
	LDX	WORLD_INDX
	LDA	START_BACK,X	;GET THE STARTING OFFSET IN THIS WORLD
	STA	XBACK
	LDA	START_BACK+1,X
	STA	XBACK+1
.endif ;' )

UM110:	ASL	XBACK
	ROL	XBACK+1
	ASL	XBACK
	ROL	XBACK+1
	ASL	XBACK
	ROL	XBACK+1		;MAKE STARTING COLUMN INTO PIXEL COLUMN

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	TOPROW
	STA	YBACK
	LDA	SPECGOTO
	BNE	UM112

	LDX	CURWORLD
	LDA	START_TOP,X	;GET THE STARTING OFFSET IN THIS WORLD
	STA	YBACK
UM112:	LDA	#0
	STA	YBACK+1

	ASL	YBACK
	ROL	YBACK+1
	ASL	YBACK
	ROL	YBACK+1
	ASL	YBACK
	ROL	YBACK+1		;MAKE STARTING COLUMN INTO PIXEL COLUMN
.endif
.ifndef BLOCKMODE;	', `
	LDA	#0
	STA	YBACK		;IF NOT BLOCK MODE, JUST ZERO Y SCROLL
	STA	YBACK+1
.endif;	')

	LDX	WORLD_INDX
	LDY	USE_BACK+1,X	;GET HIGH BYTE OF WORLD TO USE
	LDA	USE_BACK,X	;GET LOW
	TAX			;PUT WHERE NEEDED
	JSR	INITBACK
	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN

	LDA	SPECGOTO
	BEQ	UM119		;IF NOT SPECIAL GOTO WORLD, NO NEED FOR CHECK
	LDA	LEFTCOL
	SEC
	SBC	STARTCOL
	STA	SUBSVAR1
	LDA	LEFTCOL+1
	SBC	STARTCOL+1	;SEE IF THE LEFTMOST COLUMN WORKED OUT
	BNE	UM111
	LDA	SUBSVAR1
	BNE	UM111

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	TOPROW
	SEC
	SBC	STARTROW
	STA	SUBSVAR2	;MAKE DIFFERENCE ON Y FROM WHAT WE WANTED
	BNE	UM111
	.endif ;' )

	JMP	UM119	

;THE REQUESTED LEFTMOST COLUMN OR TOPMOST ROW DIDN'T WORK.  IT WAS TOO FAR 
;RIGHT OR TOO FAR DOWN FOR THIS BACKGROUND.  SUBTRACT THE DIFFERENCE 
;FROM THE ENTITIES X AND Y LOCATIONS.

UM111:	LDA	SUBSVAR1
	JSR	TIMES8		;MAKE DISTANCE WE WERE TOO FAR RIGHT
	STA	SUBSVAR1	;SAVE IT HERE

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET
	LDA	SUBSVAR2
	JSR	TIMES8
	STA	SUBSVAR2 
	.endif ;' )

	LDX	JOYENEMY
	JSR	ADJUSTX
	LDX	JOYENEMY+1
	JSR	ADJUSTX	
	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN

UM119: 	LDX	WORLD_INDX
	LDA	USE_TABLE,X
	STA	TABLEPTR
	LDA	USE_TABLE+1,X
	STA	TABLEPTR+1	;SET POINTER FOR WORLD TO USE.  POINT TO 0.

;RESET THE STATE MACHINE AND SPECIAL FUNCTION FLAGS.

	LDA	#0
	STA	BPAUSE		;UNPAUSE THE GAME
	STA	GLOBAL_XSCR	
	STA	HALFXLOST
	STA	QUARTERXLOST

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		
	STA	GLOBAL_YSCR	
	STA	HALFYLOST
	STA	QUARTERYLOST
	.endif ;' )

	STA	STATLEN
	STA	NEEDCOL
	STA	PHASE4

;DONE.

	LDA	SPECGOTO	;SEE IF POTENTIAL ENDREQUEST WORLD
	BEQ	UM509		

	LDA	#0
	STA	SPECGOTO	;RESET THIS FLAG IF SET

	JSR	INSTAT		;IF ENDREQUEST, THIS IS SET
	BEQ	UM509
	LDA	#-1
	STA	SAVEDWORLD	;RESET IT
	JMP	UM510		;AND DON'T SCAN FLAGS AT THE NEW WORLD

UM509: 	JSR	SCANFLAGS	;SCAN FOR ENEMIES TO LAUNCH

UM510:	LDA	#0
	STA	WORLD_REQUEST	;FREE UP THE WORLD TO START RUNNING

	JSR	RESUME_NMI	;ENABLE NMI SINCE WE STOPPED IT
	RTS

ADJUSTX:			;A DEDICATED SUB FOR SPECGOTO LOGIC.
	CPX	#-1
	BEQ	AX10
	JSR	XINVALID
	BEQ	AX10
	LDA	ENEMYX,X
	SEC
	SBC	SUBSVAR1
	STA	ENEMYX,X

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET
	LDA	ENEMYY,X
	SEC
	SBC	SUBSVAR2
	STA	ENEMYY,X 
	.endif ;' )

AX10:	RTS

;THIS SUB WILL TAKE AN X PIXEL LOCATION FOR A SPRITE AND MAKE A COLUMN
;POSITION WITHIN THE BACKGROUND.  IT USES SAFEWORD.  
;X POSITION IN A ON ENTRY, THE RESULT IS IN Y:X ON EXIT.  

FIND_COL:
	CLC
	ADC	XBACK		;ADD LOW PIXELS OF SCROLL
	STA	SAFEWORD
	LDA	XBACK+1
	ADC	#0		;MAKE 2 BYTE LOCATION IN BUFFER
	LSR	A
	ROR	SAFEWORD
	LSR	A
	ROR	SAFEWORD
	LSR	A
	ROR	SAFEWORD	;MAKE COLUMN ON SCREEN

	LDX	SAFEWORD
	TAY
	RTS

;THIS SUB WILL TURN A INTO A PIXEL VALUE FROM A TEXT VALUE (*8)

TIMES8:	ASL	A
	ASL	A
	ASL	A
	RTS

;THESE SUBS WILL DIVIDE A BY 8 AND 16.

DIV16:	LSR	A
DIV8:	LSR	A
	LSR	A
	LSR	A
	RTS

;THIS ROUTINE WILL SELECT THE CHARACTER SETS AND PALETTES FOR THE WORLD
;SPECIFIED IN CURWORLD AND WORLD_INDX

INIT_SETS:
	LDX	CURWORLD
	LDA	USE_BCHRS,X
	PHA
	AND	#1
	ASL	A
	ASL	A
	ASL	A
	ASL	A		;GET UPPER/LOWER SET BIT INTO REG2000 POSITION
	ORA	#8		;AND WE ALWAYS USE UPPER FOR SPRITES
	STA	BACKBITS
	PLA	
	ROL	A
	ROL	A
	ROL	A		;MOVE SET # UP INTO VIDEO SET NIBBLE
	AND	#$F0		;KEEP ONLY VIDEO BITS
	PHA
	JSR	MAKEBANK	;MAKE THE BANK AND INDEX TO USE
	STA	BACKBANK	;SET THE BANK TO USE
	STX	BACKINDX
	PLA			;GET BACK THE BANK
	ORA	#1		;MAKE ROM PAGE #1 SELECT
	JSR	MAKEBANK
	STA	ALTBANK
	STX	ALTINDX

	JSR	WORLD_BPAL

;THIS SUB WILL ACTIVATE THE WORLD'S SPRITE PALETTE

WORLD_SPAL:
	LDX	WORLD_INDX
	LDY	USE_SPAL+1,X
	LDA	USE_SPAL,X
	TAX			;POINT TO THE SPRITE PALETTE TO USE
	JSR	SPRITEPAL
	RTS

;THIS SUB WILL ACTIVATE THE WORLD'S BACKGROUND PALETTE

WORLD_BPAL:
	LDX	WORLD_INDX
	LDY	USE_BPAL+1,X
	LDA	USE_BPAL,X
	TAX			;POINT TO THE BACKGROUND PALETTE TO USE
	JSR	BACKPAL
	RTS

;THIS ROUTINE WILL DISABLE NMI AND VIDEO AND CLEAR BOTH SCREEN PAGES'S
;BY FILLING WITH ERASECHAR.  IT DOESNT CHANGE THE PALETTE BYTES IN THE SCREEN
;BUFFER.

;ON RETURN, VIDEO AND NMI ARE STILL DISABLED.

CLEAR_BOTH:
	JSR	ALLOW_WRITES	;DISABLE NMI AS SPECIFIED BY BACKPAL

	LDY	#$20		;ADDRESS Y

	JSR	FSTR10		;SHARE THE CODE

	LDY	#$24

FSTR10:
	LDX	#0

	LDA	$2002
	STY	$2006
	STX	$2006		;ADDRESS AS REQUESTED.

	LDX	#240		
	LDA	#ERASECHAR

FOURSTORE:
	STA	$2007
	STA	$2007
	STA	$2007
	STA	$2007
	DEX
	BNE	FOURSTORE
	RTS

;********* IN A REAL WORLD.  KEEP ALL ENTITIES MOVING. *******
;WE WAIT FOR THE FLAG "PHASE4" TO BECOME TRUE INDICATING WE NEED
;TO MOVE THE ENTITIES.  THIS GIVES US A STEADY FREQUENCY OF MOVEMENT.

REAL_WORLD:

 	LDA	BPAUSE
	BNE	RWL0
	LDA	PHASE4
	AND	#1
	BNE	RWL10
RWL0:	RTS

;ITS ANOTHER CLOCK PHASE.  WE HAVE TO ROTATE THE SPRITES NOW IF WE WANT
;TO DO THAT BECAUSE BOTH THE LOW LEVEL AND THE HIGH ARE NOT DISTURBING
;THEM RIGHT NOW AND WE HAVE OUR CHANCE.

RWL10:	JSR	ROTATE

	DEC	PHASE4		;ALLOW LOW LEVEL BACK IN

;MAKE THE BACKGROUND SCROLL ADJUSTMENT

	JSR	CHECKSCROLL	;MAKE GLOBAL_XSCR FOR ENTITIES

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `
	JSR	CHECKYSCROLL	;MAKE GLOBAL_YSCR FOR ENTITIES
.endif ;' )

;APPLY IT TO THE BACKGROUND.  

	JSR	APPLYSCROLL

;APPLY IT TO THE ENEMIES

	JSR	APPLYENEMIES

	LDA	GLOBAL_XSCR
	BEQ	ASX10
	JSR	SCRLX
ASX10:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		
	LDA	GLOBAL_YSCR
	BEQ	ASX20
	JSR	SCRLY
ASX20:
.endif ;' )

;MOVE THE ENTITIES TO THEIR CURRENT LOCATION

	JSR	PUTENEMIES

;SEE IF WE NEED TO TEST A NEW WORLD COLUMN ON THE RIGHT OR LEFT

	LDA	NEEDCOL		;SEE IF WE NOW NEED A SCREEN FLAGS TEST
	BEQ	RWL150
	LDA	NMICOL
	STA	TESTCOL
	LDA	NMICOL+1
	STA	TESTCOL+1
	JSR	SCREENFLAGS	;NOW WE CAN CHECK THE COLUMN WE NEEDED
	LDA	#0
	STA	NEEDCOL

;MOVE ENTITIES.

RWL150:	LDA	#0
	STA	SAFEBYTE	;SET ENEMY TO MOVE TO 0
RWL200:	JSR	MOVEENEMY	;MOVE THIS ONE
	LDA	WORLD_REQUEST	;SEE IF THIS ENTITY WANTED A NEW WORLD
	BNE	RWL300		;IF SO, END THE LOOP
	LDA	PHASE4		;SEE IF WE GOT BEHIND
	BEQ	RWL201
	ORA	#$80
	STA	PHASE4		;IF SO, SET FLAG TO NOT EXECUTE LOW PRIORITYS
RWL201:	INC	SAFEBYTE	;GO TO NEXT
	LDA	SAFEBYTE
	CMP	#ECNT
	BCC	RWL200		;MOVE ALL OF THEM

	LDA	PHASE4		;SEE IF WE GOT BEHIND
	AND	#$7F
	BNE	RWL300
	STA	PHASE4		;RESET GOT BEHIND BIT

RWL300:	RTS

;MOVE ALL ENTITIES TO THEIR CURRENT LOCATION.   

PUTENEMIES:
	LDX	#0
PUE120:	LDA	ENEMY0,X	
	CMP	#-1		;INVALID?
	BEQ	PUE121
	LDA	ENEMYSTAT,X
	BMI	PUE121		;IF SLEEPING, DON'T TRY TO DO A PUT.
	LDA	ENEMYJSTAT,X	;SEE IF HIDDEN FROM SOME WORLD
	AND	#$20
	BNE	PUE121
	STX	SAFEBYTE	;SAVE IT FOR RESTORE
	LDA	ENEMYY,X	;GET ENEMIES Y LOCATION
	TAY
	LDA	ENEMYX,X
	TAX
	LDA	SAFEBYTE	;GET SLOT NUMBER IN A
	JSR	PUTSPRT		;PUT IT DOWN.
	LDX	SAFEBYTE
PUE121:	INX			;GO TO NEXT
	CPX	#ECNT
	BNE	PUE120		;MOVE ALL OF THEM
	RTS

;THIS ROUTINE WILL APPLY GLOBAL_XSCR AND _YSCR TO THE ENEMIES.

APPLYENEMIES:
	LDX	#0
	LDA	GLOBAL_XSCR

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `	
	ORA	GLOBAL_YSCR
.endif ;' )

	BEQ	RWL110
RWL100:	TXA
	PHA
	JSR	SCROLLENEMY	;MOVE THIS ONE SCROLL WISE
	PLA
	TAX
	INX			;GO TO NEXT
	CPX	#ECNT
	BNE	RWL100		;MOVE ALL OF THEM
	
RWL110:	RTS

;THIS ROUTINE WILL APPLY GLOBAL_XSCR AND _YSCR TO THE BACKGROUND.
;IT DOES NOT CALL SCRLX OR SCRLY, THESE ARE CALLED FROM THE INTERRUPT
;ROUTINE AT THE BEST POSSIBLE TIME FOR VISUAL PURPOSES.

APPLYSCROLL:
	LDA	GLOBAL_XSCR	;GET RESULT
.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `	
	ORA	GLOBAL_YSCR
.endif ;' )
	BNE	RX14
	JMP	RX50
RX14:	LDA	#0
	STA	SUBSVAR2	;ZERO HIGH BYTE FOR + SCROLL

	LDA	GLOBAL_XSCR	

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `	
	BEQ	YX10		;IF WE HAVE Y SCROLL, WAS X CHANGED?
.endif ;' )

	JSR	NEGATE		;SCREEN SCROLL IS OPPOSITE OF ENTITY!
	STA	SUBSVAR1
	BPL	RX15
	LDA	#-1
	STA	SUBSVAR2	;MAKE FULL NEGATIVE RESULT
	
RX15:	CLC
	LDA	XBACK
	ADC	SUBSVAR1
	STA	XBACK
	LDA	XBACK+1
	ADC	SUBSVAR2
	STA	XBACK+1		;UPDATE SCREEN SCROLL

RX16:	LDA	STARTCOL	;SAVE CURRENT STARTING COLUMN
	STA	SUBSVAR1
	LDA	STARTCOL+1
	STA	SUBSVAR2
 	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN
	LDA	STARTCOL
	SEC
	SBC	SUBSVAR1
	STA	SUBSVAR1	;SAVE LOW BYTE OF RESULT
	LDA	STARTCOL+1
	SBC	SUBSVAR2	;DO A WORD COMPARE TO SEE IF NEW COLUMN
	BCC	RX30		;SKIP IF SMALLER (SCROLLED LEFT)
	BNE	RX20
	LDA	SUBSVAR1	;IF EQUAL, SEE IF WHOLE WORD EQUAL
	BEQ	RX45

RX20:	LDA	STARTCOL
	CLC
	ADC	#31		;TEST THE LAST COLUMN IF WE SCROLLED RIGHT
	STA	NMICOL
	LDA	STARTCOL+1
	ADC	#0
	STA	NMICOL+1
	JMP	RX40

RX30:	LDA	STARTCOL
	STA	NMICOL
	LDA	STARTCOL+1
	STA	NMICOL+1
RX40: 	LDA	#-1
	STA	NEEDCOL		;SO JUST SET A FLAG TO DO IT AFTERWARDS.
RX45:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `	
     	
YX10:	LDA	#0
	STA	SUBSVAR2	;ZERO HIGH BYTE FOR + SCROLL
	LDA	GLOBAL_YSCR	;IF WE HAVE Y SCROLL, WAS Y CHANGED?
	BEQ	RX50
	JSR	NEGATE		;SCREEN SCROLL IS OPPOSITE OF ENTITY!
	STA	SUBSVAR1
	BPL	YX15
	LDA	#-1
	STA	SUBSVAR2	;MAKE FULL NEGATIVE RESULT
	LDA	YBACK+1		;IF GOING NEGATIVE, IS TOP BYTE 0?
	BNE	YX15
	LDA	YBACK		;IF SO, MAKE SURE NOT GOING BELOW 0
	CMP	GLOBAL_YSCR
	BCS	YX15		;IF YBACK IS BIGGER, ITS OK
	LDA	YBACK
	STA	GLOBAL_YSCR	;SET TO MAX ALLOWED.
	LDA	#0
	STA	YBACK		;OTHERWISE, WE ONLY GO TO ZERO
	JMP	YX16
	
YX15: 	CLC
	LDA	YBACK
	ADC	SUBSVAR1
	STA	YBACK
	LDA	YBACK+1
	ADC	SUBSVAR2
	STA	YBACK+1		;UPDATE SCREEN SCROLL

YX16:  	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN AND ROW
.endif ;' )

RX50:	RTS

;***************** WORLD COLUMN COMMAND TESTING LOGIC ****************
;
;THE WORLD COLUMN COMMANDS ARE TESTED WHEN A NEW SCREEN COLUMN COMES
;ONTO THE SCREEN OR WHEN AN ENTITY DESIGNATED TO TEST SCREEN
;COMMANDS MOVES ONTO A NEW COLUMN OR ROW.  ALSO, WHEN AN ENTITY
;PUSHES THE UP OR DOWN KEY ON A COLUMN IT WILL BE TESTED AGAIN.
;********************************************************************

;THIS ROUTINE WILL SCAN ALL COMMANDS PRESENTLY ON SCREEN AND LOOK FOR
;LAUNCH ENEMY COMMANDS.  IT CHANGES SAFEBYTE!

SCANFLAGS:
	LDA	#0
SCF10: 	PHA			;SAVE THE ONE WE ARE TESTING
	CLC
	ADC	STARTCOL
	STA	TESTCOL
	LDA	STARTCOL+1
	ADC	#0
	STA	TESTCOL+1
	JSR	SCREENFLAGS	;DO THIS FLAG
	PLA
	TAX			;GET BACK INDEX
	INX			;GO TO NEXT SCREEN COLUMN
	TXA
	CMP	#32		;DONE WITH 32 OF THEM?
	BNE	SCF10
	RTS	

;THIS ROUTINE TESTS FOR ENTITY LAUNCH COMMANDS WHEN A COLUMN ON
;SCREEN IS SCROLLED ONTO.  TESTCOL SHOULD HAVE THE SCREEN COLUMN YOU WANT TO
;TEST.    IT CHANGES SAFEBYTE!

SCREENFLAGS:
	LDA	TESTCOL
	STA	WORLDCOL
	LDA	TESTCOL+1
	STA	WORLDCOL+1	;SAVE COLUMN
	JSR	SEEKCMD
	CMP	#$F0		;LAUNCH ENTITY?
	BNE	SFG20
	JSR	BF20
SFG20:	RTS

BF20: 	JSR	NOTLAUNCHED	;LAUNCH ENTITY MAKE SURE NOT ALREADY GOING
	JSR	FINDFREE 	;TRY TO FIND ONE
	BNE	SFG20		;DONE IF NONE.
	
;AN ENEMY SLOT IS AVAILABLE.  INITIALIZE ALL OF ITS FLAGS.

BF2010: STX	SAFEBYTE	;SAVE ENEMY INDEX HERE FOR LATER USE
	LDA	WORLDCOL
	STA	ENEMYLCOL,X	;SET THE ORIGIN OF THIS LAUNCH 
	LDA	WORLDCOL+1
	STA	ENEMYHCOL,X

;MAKE THE BACKGROUND LOCATION TO LAUNCH FROM

	LDA	WORLDCOL
	STA	SAFEWORD
	LDA	WORLDCOL+1
	STA	SAFEWORD+1
	LDY	BYTE2
 
	JSR	VISUAL_POINT	;MAKE LOCATION TO LAUNCH FROM
	BCC	BF2012		;SKIP IF LOCATION FULLY ON SCREEN
       	LDA	BYTE4		;IF NOT FULLY ON, IS IT A SLEEPER?
	CMP	#-1
	BNE	BF2012		;IF IT IS, THAT WILL MAKE IT WAIT
	LDA	#-2		;SET IT TO SLEEP TILL ITS VISIBLE
	STA	BYTE4

BF2012:	TXA
	LDX	SAFEBYTE	;GET BACK INDEX
	STA	ENEMYX,X	;SET COLUMN OF LAUNCH
	TYA			;GET ROW TO USE
	STA	ENEMYY,X
	LDA	BYTE3
	STA	ENEMYP2,X	;SET PARAMETER 2 FOR TESTING

	LDY	#0		;ASSUME NOT SLEEPING
	LDA	BYTE2
	STA	ENEMYHREG,X	;SAVE Y TOO IN CASE WE HAVE TO SLEEP
	LDA	BYTE4
	STA	ENEMYLREG,X	;AND PUT HERE FOR SLEEPERS

	CMP	#-1		;SEE IF ITS NOT A SLEEPER
	BEQ	BF2011
	LDY	#$80
BF2011:	TYA
	STA	ENEMYSTAT,X	;SET SLEEPING FLAG

	LDA	BYTE5
	STA	ENEMYNUM,X	;SET THE PERMANENT MEMORY VALUE

;SET DEFAULTS AND INITIALIZE THE STRUCTURE.  ENEMY0 IS NOT SET UNTIL THE
;LAST MOMENT WHEN EVERYTHING ELSE IS VALID SO THAT WE DON'T GET INTO
;TROUBLE AT THE NMI LEVEL.  PUT THE DESIRED ENEMY0 VALUE INTO BYTE1
;VARIABLE.

FINISH_ENEMY:			;THIS ENTRY SHARED BY THE ENTITY COMMAND 1F.
	LDX	SAFEBYTE	;OTHER USERS MUST SET UP SAME STUFF AS BF20

	LDA	ENEMYNUM,X	;SEE IF PERMANENT MEMORY REQUEST
	CMP	#-1
	BEQ	BF2013
	JSR	MAKELIFE	;MAKE THE INDEX TO PERMENENT MEMORY
	LDX	SAFEBYTE
	AND	REMEMBER,Y	;SEE IF ITS STILL ALIVE
	BEQ	BF2013
	JMP	BF2016		;IF NOT, DON'T LAUNCH IT
BF2013:	LDA	#0		
	STA	ENEMYREQ,X	
	STA	ENEMYFCTR,X
	STA	ENEMYXMOM,X
	STA	ENEMYYMOM,X
	STA	ENEMYDELAY,X	
	STA	ENEMYCENTR,X	;ZERO THIS TO STOP CENTER CORRECTION
	STA	ENEMYHIGH,X	;MUST ZERO HEIGHT TO STOP Y ADJUSTMENT
	STA	ENEMYTLLOW,X
	STA	ENEMYTLHI,X	
	STA	ENEMYTRACK,X	
	STA	ENEMYTLLOW,X
	STA	ENEMYTLHI,X
	STA	ENEMYTRLOW,X
	STA	ENEMYTRHI,X
	STA	ENEMYCNT,X
	STA	ENEMYALT,X
	STA	ENEMYBEHAVE,X

	LDA	#-1
	STA	ENEMYINTS,X	;START WITH ALL INTERRUPTS DISABLED
	STA	ENEMYATK,X	;SET NO LAST ATTACKER
	STA	ENEMYRSH,X	;SET NO RESUME POINT
	STA	ENEMYLROW,X	;SET ROW TO FORCE COMMAND TEST
	STA	ENEMYLINK,X
	STA	ENEMYID,X	;PRESET THIS FOR HURTING DISABLED ENTITIES

	LDA	#$80
	STA	ENEMYJSTAT,X	;INITIALIZE SECONDARY STATUS BITS

 	LDA	#TRAVELING|DOWN
	STA	ENEMYFACE,X	;SET DIRECTION IT FACES

	LDA	#DEF_GRAV
	STA	ENEMYGRAV,X	;SET INITIAL GRAVITY

	LDA	#DEF_XLIM
	STA	ENEMYXLIM,X
	LDA	#DEF_YLIM
	STA	ENEMYYLIM,X	;SET MOMENTUM LIMITS

	LDA	#DEF_XFRICT
	STA	ENEMYXFRICT,X
	LDA	#DEF_YFRICT	;SET FRICTIONS
	STA	ENEMYYFRICT,X

	LDA	#DEF_BOUNCE
	STA	ENEMYBOUNCE,X	;SET BOUNCE

	LDA	BYTE1		;GET ENEMY NUMBER
	JSR	POINTE2		;CALL POINTENEMY

	LDY	#2
	LDA	(SUBSVAR1),Y
	STA	ENEMYFLGS,X 	;GET FLAGS VALUES
	INY
	LDA	#4
	ORA	ENEMYSTAT,X
	STA	ENEMYSTAT,X	;ASSUME SOLID IS GOING TO BE ON
	LDA	(SUBSVAR1),Y
	STA	ENEMYSOLID,X	;GET SOLID VALUE
	BNE	BF2015
	LDA	ENEMYSTAT,X
	EOR	#4		;IF NO SOLID, RESET BIT
	STA	ENEMYSTAT,X       	

BF2015:	INY
	LDA	(SUBSVAR1),Y	;GET CONTROL BITS
	STA	ENEMYCTRL,X

	INY
	LDA	(SUBSVAR1),Y
	STA	ENEMYHEALTH,X	;AND HEALTH.  PRIZE WE'LL LEAVE FOR DEATH.

;ALL SET UP TO LAUNCH THIS ONE.  MAKE SURE ITS NOT ASLEEP.

	LDA	ENEMYSTAT,X
	BMI	BF2017

INIT_ENEMY:			;NEEDS BYTE1=ENEMY0 VALUE!
	JSR	PICKMOD4	;CALL OUR OWN ROUTINE TO INIT EWAKE MODE
	BEQ	BF2017
BF2016:	LDX	SAFEBYTE
	LDA	#-1
	STA	ENEMY0,X	;IF CAN'T INIT IT, GET RID OF IT.
	RTS
BF2017:	LDA	BYTE1		;GET ENEMY TYPE
	STA	ENEMY0,X	;SET THAT
	RTS			

;THIS SUB WILL MAKE SURE THE ENEMY THAT WOULD BE LAUNCHED BY WORLDCOL
;IS NOT ALREADY ACTIVE.  IT CHECKS ENEMY COLUMN TO SEE IF THERE IS A MATCH.
;IF THERE IS, IT POPS THE RETURN ADDRESS ON THE STACK AND RETURNS.

NOTLAUNCHED:
	JSR	FINDWCOL
	BNE	NLH20
	LDA	ENEMYJSTAT,Y
	AND	#$20		;MAKE SURE NOT HIDDEN FOR STATREQUEST
	BNE	NLH20
	PLA
	PLA
NLH20:	RTS

;THIS SUBROUTINE WILL RETURN THE INDEX OF AN ENTITY SPECIFIED BY LAUNCHING
;WORLD COLUMN IN WORLDCOL.  IN RETURN, IF Z THEN Y=INDEX.  IF NZ THEN
;THAT ENTITY IS NOT LAUNCHED.

FINDWCOL:
	LDY	#ECNT-1
FNDWC0:	JSR	VALID		;MAKE SURE ITS VALID
	BEQ	FNDWC5
	LDA	ENEMYLCOL,Y
	CMP	WORLDCOL	;THIS ONE MATCHES?
	BNE	FNDWC5
	LDA	ENEMYHCOL,Y
	CMP	WORLDCOL+1
	BEQ	FNDWC9
FNDWC5:	DEY
	BPL	FNDWC0
	LDA	#-1		;IF WE CAN'T FIND IT, RETURN NZ.
FNDWC9:	RTS

;THIS SUB WILL FIND AN AVAILABLE ENEMY AND RETURN THE INDEX IN X.  IF NONE
;IS AVAILABLE IT RETURNS NZ, ELSE Z.  SAFEBYTE IS NOT USED.  IF IT
;NEEDS TO REMOVE A LOW PRIORITY ENTITY TO FIND A SLOT, IT WILL.

FINDFREE:
	LDY	#-1		;FLAG NO LOW PRIORITY SLOT TO USE
	LDX	#0
FEN10:	LDA	ENEMY0,X
	CMP	#-1
	BEQ	FEN20
	LDA	ENEMYCTRL,X
	AND	#$10			;IF USED, LOW PRIORITY?
	BEQ	FEN15
      	TXA
	TAY			;SIGNAL WE FOUND A LOW PRIORITY ONE
FEN15:	INX
	CPX	#ECNT
	BNE	FEN10
	TYA
	BMI	FEN16
	PHA
	TAX		;IF WE HAVEN'T ANY, USE THIS LOW PRIORITY ONE.
	JSR	ENEMYG2	
	PLA
	TAX
	JMP	FEN20

FEN16:	RTS		;NONE AVAILABLE (Y-->A=-1)

FEN20:	LDA	#0	;X HAS THE FREE ENEMY.
	RTS

;JUMP HERE TO CHECK FOR A WORLD COMMAND THAT AN ENTITY WOULD CARE ABOUT.
;X AND SAFEBYTE SHOULD HAVE THE ENTITIES INDEX AND ENEMYLTST AND
;ENEMYHTST HIS COLUMN IN THE BACKGROUND.

TESTFLGS:
	LDA	ENEMYLTST,X	;GET COLUMN OF TEST
	STA	TESTCOL
	LDA	ENEMYHTST,X	;GET COLUMN OF TEST
	STA	TESTCOL+1
	JSR	SEEKCMD		;SEEK THE COMMAND.
	BEQ	TF10
 	CMP	#$F0		;MAKE SURE ITS IN THE RANGE FOR ENTITIES
	BCS	TF10		;ONLY 1-EF ALLOWED.

	LDX	SAFEBYTE	;GET ENTITY THAT CAME ONTO IT
	LDA	ENEMYFEET,X	;GET HIS Y
	CLC
	ADC	YBACK		;ADD BACKGROUND Y
	STA	SAFEWORD
	LDA	YBACK+1
	ADC	#0
	ROR	A
	ROR	SAFEWORD
	ROR	A
	ROR	SAFEWORD
	ROR	A
	ROR	SAFEWORD	;MAKE LAUNCH COLUMN
	LDA	SAFEWORD
	CMP	FLAGBYTE	;IS IT ABOVE THE RANGE?
	BCC	TF10
	SBC	#1		;DECREMENT IT TO CATCH EQUAL CONDITION
	CMP	BYTE1		;OR BELOW IT?
	BCS	TF10		;SKIP IF ITS OUTSIDE THE ROW RANGE

;THE ENTITY HAS STEPPED ONTO A FLAG.  REPORT IT TO HIM UNLESS THERE ARE
;QUALIFYING CONDITIONS FOR A JOYSTICK.

	LDA	#TESTING
	AND	ENEMYINTS,X
	BNE	TF10		;SKIP IF ITS NOT ENABLED
	LDA	ENEMYJSTAT,X	;SEE IF JOYSTICK ATTACHED
	BMI	TF5
	AND	#1		;GET JOYSTICK TO CHECK
	TAY
	LDA	J1FLAGS,Y	;GET CURRENT JOYSTICK STATE
	AND	BYTE5
	EOR	BYTE4		;SEE IF MATCH
	BNE	TF10

TF5:	LDA	BYTE2
	STA	ENEMYP1,X
	LDA	BYTE3
	STA	ENEMYP2,X
	LDA	#ECMD
	STA	ENEMYREQ,X	;REQUEST THE ENEMIES COMMAND SEQUENCE
TF10:	RTS			;AND ITS UP TO HIM

;THIS ROUTINE WILL SEEK IN THE COLUMN COMMAND TABLE FOR THE CURRENT
;WORLD (TABLEPTR) FOR THE COLUMN SPECIFIED IN TESTCOL (WORD). ON RETURN, IF
;Z THEN NO COMMAND WAS FOUND FOR THIS TABLE AND FLAGBYTE HAS BEEN
;SET TO 0.  IF NZ, THEN FLAGBYTE, BYTE1, BYTE2, BYTE3, BYTE4, AND
;BYTE5 HAVE BEEN  LOADED WITH THE 6 BYTES THAT MAKE THIS COMMAND.  
;REGISTER A HAS FLAGBYTE IN IT ON RETURN.

;THIS ROUTINE IS CALLED FROM BOTH NMI AND OUTSIDE NMI (PRIMARILY) INTERRUPTS.
;THIS IS OK BECAUSE THE VARIABLES WHICH ARE CHANGED ARE SAVED BY NMI.

SEEKCMD:
	JSR	SEEKCMD2	;GET THE FLAG BYTE
	BEQ	SEEK10
	LDY	#3
	LDA	(TABLEPTR),Y	;IF WE FOUND ONE, GET THE BYTES
	STA	BYTE1
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE2
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE3
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE4
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE5
	LDA	FLAGBYTE	;RESTORE NZ CONDITION
SEEK10:	RTS


;THIS VERSION OF SEEKCMD DOES NOT CHANGE BYTE1-BYTE5.  IT
;JUST RETURNS THE FLAG BYTE IN A AND IN FLAGBYTE.

SEEKCMD2:
	JSR	TESTSEEK
	BEQ	SEEK100

;NO MATCH.  SEE IF WE SHOULD GO LEFT OR RIGHT.

SEEK20:	BCS	SEEK50

;WE NEED TO MOVE TO A PREVIOUS ENTRY.

SEEK40:	JSR	PREVENTRY
	JSR	TESTSEEK
	BEQ	SEEK100
	BCC	SEEK40	
	JMP	SEEK107		;WHEN THE LESS THAN BECOMES GREATER THAN, END

;WE NEED TO MOVE TO THE NEXT ENTRY.

SEEK50:	JSR	NEXTENTRY
	JSR	TESTSEEK
	BEQ	SEEK100
	BCS	SEEK50 		;WHEN > BECOMES < THEN DONE.
	JMP	SEEK107

;FOUND A MATCH.  MAKE SURE ITS NOT THE SPECIAL CASE OF TABLE ENDS

SEEK100:
	LDY	#2		;POINT TO THE COMMAND BYTE
	LDA	(TABLEPTR),Y
	STA	FLAGBYTE
	BNE	SEEK110

;WE FOUND A MATCH BUT ITS AN END OF TABLE MARKER.

	LDA	TESTCOL			;THERE ARE 2 CASES, 0 AND 255.
	ORA	TESTCOL+1
	BNE	SEEK105
	JSR	NEXTENTRY
	JSR	TESTSEEK	;CHECK NEXT ENTRY IF START OF TABLE.
	BEQ	SEEK100		;IF NEXT IS 0 TOO, WE FOUND IT.
	JMP	SEEK107

SEEK105:	
	JSR	PREVENTRY	;BACK UP 1 IF END OF TABLE

;DONE WITH FAILURE.

SEEK107:
	LDA	#0
	STA	FLAGBYTE
	RTS

;DONE WITH SUCCESS

SEEK110:	
	LDA	FLAGBYTE
	RTS	

PREVENTRY:		;CALL HERE TO BACK TABLEPTR UP 1 ENTRY (8 BYTES)
	LDA	TABLEPTR
	SEC
	SBC	#8
	STA	TABLEPTR
	LDA	TABLEPTR+1
	SBC	#0
	STA	TABLEPTR+1
	RTS

NEXTENTRY:		;CALL HERE TO MOVE TABLEPTR FORWARD 1 ENTRY (8 BYTES)
	LDA	TABLEPTR
	CLC
	ADC	#8
	STA	TABLEPTR
	LDA	TABLEPTR+1
	ADC	#0
	STA	TABLEPTR+1
	RTS

;THIS ROUTINE WILL COMPARE TESTCOL (WORD) TO (TABLEPTR) AND SET
;FLAGS:  Z MEANS SAME
;	 CY OR NC FOR DIFFERENT.  CY IF TESTCOL>(TABLEPTR).
;
;IT HONORS SETTING BIT $8000 IN THE WORD THERE TO SIGNAL A DOUBLED
;COMMAND.   IT CHANGES FLAGBYTE AND TTT1, TTT2.

TESTSEEK:
     	JSR	TESTSK1		;CHECK FOR THE MATCH
	BEQ	TS5		;IF FOUND, USE IT
	BCC	TS5		;OR IF TESTCOL< THEN NO POSSIBLITY OF DOUBLE 
	PHP			;SAVE CONDITION FLAGS
	LDA	TTT1    	;SEE IF DOUBLE BIT
	BPL	TS4		;IF NOT, JUST RETURN THE FLAG WE HAD
	PLA
	JSR	TESTSK2
	RTS
TS4:  	PLP
TS5:	RTS


TESTSK1:
	LDY	#1		;MAKE AN INDIRECT INDEX
	LDA	(TABLEPTR),Y
	STA	TTT1    	;SET IT FOR DOUBLE BIT CHECK
	AND	#$7F
	STA	TTT2    	;SET HIGH BYTE WITHOUT BIT $80
	DEY
	LDA	TESTCOL		;GET COLUMN WE ARE LOOKING FOR
	SEC
	SBC	(TABLEPTR),Y	;SEE IF THIS IS A MATCH
	STA	FLAGBYTE	;SAVE HERE CAUSE WE CHANGE IT LATER.
	LDA	TESTCOL+1
	SBC	TTT2    	;GET THE TOP BYTE WITHOUT BIT $80
	BNE	TS20
	LDA	FLAGBYTE	;GET BACK LOW AND SET Z FLAG
TS20:	RTS

;THIS IS A COPY OF TESTSEEK THAT INCREMENTS THE WORD FOR CASES WHERE
;THE DOUBLE BIT IS SET.  IT ASSUMES THE FIXED HIGH BYTE IS ALREADY IN
;TTT2    .

TESTSK2:
	LDY	#0		;MAKE AN INDIRECT INDEX
	LDA	(TABLEPTR),Y
	CLC
	ADC	#1
	STA	TTT1    	;MAKE COPY OF THE WORD WITH +1
	LDA	TTT2    
	ADC	#0
	STA	TTT2    	;SET HIGH BYTE WITHOUT BIT $80

	LDA	TESTCOL		;GET COLUMN WE ARE LOOKING FOR
	SEC
	SBC	TTT1    	;SEE IF THIS IS A MATCH
	STA	FLAGBYTE	;SAVE HERE CAUSE WE CHANGE IT LATER.
	LDA	TESTCOL+1
	SBC	TTT2    	;GET THE TOP BYTE WITHOUT BIT $80
	BNE	TS30
	LDA	FLAGBYTE	;GET BACK LOW AND SET Z FLAG
TS30:	RTS

;THIS ROUTINE WILL TAKE AN X TEXT POSITION WITHIN THE BACKGROUND IN
;SAFEWORD AND A Y ROW POSITION IN Y AND WILL CONVERT INTO SPRITE 
;COORDINATES WITHIN THE VISUAL SCREEN.  

;ON RETURN, IF THE CARRY IS CLEAR THEN Y=PIXEL ROW AND X=PIXEL COLUMN.
;IF CARRY, THEN THE POSITION WAS OFF SCREEN AND Y AND X ARE UNDEFINED. 

VISUAL_POINT:

	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1	;MAKE *8 LOCATION

	SEC
	LDA	SAFEWORD
	SBC	XBACK
	STA	SAFEWORD
	TAX			;KEEP IN CASE X IS VALID.
	LDA	SAFEWORD+1
	SBC	XBACK+1		;MAKE POSITION RELATIVE TO CURRENT SCROLL
	STA	SAFEWORD+1
	BNE	VP20		;IF TOP BYTE NOT 0, ITS NOT GOOD.
	BCS	VP25
	
;THE POINT IS OFF SCREEN.

VP20:	SEC
	RTS

;X IS OK.  NOW MAKE Y.

VP25: 	STY	SAFEWORD

	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1	;MAKE *8 LOCATION

	SEC
	LDA	SAFEWORD
	SBC	YBACK
	STA	SAFEWORD
	TAY			;KEEP IN CASE Y IS GOOD
	LDA	SAFEWORD+1
	SBC	YBACK+1		;MAKE POSITION RELATIVE TO CURRENT SCROLL
	STA	SAFEWORD+1
	BNE	VP20		;IF TOP BYTE 0, NO GOOD.
	BCC	VP20		;AND IF ABOVE TOP, NO GOOD
	CPY	#$F0		;AND IF TOO LOW, NO GOOD
	RTS			;WILL SET CARRY IF TOO LOW

;THIS ROUTINE WILL CALCULATE THE FIRST BACKGROUND COLUMN FULLY DISPLAYED
;ON SCREEN.  IT USES ONLY XBACK AND YBACK AND IS OK TO CALL EVEN IF SCRLX
;OR SCRLY HAVE NOT BEEN CALLED FOR THE NEW VALUE.  THE VALUE IS RETURNED 
;IN STARTCOL AND STARTROW.  IT ONLY
;REPORTS A COLUMN AS THE LEFTMOST COLUMN IF PIXEL 0 OF IT IS ON THE SCREEN.

;THIS ROUTINE SHOULD ONLY BE CALLED FROM USER_NMI EXCEPT WHEN A NEW WORLD
;IS BEING INITIALIZED.

MAKE_STCOL:
	LDA	XBACK
	CLC
	ADC	#7		;MAKE SURE WE ARE ON PIXEL 0 OR LESS
	STA	STARTCOL
	LDA	XBACK+1						    
	ADC	#0
	STA	STARTCOL+1
	LSR	STARTCOL+1
	ROR	STARTCOL
	LSR	STARTCOL+1
	ROR	STARTCOL
	LSR	STARTCOL+1
	ROR	STARTCOL

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	YBACK
	CLC
	ADC	#7		;MAKE SURE WE ARE ON PIXEL 0 OR LESS
	STA	STARTROW
	LDA	YBACK+1						    
	ADC	#0
	LSR	A
	ROR	STARTROW
	LSR	A
	ROR	STARTROW
	LSR	A
	ROR	STARTROW

	.endif ;' )

	RTS

;********************* ENEMY FUNCTIONS ******************************

;ENEMIES ARE REFFERRED TO BY INDEXES OF 0 TO (ECNT-1)

;THIS SUB WILL GET RID OF THE ENEMY SAFEBYTE (INDEX) AND FREE UP ITS SLOT.

ENEMYGONE:
	LDX	SAFEBYTE
ENEMYG2:   			;CALL HERE WITH X IF SAFEBYTE INVALID
	LDA	#-1
	STA	ENEMY0,X
	TXA
	JMP	KILLSPRT	;GET RID OF IT IF SO

;THIS ROUTINE WILL MAKE ALL NON-JOYSTICK ENTITIES GO AWAY.  IT USES SAFEBYTE!

NONJOYGONE:
	LDY	#0		;START WITH ENEMY 0
NJG11:
	JSR	VALID		;SKIP IF US OR INVALID
	BEQ	NJG20
	LDA	ENEMYJSTAT,Y	;SEE IF THIS ONE HAS A JOYSTICK ATTACHED
	BPL	NJG20		;IF SO, DON'T REMOVE IT
	STY	SAFEBYTE
	JSR	ENEMYGONE
	LDY	SAFEBYTE
NJG20:	
	INY
	CPY	#ECNT
	BNE	NJG11
	RTS	

;THIS ROUTINE WILL SEARCH ACTIVE ENTITIES TO SEE IF ANY ARE MARKED AS
;MUST KILL.  IF SO, IT WILL RETURN NZ.  IF NONE, Z.  

MUSTKILL:
	LDY	#0

MKL10:	JSR	VALID
	BEQ	MLK20
	LDA	ENEMYFLGS,Y
	AND	#4
	BNE	MLK30
MLK20:	INY
	CPY	#ECNT
	BNE	MKL10
	RTS

MLK30: 	LDA	ENEMYSTAT,Y	;MAKE SURE ITS NOT ASLEEP
	BMI	MLK20
	LDA	#-1		;RETURN NZ
	RTS

;THIS ROUTINE WILL MOVE AN ENEMY.  THE ENEMY INDEX SHOULD BE IN SAFEBYTE ON
;ENTRY.  IT WILL BE RETURNED THERE.

MOVEENEMY:
	LDX	SAFEBYTE
	LDA	ENEMY0,X
	CMP	#-1		;INVALID?
	BNE	CE3
CE2:   	RTS

CE3:	JSR	HIDDEN		;HIDDEN?
	BNE	CE2

;SEE IF THE ENEMY IS EXECUTING HALF SPEED

CE5:  	LDA	ENEMYJSTAT,X
	AND	#$40		;IF HALF SPEED, THIS BIT SET
	BEQ	CE7
	TXA			;STAGGER BY ENEMY NUMBER 
	EOR	ALTPHASE
	AND	#1
	BEQ	CE7		;CATCH EVERY OTHER PHASE

;THIS ENTITY WILL NOT EXECUTE THIS CYCLE HOWEVER WE NEED TO MOVE IT
;IF ITS A LINKED ENTITY.

CE6:	LDA	ENEMYLINK,X	;LINKED ENEMY?
	BMI	CE2
	JSR	PUTLINK		;KEEP IT UP TO DATE IF SO.
	JMP	CE2

;SEE IF WE GOT BEHIND AND WE NEED TO NOT EXECUTE LOW PRIORITY ENTITIES
;EVERY OTHER CYCLE.

CE7:	LDA	PHASE4		;BIT $80 OR 01 SET MEANS WE GOT BEHIND
	BEQ	CE10
		
	LDA	ENEMYCTRL,X
	AND	#$20		;LOW EXECUTION PRIORITY?
	BEQ	CE10
 
 	LDA	ENEMYJSTAT,X
	AND	#$40		;IF HALF SPEED, THIS BIT SET
	BEQ	CE8
	TXA			;STAGGER BY ENEMY NUMBER IF NOT HALF SPEED
	EOR	ALTPHASE
	AND	#2
	BNE	CE6		;CATCH EVERY OTHER 4TH PHASE IF HALF SPEED
	JMP	CE10

CE8:	TXA			;STAGGER BY ENEMY NUMBER IF NOT HALF SPEED
	EOR	ALTPHASE
	AND	#1
	BNE	CE6		;CATCH EVERY OTHER PHASE

;CHECK IF THE ENEMY IS SLEEPING AND WAITING TO MOVE ONTO THE CORRECT
;SCREEN LOCATION.  THIS IS ALSO USED IF THE LOGIC NEEDS TO LAUNCH IT
;BUT ITS POSITION IS STILL OFF THE RIGHT OR LEFT OF THE SCREEN.  WE
;MUST NOT LAUNCH IT UNTIL ITS COLUMN PIXEL 0 IS VISIBLE ON SCREEN.

CE10:	LDA	ENEMYSTAT,X
	BPL	CE15		;BIT $80 MEANS ASLEEP

	LDA	ENEMYLCOL,X	;GET ORIGIN COLUMN
	STA	SAFEWORD
	LDA	ENEMYHCOL,X
	STA	SAFEWORD+1
	LDA	ENEMYHREG,X
	TAY			;GET Y TO BE USED

	JSR	VISUAL_POINT	;MAKE LOCATION TO LAUNCH FROM
	TXA
	LDX	SAFEBYTE	;GET BACK INDEX
	BCS	CE12		;IF NOT ON SCREEN, DON'T LAUNCH IT
	STA	ENEMYX,X	;SET LAUNCH POINT
	TYA
	STA	ENEMYY,X	;SET Y TOO
	LDA	ENEMYLREG,X	;IF SLEEPING TILL ON SCREEN, SEE IF IT DOESN'T
	CMP	#-2		;CARE WHERE (-2)
	BEQ	CE11
	LDA	ENEMYX,X	;GET BACK CURRENT LOCATION
	JSR	DIV8		;MAKE COLUMN THIS ENTITY IS ON
	CMP	ENEMYLREG,X	;SEE IF TIME TO LAUNCH IT
	BNE	CE12		;IF NOT, WAIT TILL IT IS.
CE11:	LDA	ENEMY0,X
	STA	BYTE1		;SET UP THE NEEDED BYTE 1 
	JSR	INIT_ENEMY	;DO THE INIT WE WAITED FOR
	LDX	SAFEBYTE
	LDA	ENEMYSTAT,X
	AND	#$7F
	STA	ENEMYSTAT,X
CE12:	RTS

;CHECK IF THE ENEMY HAS AN ATTACK ACTIVE THIS CYCLE.

CE15:	LDA	ENEMYD1,X	;GET FRAME # OF ATTACK
	CMP	#-1		;DISABLED?
	BEQ	CE20
	CMP	#-2		;PERMANENTLY ARMED?
	BEQ	CE35
	LDA	ENEMYSTAT,X	;SEE IF ARMED BEFORE WE GET FRAME TO SAVE PWR
	AND	#$20
	BEQ	CE20		;IF NOT, NO ATTACK
	LDA	SAFEBYTE
	JSR	GETFRAME	;GET FRAME # OF CURRENT ENEMY ANIMATION
	TXA			;SAVE FRAME # HERE
	LDX	SAFEBYTE
	CMP	ENEMYD1,X	;SEE IF CURRENT IS SAME OR BIGGER 
	BCS	CE30		;IF SO, WE NEED TO CHECK FOR ATTACK ARMED
CE20:	JMP	ME10

CE30:	LDA	ENEMYSTAT,X	
	EOR	#$20
	STA	ENEMYSTAT,X	;RESET ARMED BIT NOW

CE35:	LDA	ENEMYD2,X	;GET HOTSPOT FLAG
	AND	#$0F
	ASL	A		;MAKE *2
	STA	SAFEWORD
	LDY	ENEMYTRACK,X	;SEE WHAT DIRECTION ON X AXIS
	BPL	CE40
	LDA	ENEMYCENTR,X
	SEC
	SBC	SAFEWORD	;BACK UP TO LEFT IF FACING LEFT
	BCS	CE50
	LDA	#0		;DON'T ALLOW SCREEN WRAP
	JMP	CE50
CE40:	CLC
	ADC	ENEMYCENTR,X	;MAKE POINT IN SPACE RELATIVE TO CENTER
	BCC	CE50
	LDA	#-1		;DON'T ALLOW SCREEN WRAP
CE50:	STA	SAFEX		;SAVE CENTER OF ATTACK ON X HERE

	LDA	ENEMYD2,X	
	AND	#$F0	
	LSR	A
	LSR	A		;MAKE *16 INTO *4 Y LOCATION
	CLC
	ADC	ENEMYY,X	;MAKE Y LOCATION OF ATTACK
	STA	SAFEY

	LDA	ENEMYD4,X	;GET ATTACK ZONE FOR X
	AND	#$0F
	ASL	A
	ASL	A
	STA	SAFEWORD	;SET RADIUS OF ATTACK HERE
	LDA	SAFEX
	CLC
	ADC	SAFEWORD
	BCC	CE55
	LDA	#-1
CE55:	STA	SAFEX2		;SET RIGHTMOST AREA OF ATTACK
	LDA	SAFEX
	SEC
	SBC	SAFEWORD
	BCS	CE60
	LDA	#0
CE60:	STA	SAFEX		;SET LEFTMOST AREA OF ATTACK

	LDA	ENEMYD4,X	;GET ATTACK ZONE FOR Y
	AND	#$F0
	LSR	A
	LSR	A
	STA	SAFEWORD
	LDA	SAFEY
	CLC
	ADC	SAFEWORD
	STA	SAFEY2		;SET BOTTOMMOST AREA OF ATTACK
	LDA	SAFEY
	SEC
	SBC	SAFEWORD
	BCS	CE65
	LDA	#0
CE65:	STA	SAFEY		;SET TOPMOST AREA OF ATTACK

	LDY	#0		;START ENTITY CHECK WITH #0
CE100:	JSR	VALID2		;MAKE SURE VALID AND NOT US
	BEQ	CE150		

	LDA	ENEMYFLGS,X
	AND	#$40		;DID WE SPECIFY SPECIFIC TARGETING?
	BEQ	CE105

	LDA	ENEMYTLLOW,Y	;GET THE ENTITIES TARGET LEVEL
	AND	ENEMYTRLOW,X	;SEE IF WE TARGETED HIM
	BNE	CE105

	LDA	ENEMYTLHI,Y
	AND	ENEMYTRHI,X
	BEQ	CE150

CE105:	LDA	ENEMYY,Y 	;GET ENTITY TO CHECK'S TOP EDGE
	CMP	SAFEY		;SEE IF TOP IS ABOVE ATTACK AREA TOP
	BCS	CE110
	LDA	ENEMYFEET,Y	;IF SO, BOTTOM MUST BE BELOW ATTACK TOP
	CMP	SAFEY
	BCS	CE130
	JMP	CE150		;IF Y OUT OF RANGE, END	

CE110:	CMP	SAFEY2		;TOP IS BELOW ATTACK TOP.  
	BCC	CE130  		;SO IT MUST BE ABOVE ATTACK BOTTOM
	BNE	CE150		;OR EQUAL TO IT

CE130:	LDA	ENEMYX,Y	;Y IS IN RANGE.   REPEAT LOGIC FOR SIDES
	CMP	SAFEX		
	BCS	CE135
	CLC
	ADC	ENEMYWIDE,Y	
	BCC	CE132
      	LDA	#-1
CE132:	CMP	SAFEX
	BCS	CE140
	JMP	CE150		

CE135:	CMP	SAFEX2		
	BCC	CE140  		
	BNE	CE150		

;WE DID GET AN ENEMY WITH THE HOTSPOT BUT WAS THE DIRECTION CORRECT?
;WE HAVEN'T IMPLEMENTED THIS YET...

CE140:	
	JSR	REPORT		;REPORT THE HIT
	LDA	ENEMYSTAT,X
	ORA	#8
	STA	ENEMYSTAT,X	;SET FLAG OF WE HAVE ATTACKED SOMEONE
	LDA	ENEMY0,Y	;GET THE ENTITY NUMBER OF THE VICTIM
	STA	ENEMYVCTM,X	;SET WHO WE ATTACKED.
CE150:	INY
	CPY	#ECNT		;DONE WITH CHECK?
	BNE	CE100
	JMP	ME10		;DONE WITH ATTACK REPORTING

;THIS LITTLE SUB WILL REPORT AN ATTACK TO ENTITY Y FROM ENTITY X. 

REPORT:				;SHARED BY CMD36!!!
	LDA	SAFEBYTE
	STA	ENEMYATK,Y	;SET LAST ATTACKER FOR THIS ENEMY
	LDA	ENEMY0,X
	STA	ENEMYID,Y	;SET OUR ENEMY NUMBER FROM ENTITYTAB

	LDA	ENEMYD3,X	;GET OUR DAMAGE SPECS
	STA	ENEMYDAMG,Y	;SAVE IT HERE

;WARNING!!! YOU MUST SET THE ABOVE FLAGS EVEN IF HURTING IS DISABLED
;BECAUSE ENEMYID IS PROMISED TO BE VALID EVEN IF HURTING IS OFF.  ITS
;SET TO -1 AT LAUNCH FOR ENTITIES THAT HAVE ONLY A WAKEUP ENTRY.

	LDA	#HURTING
	AND	ENEMYINTS,Y
	BNE	REP10

	LDA	#EHURT
	STA	ENEMYREQ,Y	;REQUEST THE ENEMIES HURT SEQUENCE
REP10:	RTS

;SET UP THE POINTER USED TO GET THE ENEMY MOVEMENT INFO.

ME10:	JSR	EBACKUP		;GET THIS ENEMIES POINTER
	LDA	CLOCKP		;SET PASS COUNT TO ALLOW COMMANDS BASED ON 
	STA	PASSCNT		;THE CLOCKPHASE
	DEC	PASSCNT

;KEEP THE ENEMIES COUNTER RUNNING

	LDA	ENEMYCNT,X
	BEQ	ME12
	DEC	ENEMYCNT,X

ME12:	LDA	ENEMYALT,X
	BEQ	ME15
	DEC	ENEMYALT,X

;SEE IF AN EXTERNAL EVENT EFFECTED THE ENEMY. ENEMYREQ WILL BE TRUE.
;THE EXTERNAL EVENTS THEMSELVES CHECK IF THEY ARE ENABLED BECAUSE THEY
;KNOW WHAT THEY ARE. SO WE CAN TRUST IT HERE.

ME15:	LDA	ENEMYREQ,X
	BEQ	ME20
	LDA	ENEMYPTR
	STA	ENEMYRSL,X
	LDA	ENEMYPTR+1
	STA	ENEMYRSH,X	;SET RESUME POINTER
	LDA	ENEMYDELAY,X	;GET CURRENT DELAY IN PROGRESS
	STA	ENEMYSD,X	;WE MUST SAVE IT FOR RESUME
	LDA	ENEMYINTS,X
	STA	ENEMYSINT,X	;SAVE INTERRUPT CONDITION
	LDA	#-1
	STA	ENEMYINTS,X	;LOCK OUT ANY OTHER INTERRUPTS
	LDA	ENEMYREQ,X
	STA	DATA1		;SET MODE TO REQUEST
	LDA	#0
	STA	ENEMYREQ,X	;RESET COMMAND
	JSR	PICKMOD2	;PICK THAT MODE
	LDA	#0
	STA	ENEMYDELAY,X	;ZERO THE DELAY IF WE HAD ONE

;SEE IF WE ARE PAUSING

ME20:	LDA	ENEMYDELAY,X
	BEQ	ME40
	DEC	ENEMYDELAY,X
	JMP	ME250

;NOT PAUSING.  DO THE TABLE.  THE ACTUAL COMMAND BYTES MIGHT BE IN
;ANOTHER ROM PAGE SO WE FETCH THE BYTES NOW AND INCREMENT THE POINTER
;HERE AND THE ROUTINES THEMSELVES DECIDE WHAT TO DO NEXT.  ITS LEGAL
;FOR THEM TO PUT BACK THE OLD POINTER STILL IN THEIR DATA STRUCTURES
;IF THEY WANT OR THEY CAN CHANGE THE POINTER IN LOW MEMORY WHICH IS
;PICKED UP AND PUT INTO THEIR DATA STRUCTURE ON RETURN.

ME40:  	LDX	#0
	JSR	FILLCBUF	;GET THE DATA FOR THE NEXT COMMAND
	LDX	SAFEBYTE	;RESTORE ENEMY INDEX
	LDA	SUBSVAR1	;GET LENGTH WE LOADED
	CLC
	ADC	ENEMYPTR
	STA	ENEMYPTR	;UPDATE THE POINTER
	BCC	ME42
	INC	ENEMYPTR+1
ME42:	JSR	ME110		;MAKE IT INTO A SUB
	LDX	SAFEBYTE
 	JSR	SETPTR		;GET RESULTING POINTER FOR COMMAND
	LDA	PASSCNT
	BPL	ME105
	DEC	PASSCNT		;IF MINUS BEFORE, COUNT LOOKING FOR IT GOING
	BMI	ME20		;TO PLUS WHICH MEANS WE WERE DONE.
	JMP	ME250

ME105:	DEC	PASSCNT		;TRY TO RUN ANOTHER
	BPL	ME20		;STILL PLUS MEANS OK
	JMP	ME250		;IF NOT, STOP NOW

ME110:	LDY	CMDBUF
	LDA	CMDBASEH,Y
	PHA
	LDA	CMDBASEL,Y
	PHA
	RTS			;JUMP TO THE ROUTINE WITH A RTS

CMDBASEL:
	.byte	(CMD00-1) & $FF	;FOR FAKING AN RTS.  BUT THE 6502
	.byte	(CMD01-1) & $FF	;NEEDS IT DECed FOR SOME ODD REASON.
	.byte	(CMD02-1) & $FF
	.byte	(CMD03-1) & $FF
	.byte	(CMD04-1) & $FF
	.byte	(CMD05-1) & $FF
	.byte	(CMD06-1) & $FF
	.byte	(CMD07-1) & $FF
	.byte	(CMD08-1) & $FF
	.byte	(CMD09-1) & $FF
	.byte	(CMD0A-1) & $FF
	.byte	(CMD0B-1) & $FF
	.byte	(CMD0C-1) & $FF
	.byte	(CMD0D-1) & $FF
	.byte	(CMD0E-1) & $FF
	.byte	(CMD0F-1) & $FF
	.byte	(CMD10-1) & $FF
	.byte	(CMD11-1) & $FF
	.byte	(CMD12-1) & $FF
	.byte	(CMD13-1) & $FF
	.byte	(CMD14-1) & $FF
	.byte	(CMD15-1) & $FF
	.byte	(CMD16-1) & $FF
	.byte	(CMD17-1) & $FF
	.byte	(MAKEDING-1) & $FF
	.byte	(CMD19-1) & $FF
	.byte	(CMD1A-1) & $FF
	.byte	(CMD1B-1) & $FF
	.byte	(CMD1C-1) & $FF
	.byte	(CMD1D-1) & $FF
	.byte	(CMD1E-1) & $FF
	.byte	(CMD1F-1) & $FF
	.byte	(CMD20-1) & $FF
	.byte	(CMD21-1) & $FF
	.byte	(CMD22-1) & $FF
	.byte	(CMD23-1) & $FF
	.byte	(CMD24-1) & $FF
	.byte	(CMD25-1) & $FF
	.byte	(CMD26-1) & $FF
	.byte	(CMD27-1) & $FF
	.byte	(CMD28-1) & $FF
	.byte	(CMD29-1) & $FF
	.byte	(CMD2A-1) & $FF
	.byte	(CMD2B-1) & $FF
	.byte	(CMD2C-1) & $FF
	.byte	(CMD2D-1) & $FF
	.byte	(CMD2E-1) & $FF
	.byte	(CMD2F-1) & $FF
	.byte	(CMD30-1) & $FF
	.byte	(CMD31-1) & $FF
	.byte	(CMD32-1) & $FF
	.byte	(CMD33-1) & $FF
	.byte	(CMD34-1) & $FF
	.byte	(CMD35-1) & $FF
	.byte	(CMD36-1) & $FF
	.byte	(CMD37-1) & $FF
	.byte	(CMD38-1) & $FF
	.byte	(CMD39-1) & $FF
	.byte	(CMD3A-1) & $FF
	.byte	(CMD3B-1) & $FF
	.byte	(CMD3C-1) & $FF
	.byte	(CMD3D-1) & $FF
	.byte	(CMD3E-1) & $FF
	.byte	(CMD3F-1) & $FF
	.byte	(CMD40-1) & $FF
	.byte	(CMD41-1) & $FF
	.byte	(CMD42-1) & $FF
	.byte	(CMD43-1) & $FF
	.byte	(CMD44-1) & $FF
	.byte	(CMD45-1) & $FF
	.byte	(CMD46-1) & $FF
	.byte	(CMD47-1) & $FF
	.byte	(CMD48-1) & $FF
	.byte	(CMD49-1) & $FF
	.byte	(CMD4A-1) & $FF
	.byte	(CMD4B-1) & $FF
	.byte	(CMD4C-1) & $FF
	.byte	(CMD4D-1) & $FF
	.byte	(CMD4E-1) & $FF
	.byte	(CMD4F-1) & $FF
	.byte	(CMD50-1) & $FF
	.byte	(CMD51-1) & $FF
	.byte	(CMD52-1) & $FF
	.byte	(CMD53-1) & $FF
	.byte	(CMD54-1) & $FF
	.byte	(CMD55-1) & $FF
	.byte	(CMD56-1) & $FF
	.byte	(CMD57-1) & $FF
	.byte	(CMD58-1) & $FF
	.byte	(CMD59-1) & $FF
	.byte	(CMD5A-1) & $FF
	.byte	(CMD5B-1) & $FF
	.byte	(CMD5C-1) & $FF
	.byte	(CMD5D-1) & $FF
	.byte	(CMD5E-1) & $FF
	.byte	(CMD5F-1) & $FF
	.byte	(CMD60-1) & $FF
	.byte	(CMD61-1) & $FF
	.byte	(CMD62-1) & $FF
	.byte	(CMD63-1) & $FF
	.byte	(CMD64-1) & $FF
	.byte	(CMD65-1) & $FF
	.byte	(CMD66-1) & $FF
	.byte	(CMD67-1) & $FF
	.byte	(CMD68-1) & $FF
	.byte	(CMD69-1) & $FF
	.byte	(CMD6A-1) & $FF
	.byte	(CMD6B-1) & $FF
	.byte	(CMD6C-1) & $FF
	.byte	(CMD6D-1) & $FF
	.byte	(CMD6E-1) & $FF
	.byte	(CMD6F-1) & $FF
	.byte	(CMD70-1) & $FF
	.byte	(CMD71-1) & $FF
	.byte	(CMD72-1) & $FF
	.byte	(CMD73-1) & $FF
	.byte	(CMD74-1) & $FF
	.byte	(CMD75-1) & $FF
	.byte	(CMD76-1) & $FF
	.byte	(CMD77-1) & $FF
	.byte	(CMD78-1) & $FF
	.byte	(CMD79-1) & $FF
	.byte	(CMD7A-1) & $FF
	.byte	(CMD7B-1) & $FF
	.byte	(CMD7C-1) & $FF
	.byte	(CMD7D-1) & $FF
	.byte	(CMD7E-1) & $FF
	.byte	(CMD7F-1) & $FF
	.byte	(CMD80-1) & $FF
	.byte	(CMD81-1) & $FF
	.byte	(CMD82-1) & $FF
	.byte	(CMD83-1) & $FF
	.byte	(CMD84-1) & $FF
	.byte	(CMD85-1) & $FF
	.byte	(CMD86-1) & $FF
	.byte	(CMD87-1) & $FF
	.byte	(CMD88-1) & $FF
	.byte	(CMD89-1) & $FF
	.byte	(CMD8A-1) & $FF
	.byte	(CMD8B-1) & $FF
	.byte	(CMD8C-1) & $FF
	.byte	(CMD8D-1) & $FF
	.byte	(CMD8E-1) & $FF
	.byte	(CMD8F-1) & $FF
	.byte	(CMD90-1) & $FF
	.byte	(CMD91-1) & $FF
	.byte	(CMD92-1) & $FF
	.byte	(CMD93-1) & $FF
	.byte	(CMD94-1) & $FF
	.byte	(CMD95-1) & $FF
	.byte	(CMD96-1) & $FF
	.byte	(CMD97-1) & $FF
	.byte	(CMD98-1) & $FF
	.byte	(CMD99-1) & $FF
	.byte	(CMD9A-1) & $FF
	.byte	(CMD9B-1) & $FF
	.byte	(CMD9C-1) & $FF
	.byte	(CMD9D-1) & $FF
	.byte	(CMD9E-1) & $FF
	.byte	(CMD9F-1) & $FF
	.byte	(CMDA0-1) & $FF
	.byte	(CMDA1-1) & $FF
	.byte	(CMDA2-1) & $FF
	.byte	(CMDA3-1) & $FF
	.byte	(CMDA4-1) & $FF
	.byte	(CMDA5-1) & $FF
	.byte	(CMDA6-1) & $FF
	.byte	(CMDA7-1) & $FF
	.byte	(CMDA8-1) & $FF
	.byte	(CMDA9-1) & $FF

CMDBASEH:
	.byte	(CMD00-1) >> 8
	.byte	(CMD01-1) >> 8
	.byte	(CMD02-1) >> 8
	.byte	(CMD03-1) >> 8
	.byte	(CMD04-1) >> 8
	.byte	(CMD05-1) >> 8
	.byte	(CMD06-1) >> 8
	.byte	(CMD07-1) >> 8
	.byte	(CMD08-1) >> 8
	.byte	(CMD09-1) >> 8
	.byte	(CMD0A-1) >> 8
	.byte	(CMD0B-1) >> 8
	.byte	(CMD0C-1) >> 8
	.byte	(CMD0D-1) >> 8
	.byte	(CMD0E-1) >> 8
	.byte	(CMD0F-1) >> 8
	.byte	(CMD10-1) >> 8
	.byte	(CMD11-1) >> 8
	.byte	(CMD12-1) >> 8
	.byte	(CMD13-1) >> 8
	.byte	(CMD14-1) >> 8
	.byte	(CMD15-1) >> 8
	.byte	(CMD16-1) >> 8
	.byte	(CMD17-1) >> 8
	.byte	(MAKEDING-1) >> 8
	.byte	(CMD19-1) >> 8
	.byte	(CMD1A-1) >> 8
	.byte	(CMD1B-1) >> 8
	.byte	(CMD1C-1) >> 8
	.byte	(CMD1D-1) >> 8
	.byte	(CMD1E-1) >> 8
	.byte	(CMD1F-1) >> 8
	.byte	(CMD20-1) >> 8
	.byte	(CMD21-1) >> 8
	.byte	(CMD22-1) >> 8
	.byte	(CMD23-1) >> 8
	.byte	(CMD24-1) >> 8
	.byte	(CMD25-1) >> 8
	.byte	(CMD26-1) >> 8
	.byte	(CMD27-1) >> 8
	.byte	(CMD28-1) >> 8
	.byte	(CMD29-1) >> 8
	.byte	(CMD2A-1) >> 8
	.byte	(CMD2B-1) >> 8
	.byte	(CMD2C-1) >> 8
	.byte	(CMD2D-1) >> 8
	.byte	(CMD2E-1) >> 8
	.byte	(CMD2F-1) >> 8
	.byte	(CMD30-1) >> 8
	.byte	(CMD31-1) >> 8
	.byte	(CMD32-1) >> 8
	.byte	(CMD33-1) >> 8
	.byte	(CMD34-1) >> 8
	.byte	(CMD35-1) >> 8
	.byte	(CMD36-1) >> 8
	.byte	(CMD37-1) >> 8
	.byte	(CMD38-1) >> 8
	.byte	(CMD39-1) >> 8
	.byte	(CMD3A-1) >> 8
	.byte	(CMD3B-1) >> 8
	.byte	(CMD3C-1) >> 8
	.byte	(CMD3D-1) >> 8
	.byte	(CMD3E-1) >> 8
	.byte	(CMD3F-1) >> 8
	.byte	(CMD40-1) >> 8
	.byte	(CMD41-1) >> 8
	.byte	(CMD42-1) >> 8
	.byte	(CMD43-1) >> 8
	.byte	(CMD44-1) >> 8
	.byte	(CMD45-1) >> 8
	.byte	(CMD46-1) >> 8
	.byte	(CMD47-1) >> 8
	.byte	(CMD48-1) >> 8
	.byte	(CMD49-1) >> 8
	.byte	(CMD4A-1) >> 8
	.byte	(CMD4B-1) >> 8
	.byte	(CMD4C-1) >> 8
	.byte	(CMD4D-1) >> 8
	.byte	(CMD4E-1) >> 8
	.byte	(CMD4F-1) >> 8
	.byte	(CMD50-1) >> 8
	.byte	(CMD51-1) >> 8
	.byte	(CMD52-1) >> 8
	.byte	(CMD53-1) >> 8
	.byte	(CMD54-1) >> 8
	.byte	(CMD55-1) >> 8
	.byte	(CMD56-1) >> 8
	.byte	(CMD57-1) >> 8
	.byte	(CMD58-1) >> 8
	.byte	(CMD59-1) >> 8
	.byte	(CMD5A-1) >> 8
	.byte	(CMD5B-1) >> 8
	.byte	(CMD5C-1) >> 8
	.byte	(CMD5D-1) >> 8
	.byte	(CMD5E-1) >> 8
	.byte	(CMD5F-1) >> 8
	.byte	(CMD60-1) >> 8
	.byte	(CMD61-1) >> 8
	.byte	(CMD62-1) >> 8
	.byte	(CMD63-1) >> 8
	.byte	(CMD64-1) >> 8
	.byte	(CMD65-1) >> 8
	.byte	(CMD66-1) >> 8
	.byte	(CMD67-1) >> 8
	.byte	(CMD68-1) >> 8
	.byte	(CMD69-1) >> 8
	.byte	(CMD6A-1) >> 8
	.byte	(CMD6B-1) >> 8
	.byte	(CMD6C-1) >> 8
	.byte	(CMD6D-1) >> 8
	.byte	(CMD6E-1) >> 8
	.byte	(CMD6F-1) >> 8
	.byte	(CMD70-1) >> 8
	.byte	(CMD71-1) >> 8
	.byte	(CMD72-1) >> 8
	.byte	(CMD73-1) >> 8
	.byte	(CMD74-1) >> 8
	.byte	(CMD75-1) >> 8
	.byte	(CMD76-1) >> 8
	.byte	(CMD77-1) >> 8
	.byte	(CMD78-1) >> 8
	.byte	(CMD79-1) >> 8
	.byte	(CMD7A-1) >> 8
	.byte	(CMD7B-1) >> 8
	.byte	(CMD7C-1) >> 8
	.byte	(CMD7D-1) >> 8
	.byte	(CMD7E-1) >> 8
	.byte	(CMD7F-1) >> 8
	.byte	(CMD80-1) >> 8
	.byte	(CMD81-1) >> 8
	.byte	(CMD82-1) >> 8
	.byte	(CMD83-1) >> 8
	.byte	(CMD84-1) >> 8
	.byte	(CMD85-1) >> 8
	.byte	(CMD86-1) >> 8
	.byte	(CMD87-1) >> 8
	.byte	(CMD88-1) >> 8
	.byte	(CMD89-1) >> 8
	.byte	(CMD8A-1) >> 8
	.byte	(CMD8B-1) >> 8
	.byte	(CMD8C-1) >> 8
	.byte	(CMD8D-1) >> 8
	.byte	(CMD8E-1) >> 8
	.byte	(CMD8F-1) >> 8
	.byte	(CMD90-1) >> 8
	.byte	(CMD91-1) >> 8
	.byte	(CMD92-1) >> 8
	.byte	(CMD93-1) >> 8
	.byte	(CMD94-1) >> 8
	.byte	(CMD95-1) >> 8
	.byte	(CMD96-1) >> 8
	.byte	(CMD97-1) >> 8
	.byte	(CMD98-1) >> 8
	.byte	(CMD99-1) >> 8
	.byte	(CMD9A-1) >> 8
	.byte	(CMD9B-1) >> 8
	.byte	(CMD9C-1) >> 8
	.byte	(CMD9D-1) >> 8
	.byte	(CMD9E-1) >> 8
	.byte	(CMD9F-1) >> 8
	.byte	(CMDA0-1) >> 8
	.byte	(CMDA1-1) >> 8
	.byte	(CMDA2-1) >> 8
	.byte	(CMDA3-1) >> 8
	.byte	(CMDA4-1) >> 8
	.byte	(CMDA5-1) >> 8
	.byte	(CMDA6-1) >> 8
	.byte	(CMDA7-1) >> 8
	.byte	(CMDA8-1) >> 8
	.byte	(CMDA9-1) >> 8

;***************
;HERE ARE THE VARIOUS COMMANDS.  EACH IS ENTERED WITH THE BYTES IT NEEDS
;IN CMDBUF AT DATA1, DATA2, ETC.  X HAS THE ENEMY INDEX.
;***************

;THIS ENTRY POINT IS USED TO ACTIVATE EACH OF THE MODES.  THEY
;ARE NORMALLY ENTERED FROM A COMMAND IN THE COMMAND STREAM WHICH IS
;INDEXED INTO CMDBASE TABLE.  BUT EXTERNAL ROUTINES MAY CALL.  PUT
;THE DESIRED MODE INDEX FROM COMMAND 0 IN KUNGTAB INTO DATA1
;AND CALL. (THE ONLY CURRENT "OUTSIDE" ROUTINES THAT DO THIS 
;AS OF TODAY ARE THE LAUNCH ENEMY COMMAND, BF20 AND COMMAND 63). THIS ROUTINE 
;CORRECTLY RETURNS THE NZ OR Z FLAG AS DESCRIBED BY SETUPANIM.

CMD00:
	LDA	#-1
	STA	ENEMYRSH,X	;RESET RESUME COMMAND WITH MODE CHANGE

PICKMOD2:
	LDA	#0
	STA	SETUPFLG	;ZERO THE SPECIAL SETUP MODE FLAG

PICKMOD3:			;CALL HERE AFTER SETTING SETUPFLG YOURSELF

	LDA	DATA1		;GET DESIRED MODE INDEX
	JSR	SETUPANIM	;SET UP THE ANIMATION AND PARAMS
	RTS

PICKMOD4:			;FOR FINISH_ENEMY SINCE ENEMY0,X INVALID
	LDA	#0
	STA	SETUPFLG	;ZERO THE SPECIAL SETUP MODE FLAG
	LDA	BYTE1
	JSR	POINTE2		;MAKE INITIAL INDEX FOR POINTENEMY
	LDA	#EWAKE		;GET DESIRED MODE INDEX
	PHA			;FAKE IT FOR SETUPA2
	JMP	SETUPA2		;SHARE ENDING FOR SETUPANIM

CMDA3:				;DISTANCE SHARES WITH THIS COMMAND.
CMD01:	JSR	MAKETRACKS	;MOVE EXECUTE POINTER IF TARGET IS IN RANGE 
	LDA	DATA3
	STA	SUBSVAR3
	LDA	DATA4
	STA	SUBSVAR4	;GET Y VALUES TOO AND PASS THESE BYTES
	LDA	SUBSVAR2	;SEE IF SPECIAL CASE OF NONE TO TRACK
	CMP	#-1
	BEQ	CMD019
	
	LDA	SUBSVAR3	;DON'T CARE ABOUT X?
	CMP	#-1
	BEQ	CMD017		;SKIP DIRECTION CHECK AND ALL IF SO

	LDA	SUBSVAR1	;GET X OF TARGET
	CMP	ENEMYCENTR,X	;SEE WHAT DIRECTION HE IS
	BCC	CMD010		;SKIP IF HE'S BEHIND US
	LDY	#0		;SET FLAG OF HE'S IN PLUS DIRECTION 
 	JMP	CMD011

CMD010:	LDY	#$80		;SET FLAG OF HE'S IN MINUS DIRECTION

CMD011:	TYA			;GET DIRECTION FLAG
	EOR	ENEMYXMOM,X	;MAKE SURE WE ARE FACING THE TARGET
	BPL	CMD016
	LDA	CMDBUF		;SEE IF COMMAND A3
	CMP	#$A3

	BNE	CMD019		;IT DOESN'T CARE IF WE ARE FACING IT.
;	BEQ	CMD016
;	LDA	ENEMYXMOM,X	;IF ZERO X MOMENTUM, HE'S FACING IT.
;	BNE	CMD019		;IF NOT, TEST FAILS

CMD016:	LDA	SUBSVAR1	;NOW GET BACK TARGET LOCATION
	SEC
	SBC	ENEMYCENTR,X	;MAKE DISTANCE TO TARGET
	CPY	#0		;SEE IF WE NEED TO INVERT SIGN
	BEQ	CMD012
	JSR	NEGATE
CMD012:	CMP	SUBSVAR3	;SEE IF X IN RANGE
	BCS	CMD019		;IF NOT, NO MOVEMENT OF EXECUTION POINTER

CMD017:	LDA	SUBSVAR4	;DON'T CARE ABOUT Y?
	CMP	#-1
	BEQ	CMD018		;IF NOT, WE PASSED THE TEST

	LDA	SUBSVAR2	;GET Y OF TARGET
	CMP	ENEMYFEET,X	;SEE WHAT DIRECTION HE IS
	BCC	CMD013		;SKIP IF HE'S ABOVE US
	LDY	#0		;SET FLAG OF HE'S IN PLUS DIRECTION 
 	JMP	CMD014

CMD013:	LDY	#$80		;SET FLAG OF HE'S IN MINUS DIRECTION

CMD014:	LDA	SUBSVAR2	;NOW GET BACK TARGET Y LOCATION
	SEC
	SBC	ENEMYFEET,X	;MAKE DISTANCE TO TARGET
	CPY	#0		;SEE IF WE NEED TO INVERT SIGN
	BEQ	CMD015
	JSR	NEGATE
CMD015:	CMP	SUBSVAR4	;SEE IF Y IN RANGE
	BCS	CMD019		;IF NOT, NO MOVEMENT OF EXECUTION POINTER
CMD018:	JMP	MOVEPTR		;YEP, WE NEED TO MOVE IT.
CMD019:	RTS

CMD02:				;MOVE EXECUTE POINTER IF LEDGE
CMD021:	LDA	DATA3
	ASL	A
	ASL	A
	ASL	A		;MAKE INTO PIXELS
	JSR	NEGATE		;ABOVE US
	TAY
	LDX	#0
	JSR	TESTMOVE	;SEE IF WE COULD MOVE THERE
	BNE	MOVEPTR		;IF NOT, WE FOUND A LEDGE
	DEC	DATA3
	BNE	CMD021
	RTS

CMD03:	LDA	DATA3		;MOVE EXECUTE POINTER IF PRECIPICE 
	CLC
	ADC	ENEMYWIDE,X	;ADD 1 BYTE OFFSET TO ENEMIES WIDTH IN PIXELS
	LDY	ENEMYTRACK,X	;SEE IF PLUS OR MINUS DIRECTION
	BPL	CMD035
	JSR	NEGATE		;NEED LEFT MOVEMENT IF MINUS MOMENTUM
CMD035:	TAX			;MOVE OVER 1 WIDTH
	LDY	#2		;MOVE DOWN 2
	JSR	TESTMOVE	;SEE IF WE COULD FALL THERE	
	BEQ	MOVEPTR
	RTS

CMD04:				;MOVE EXECUTE POINTER

;JUMP HERE TO SET ENEMYPTR TO DATA2:DATA1

MOVEPTR:
	LDA	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	STA	ENEMYPTR+1
	RTS

CMD05:	JSR	GETRANDOM	;MOVE EXECUTE POINTER RANDOM NUMBER IS BELOW A VALUE
	LDA	DATA3		;GET A RANDOM NUMBER AND GET NUMBER TO BE <
	CMP	XRANDOM
	BCC	CMD055
	JMP	MOVEPTR
CMD055:	RTS

CMD06:	LDA	DATA1		;MOMENTUM LIMIT OVERRIDE
	CMP	#-1
	BEQ	CMD065
	CMP	#0
	BNE	CMD062
	LDA	ENEMYLREG,X
CMD062:	STA	ENEMYXLIM,X	;SET X LIMIT IF NOT NO CHANGE VALUE
CMD065:	LDA	DATA2
	CMP	#-1
	BEQ	CMD067
	CMP	#0
	BNE	CMD066
	LDA	ENEMYLREG,X
CMD066:	STA	ENEMYYLIM,X	;SET Y LIMIT IF NOT NO CHANGE VALUE
CMD067:	RTS

CMD07:	LDA	DATA1 		;DELAY
	JSR	REGVAL
	STA	ENEMYDELAY,X	
NOCMDS:	LDA	#0		;HERE FOR NO MORE COMMANDS
	STA	PASSCNT
	RTS

REGVAL:	CMP	#0		;CALL HERE TO USE A AS <REGISTER> OR VALUE
	BNE	REGV10		;FIXED VALUE OR <REGISTER> AND INC THE PTR.
	LDA	ENEMYLREG,X	;ONLY GETS LOW BYTE OF <REGISTER>
REGV10:	RTS

SEECMDS:			;THIS WILL ZERO UNLESS FORCED NUMBER
	LDA	PASSCNT
	BPL	NOCMDS
	RTS

CMD08:	JSR	USEMOM 		;ADD TO MOMENTUMS
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD09:	LDA	DATA1		;SPECIFY GRAVITY
	CMP	#-1
	BNE	CMD092
	LDA	#DEF_GRAV
CMD092:	STA	ENEMYGRAV,X
	RTS

CMD0A:	LDA	DATA1		;SET SOLID CONDITION
	JSR	REGVAL		

CMD0A2:	CMP	#OFF
	BEQ	SOLIDOFF	;OFF=TURN IT OFF

	CMP	#ON		;UNCONDITIONAL ON?
	BEQ	SOLIDON		;ON IF SO.

	CMP	#SAFE		;CONDITIONAL ON?
	BNE	CMD0A7		;SKIP IF NOT

TRYON:				;TRIES TO DO CONDITIONAL ON, SETS STATUS
	LDA	ENEMYSTAT,X	;IF CONDITIONAL, ASSUME WE CAN
	AND	#$BF
	STA	ENEMYSTAT,X	;WE'LL NEED THE FLAG RESET
	JSR	SOLIDON		;IF CONDITIONAL, TRY IT OUT
	LDY	ENEMYY,X
	LDA	ENEMYX,X
	TAX
	LDA	SAFEBYTE
	JSR	TESTPUT		;AND THEN TRY MOVING TO THIS LOCATION
	LDX	SAFEBYTE
	CMP	#0
	BEQ	CMD0A5		;IF SUCCESS, WE'VE SET UP OK
	JSR	SOLIDOFF
	LDA	ENEMYSTAT,X
	ORA	#$40
	STA	ENEMYSTAT,X	;SET CONDITIONAL BIT ON
CMD0A5:	RTS


CMD0A7:	STA	ENEMYSOLID,X	;IF ANY OTHER VALUE, ITS A CHANGE IN VALUE
	LDA	ENEMYSTAT,X	;GET CURRENT STATE
	AND	#$40
	BNE	TRYON		;IF CONDITIONAL ON, TRY IT OUT NOW
	LDA	ENEMYSTAT,X
	AND	#4		;SEE IF WAS ON
	BNE	SOLIDON		;IF SO, TURN IT ON AGAIN	

SOLIDOFF:			;TURNS OFF SOLID, RESETS BIT THAT ITS ON
    	LDA	ENEMYSTAT,X
	AND	#$FB
	STA	ENEMYSTAT,X
	LDX	#0
	JSR	SDN
	RTS

SOLIDON:			;TURN ON SOLID, SET BIT THAT ITS ON.
	LDA	ENEMYSTAT,X
	ORA	#4
	STA	ENEMYSTAT,X
	LDA	ENEMYSOLID,X
	TAX
SDN:	LDA	SAFEBYTE	
	JSR	SOLID		;TURN IT ON.
	LDX	SAFEBYTE	;RESTORE ENEMY INDEX
SDN10:	RTS

CMD0B:	LDA	DATA1		;SPECIFY TARGET LEVEL
	STA	ENEMYTLLOW,X
	LDA	DATA2
	STA	ENEMYTLHI,X	;SET TARGET LEVEL
	RTS

CMD0C:	LDA	DATA1		;SPECIFY TARGET 
	STA	ENEMYTRLOW,X
	LDA	DATA2
	STA	ENEMYTRHI,X	;SET TARGET TO TRACK
	RTS

CMD0D:	LDA	#$FC		;SPECIFY X TARGET TRACKING
	JMP	CMD0E5

CMD0E:	LDA	#$CF		;SPECIFY Y TARGET TRACKING
	ASL	DATA1
	ASL	DATA1
	ASL	DATA1
	ASL	DATA1
CMD0E5:	AND	ENEMYTRACK,X
	ORA	DATA1		;SET NEW TARGET BITS INTO LOW NIBBLE
	STA	ENEMYTRACK,X
	RTS

CMD0F:	LDA	DATA1		;REQUEST WORLD
	JSR	REGVAL
CMD0F2:	STA	WORLD_REQUEST
	LDA	#0
	STA	CHEATMODE	;FLAG ITS NOT A CHEAT MODE ENTERED WORLD
CMD0F5:	JMP	NOCMDS

CMD10:	LDA	ENEMYJSTAT,X	;GRAB JOYSTICK
	AND	#$83
	CMP	DATA1		;SEE IF WE ALREADY HAVE IT
	BEQ	CMD109
	LDA	DATA1
	AND	#$07
	STA	DATA1
	LDA	ENEMYJSTAT,X
	AND	#$6C
	ORA	DATA1
	STA	ENEMYJSTAT,X	;SET JOYSTICK WE ARE TO USE
	TAY			;GET IT AS AN INDEX
	LDA	#-1
	STA	SELKEY,Y

	LDA	JOYENEMY,Y	;GET ENEMY IT HAD BEFORE
	PHA
	TXA
	STA	JOYENEMY,Y	;SET US IN CHARGE
	PLA			;GET WHO IT HAD
	TAY
	LDA	#$80
	ORA	ENEMYJSTAT,Y
	STA	ENEMYJSTAT,Y	;SET THAT OLD ENEMY AS NOT HAVING IT
CMD109:	RTS

CMD11:	JSR	GETJOY		;ADD JOYSTICK X
	LDA	JOYX,Y
	STA	DATA1
	LDA	#0
	STA	DATA2
	STA	JOYX,Y		;AND THEN ZERO IT
CMD115:	JSR	USEMOM4
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD12:	JSR	GETJOY		;ADD JOYSTICK Y
	LDA	JOYY,Y
	STA	DATA2
	LDA	#0
	STA	DATA1
	STA	JOYY,Y		;AND THEN ZERO IT
	JMP	CMD115

CMD13:	JSR	GETJOY	;ZERO JOYSTICK X
	LDA	#0
	STA	JOYX,Y	
	RTS

CMD14:	JSR	GETJOY	;ZERO JOYSTICK Y
	LDA	#0
	STA	JOYY,Y	
	RTS

CMD15:	JSR	GETJOY		;MOVE EXECUTE POINTER IF JOYSTICK BITS ARE SET
	LDA	DATA3
	AND	J1FLAGS,Y	;SEE IF ANY OF THE BITS ARE SET
	BEQ	CMD109
	JMP	MOVEPTR		;IF SO, MOVE EXECUTE POINTER

CMD16:	LDA	DATA1		;ACTIVATE ANIMATION SEQUENCE
	STA	SUBSVAR1
	LDA	DATA2
	STA	SUBSVAR2
	JSR	SETUP2		;SET IT UP
	RTS

;THIS SUB WILL FETCH DATA FROM (ENEMYPTR) FOR LENGTH X INTO CMDBUF
;AND THEN RESTORE ENEMYPTR FROM THE ENTITIES STORAGE AND POINT
;(SUBSVAR1) TO THE DATA FETCHED.  YOU MUST USE SETPTR BEFOREHAND
;AND SET UP (ENEMYPTR) YOURSELF.

FILL_POINT:			
	JSR	FILLCBUF	;GET THE DATA TO SEQUENCE WITH
	LDX	SAFEBYTE
	JSR	EBACKUP
POINT_CMDBUF:			;CALL HERE JUST TO POINT SUBSVAR1 TO CMDBUF
	LDA	#CMDBUF & $FF
	STA	SUBSVAR1
	LDA	#CMDBUF >> 8
	STA	SUBSVAR2	;POINT TO THE DATA
	RTS

CMD17:	LDA	ENEMYRSH,X	;GET RESUME POINTER HIGH
	CMP	#-1		;NO POINT TO RESUME TO?
	BEQ	CMD175		;IF SO, IGNORE IT
	STA	ENEMYPTR+1
	LDA	ENEMYRSL,X
	STA	ENEMYPTR
	LDA	ENEMYSD,X
	STA	ENEMYDELAY,X	;SET BACK WHATEVER DELAY WE HAD
	LDA	ENEMYSINT,X
	STA	ENEMYINTS,X
	LDA	CLOCKP
	STA	PASSCNT		;ALLOW SOME INSTRUCTIONS TO RUN
CMD175:	RTS

CMD19:	JSR	GETFLAGS	;WAIT FOR ANIMATION TO FREEZE.  
	TAY			;SAVE A COPY
	AND	#$07		;MAKE SURE ANIMATION
	CMP	#2
	BNE	CMD175		;IF NOT, ACT AS IF FROZEN
	TYA
	AND	#$40		;GET FREEZE BIT
	BNE	CMD175		;ALLOW CONTINUE IF FROZEN, BACKUP OTHERWISE
	JSR	NOCMDS

EBACKUP: 			;CALL HERE TO DELAY ON THIS COMMAND.
	LDA	ENEMYINL,X
	STA	ENEMYPTR
	LDA	ENEMYINH,X
	STA	ENEMYPTR+1	;ITS NOT FROZEN, BACK UP
	RTS

LOADPTR:			;CALL HERE TO SET Y:A TO THE STORED POINTER
	LDA	ENEMYINH,X	;X MUST HAVE SAFEBYTE
	TAY
	LDA	ENEMYINL,X
	RTS

;THIS ROUTINE WILL RETURN THE ANIMATION'S FLAG BYTE IN A AND KEEP X=SAFEBYTE

GETFLAGS:
	LDA	SAFEBYTE	;WAIT FOR ANIMATION TO FREEZE.  
	JSR	USEDINDX	;MAKE INDEX
	LDA	ANIM_RAM+FB,X	;GET FLAGS
	LDX	SAFEBYTE
	RTS	

CMD1A:	LDA	DATA1		;SET COUNTER.  
	JSR	REGVAL
	STA	ENEMYCNT,X
CMD1A9:	RTS

CMD1B:	LDA	DATA3		;MOVE EXECUTE POINTER IF COUNTER BELOW OR =
	CMP	ENEMYCNT,X	;BELOW OR EQUAL TO THE VALUE?
	BCC	CMD1A9		
	JMP	MOVEPTR

CMD1C:				;SPECIFY FRICTION
	LDA	ENEMYLINK,X	;ILLEGAL IF LINKED
	BPL	CMD1C4
	LDA	DATA1
	CMP	#-1
	BEQ	CMD1C2
	STA	ENEMYXFRICT,X
CMD1C2:	LDA	DATA2
	CMP	#-1
	BEQ	CMD1C4
	STA	ENEMYYFRICT,X
CMD1C4:	RTS

CMD1D:	LDA	DATA1		;GOTO X,Y POSITION
	JSR	REGVAL
	CMP	#-1
	BEQ	CMD1D2
	STA	ENEMYX,X

CMD1D2:	LDA	DATA2
	JSR	REGVAL
	CMP	#-1
	BEQ	CMD1D4
	SEC
	SBC	ENEMYHIGH,X	;CORRECT FOR ENEMIES HEIGHT
	CLC
	ADC	#1
	STA	ENEMYY,X

CMD1D4:	JSR	FINDLOCS
	RTS

CMD1E:	JSR	NOCMDS		;DIE
	LDA	DATA1		;GET FLAG TO KILL OR NOT KILL
	BEQ	CMD1E9		;SKIP IF NO KILL
	LDA	ENEMYNUM,X
	JSR	MAKELIFE
	LDX	SAFEBYTE
	ORA	REMEMBER,Y
	STA	REMEMBER,Y	;SET THE BIT ON TO SIGNAL PERMANENT DEATH
CMD1E9:	JSR	ENEMYGONE		;MAKE IT GO AWAY
CMD1E8:	RTS

;THIS ROUTINE WILL TAKE A PERMANENT MEMORY INDEX IN A AND MAKE A POINTER
;TO THE RAM BYTE IN REMEMBER WITH A BIT MASK IN A.  A WILL HAVE THE 
;APPROPRIATE BIT SET.  ACCESS THE RAM WITH REMEMBER,Y.  X IS CHANGED.
;

MAKELIFE:
	PHA		;SAVE A COPY
	JSR	DIV8	;MAKE THE BYTE LOCATION
	TAY
	PLA
	AND	#7	;GET BIT INDEX
	TAX
	LDA	BITS,X	;GET BIT TO TEST FOR
	RTS

BITS:	.byte	1,2,4,8,$10,$20,$40,$80

CMD1F: 	JSR	FINDFREE	;LAUNCH ENEMY
	BNE	CMD1E8		;DONE IF NONE AVAILABLE
	TXA
	TAY			;MAKE ENEMY INDEX HERE
	LDX	SAFEBYTE	;GET OUR INDEX FROM HERE
	LDA	DATA1		;GET ENEMY TYPE
	JSR	REGVAL
	STA	BYTE1		;SET ENEMY TYPE FOR FINISH_ENEMY
CMD1F2:	LDA	#-1
	STA	ENEMYLCOL,Y	;SET THAT THIS LAUNCH HAS NO ORIGIN
	STA	ENEMYHCOL,Y

	LDA	#0
	STA	ENEMYSTAT,Y	;SET AS NOT ASLEEP

	LDA	DATA4
	STA	ENEMYP2,Y	;SET PARAMETER 2 FROM OUR COMMAND.
	
	LDA	ENEMYX,X
	CLC
	ADC	DATA2		;MAKE LAUNCH X
	STA	ENEMYX,Y
	LDA	ENEMYY,X
	CLC
	ADC	DATA3
	STA	ENEMYY,Y	;MAKE LAUNCH Y

CMD1F20:
	JSR	SETPTR		;SAVE OUR EXECUTION POINTER

	LDA	SAFEBYTE
	PHA			;SAVE OUR ENEMY INDEX
	STY	SAFEBYTE
	LDA	#-1
	STA	ENEMYNUM,Y	;SET AS NO PERMANENT MEMORY FOR THIS ONE
	JSR	FINISH_ENEMY	;SHARE CODE WITH ENEMY LAUNCH WORLD COMMAND
	PLA
	STA	SAFEBYTE
	TAX
	JSR	EBACKUP		;PUT OUR EXECUTE POINTER BACK AND DONE
	RTS

SETPTR:				;CALL HERE TO TAKE ENEMYPTR AND PUT IT INTO
				;THE ENEMY'S SAVE LOCATION
	LDA	ENEMYPTR
	STA	ENEMYINL,X
	LDA	ENEMYPTR+1
	STA	ENEMYINH,X	;RESTORE POINTER FOR NEXT TIME
SPTR9:	RTS

CMD20:	LDA	ENEMYSTAT,X	;MOVE EXECUTE POINTER IF STANDING
	AND	#$10	   	;GET STANDING BIT
	BEQ	SPTR9
CMD205:	JMP	MOVEPTR		;MOVE POINTER IF SOLID SET

CMD21:	LDA	ENEMYDAMG,X	;APPLY DAMAGE TO HEALTH
	AND	#$07		;GET DAMAGE
	STA	SAFEWORD
	EOR	ENEMYDAMG,X
	STA	ENEMYDAMG,X	;PUT BACK ZEROED
	LDA	ENEMYHEALTH,X	;GET CURRENT HEALTH LEVEL
	SEC
	SBC	SAFEWORD
	BCS	CMD215
	LDA	#0		;DON'T GO BELOW ZERO
CMD215:	STA	ENEMYHEALTH,X
	RTS

CMD22:	LDA	DATA3		;MOVE EXECUTE POINTER IF HEALTH LESS OR =
	CMP	ENEMYHEALTH,X	;SEE IF LESS THAN OR EQUAL TO 
	BCS	CMD205
	RTS

CMD23:	LDA	DATA3		;MOVE EXECUTE POINTER IF LAST ATTACKER
	CMP	ENEMYID,X	;SEE IF MATCH
	BEQ	CMD205
	RTS

CMD24:	JSR	GETATTACK	;MOVE EXECUTE POINTER IF ATTACK #
	CMP	DATA3		;SEE IF MATCH
	BEQ	CMD205
	RTS

;THIS SUB WILL RETURN THE ATTACK NUMBER OF THE LAST ATTACK IN A.  IT USES
;SUBSVAR1.
GETATTACK:
	LDA	ENEMYDAMG,X	;MOVE EXECUTE POINTER IF ATTACK #
	PHA
	AND	#$08		;GET 16-31 ATTACK NUMBER FLAG
	ASL	A		;MAKE INTO 0 OR 16.	
	STA	SUBSVAR1
	PLA
	JSR	DIV16		;MAKE ATTACK NUMBER TO MATCH
	CLC
	ADC	SUBSVAR1
	RTS


CMD25:	LDA	ENEMYXMOM,X	;MOVE EXECUTE POINTER IF MOMENTUM
	BPL	CMD251
	JSR	NEGATE
CMD251:	STA	SAFEX2
	LDA	ENEMYYMOM,X
	BPL	CMD252
	JSR	NEGATE
CMD252:	STA	SAFEY2
	LDA	DATA3		;SEE IF WE CARE ABOUT X
	CMP	#-1
	BEQ	CMD254
	CMP	SAFEX2		;SEE IF ITS LESS THAN OR EQUAL
	BCS	CMD254
CMD253:	RTS
CMD254:	LDA	DATA4		;SEE IF WE CARE ABOUT Y
	CMP	#-1
	BEQ	CMD257
	CMP	SAFEY2		;SEE IF ITS LESS THAN OR EQUAL
	BCC	CMD253
CMD257:	JMP	MOVEPTR

CMD26:	LDA	ENEMYSTAT,X		;REARM ATTACK
	ORA	#$20		
	STA	ENEMYSTAT,X	
	RTS

CMD27:	LDA	ENEMYSTAT,X	;MOVE EXECUTE POINTER IF YOU HAVE ATTACKED
	AND	#8
	BEQ	CMD253
	EOR	ENEMYSTAT,X
	STA	ENEMYSTAT,X
	JMP	MOVEPTR

CMD28:	LDA	SAFEBYTE	;MOVE EXECUTE POINTER IF >= TO FRAME #
	JSR	GETFRAME	;CHECK FRAME # OF THIS SPRITE
	CPX	DATA3		;SEE IF MATCH OR BIGGER
	BCS	CMD257		;IF SO, MOVE POINTER
	RTS

CMD29:
.ifdef XDISPLAY;IFDEF( `XDISPLAY', `		
	LDX	DATA1		;DISPLAY INFRONT/BEHIND
	LDA	SAFEBYTE
	JSR	INFRONT
	RTS
.endif ;' )

CMD2A:	LDA	DATA3		;MOVE IF PARAM1
	CMP	ENEMYP1,X	;MATCH?
	BEQ	CMD257
	RTS

CMD2B:	LDA	DATA3		;MOVE IF PARAM2
	CMP	ENEMYP2,X	;MATCH?
	BEQ	CMD257
	RTS

CMD2C:	LDA	DATA1		;SET INSTRUCTIONS TO EXECUTE
	STA	PASSCNT
	RTS

CMD2D:	JSR	USEMOM2		;SET MOMENTUMS
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD2E:	LDA	#-1		;TEST FOR WORLD FLAG COMMANDS
	STA	ENEMYLROW,X	;SET LAST ROW TO 255 TO FORCE TEST
	JMP	NOCMDS		;SET US TO LEAVE.

CMD2F:	LDA	ENEMYINTS,X	;DISABLE INTERRUPTS
	ORA	DATA1
	STA	ENEMYINTS,X
	RTS	

CMD30:	LDA	ENEMYINTS,X	;ENABLE INTERRUPTS
	ORA	DATA1
	EOR	DATA1
	STA	ENEMYINTS,X
	RTS

CMD31:	LDA	#0		;PLAY
	STA	SAFEX		;SET CHANNEL FOR LOOP

CMD315:	LDA	SAFEX
	ASL	A
	TAY
	LDA	DATA1,Y
	STA	SAFEWORD
	LDA	DATA2,Y
	STA	SAFEWORD+1
	JSR	DOCHANNEL	;DO THIS SOUND CHANNEL
	LDA	SAFEX
	CMP	#4
	BNE	CMD315
	RTS

;THIS SUB WILL TAKE SOUND COMMAND WORD FLAG IN SAFEWORD FOR CHANNEL
;IN SAFEX AND ACTIVATE IT.  IT SUPPORTS -1 AND 0.  SAFEX IS INCREMENTED.

DOCHANNEL:
	LDA	SAFEWORD+1
	CMP	#-1		;SEE IF IGNORE IT
	BEQ	CMD319
	LDA	SAFEX
	JSR	SILENCE		;IF 0 OR PLAY, SILENCE THE CHANNEL
CMD316:	LDA	SAFEWORD+1	;SEE IF JUST SILENCE IT
	BEQ	CMD319		
	TAY
	LDA	SAFEWORD
	TAX
	LDA	SAFEX
	JSR	PLAY
CMD319:	INC	SAFEX
	RTS

CMD32:	LDA	DATA1		;SET BOUNCE FACTOR
	STA	ENEMYBOUNCE,X
	RTS

CMD33:	JSR	GETJOY		;SET MOMENTUM TO JOYSTICK X MOMENTUM
	LDA	JOYX,Y
	STA	DATA1
	LDA	#-1	
	STA	DATA2		;SIGNAL NO CHANGE FOR Y
	LDA	#0
	STA	JOYX,Y		;AND THEN ZERO IT
CMD335:	JSR	USEMOM3
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD34:	JSR	GETJOY		;SET MOMENTUM TO JOYSTICK Y MOMENTUM
	LDA	JOYY,Y
	STA	DATA2
	LDA	#-1
	STA	DATA1
	LDA	#0
	STA	JOYY,Y		;AND THEN ZERO IT
	JMP	CMD335

CMD35:	LDA	DATA3		;MOVE EXECUTE POINTER IF ACTIVE
	STA	SAFEX
	LDA	DATA4
	STA	SAFEY
	LDA	DATA5
	STA	SAFEY2
	JSR	WORDREG
CMD351:	JSR	FINDENEMY	;TRY TO FIND THIS ONE
	BNE	CMD359
	LDA	ENEMYSTAT,Y	;BUT SEE IF SLEEPING
	BMI	CMD359
	JMP	MOVEPTR		;MOVE POINTER IF MATCH

;THIS ROUTINE CHECKS SAFEY2:SAFEY AND SEES IF THE FULL WORD IS 0 (<REGISTER>).
;IF SO, THE REGISTER IS PUT THERE INSTEAD.

WORDREG:
	LDA	SAFEY2
	BNE	WRG10
	LDA	SAFEY
	BNE	WRG10
	LDA	ENEMYLREG,X
	STA	SAFEY
	LDA	ENEMYHREG,X
	STA	SAFEY2
WRG10:	RTS

;THIS ROUTINE WILL SEARCH ALL ENTITIES FOR A SPECIFIED ONE.  LOAD
;SAFEX WITH 0 TO SEARCH BY WORLD COLUMN THAT LAUNCHED IT OR LOAD IT
;WITH 1 TO SEARCH BY ENEMY ID.  LOAD SAFEY AND SAFEY2 WITH THE NUMBER TO 
;MATCH. (SAFEY ONLY IF ENEMYID, SAFEY2 NEEDED IF WORLD COLUMN (WORD).
;LOAD SAFEBYTE WITH ANY ENTITY INDEX TO
;BE IGNORED (USUALLY YOUR OWN) OR -1 TO SEARCH ALL OF THEM.  ON RETURN,
;IF Z THEN Y HAS THE ENTITY THAT WAS FOUND (ITS INDEX).  SAFEWORD
;IS NOT CHANGED AND X = SAFEBYTE ON RETURN.

FINDENEMY:
	LDY	#0		;START THE SEARCH WITH #0
CMD355:	JSR	VALID2		;SKIP IF OUR INDEX OR INVALID
	BEQ	FINDNEXT	
	LDX	SAFEX		;SEE IF ID BY WORLD COL
	BNE	CMD356
	LDA	ENEMYHCOL,Y	;IF WORLD COL, NEED WORD CHECK
	CMP	SAFEY2
	BNE	FINDNEXT
	LDA	ENEMYLCOL,Y	;IF MATCH, USE SAME CODE TO CHECK LOW BYTE
CMD356:	CMP	SAFEY		;GOT A MATCH?
	BEQ	CMD359

FINDNEXT:			;ENTER HERE TO CONTINUE FINDENEMY
	INY
	CPY	#ECNT		;CHECK ALL ENTRIES FOR MATCH
	BNE	CMD355
	CPY	#0		;SET NZ IF NONE FOUND
CMD359:	PHP
	LDX	SAFEBYTE
	PLP
	RTS

;THIS SUB WILL CHECK TO SEE IF AN ENEMY SPECIFIED IN INDEX Y IS VALID
;(ENEMY0 <> -1).  ON RETURN, IF Z, ITS INVALID.  CALL VALID2 ENTRY
;POINT TO MAKE SURE ITS NOT THE SAME AS ENEMY IN SAFEBYTE TOO.

;IF YOU CALL VALID ONLY AND IT RETURNS Z, A=-1.

VALID2:
	CPY	SAFEBYTE	;CALL HERE TO RULE OUT MATCHES TO SAFEBYTE
	BEQ	VLD10
VALID:	  			;CALL HERE FOR CHECK WITHOUT SAFEBYTE COMPARE
	LDA	ENEMY0,Y	
	CMP	#-1
VLD10:	RTS

	
CMD36:	LDA	DATA2		;HURT ENTITY
	CMP	#ALL		;HURT ALL?
	BEQ	CMD3610	
	STA	SAFEX		;PUT THESE FOR CALL TO FINDENEMY
	LDA	DATA3
	STA	SAFEY
	LDA	DATA4
	STA	SAFEY2
	BNE	CMD361
       	LDA	SAFEY
	JSR	REGVAL
	STA	SAFEY
CMD361:	JSR	FINDENEMY
	BNE	CMD364		;IF NONE, IGNORE CALL.
CMD362:	LDA	ENEMYD3,X
	PHA			;SAVE OUR DAMAGE FLAG
	LDA	DATA1
	STA	ENEMYD3,X	;FAKE IT FOR A CALL TO REPORT
	JSR	REPORT 		;REPORT DAMAGE TO THAT ENTITY
	PLA
	STA	ENEMYD3,X	;RESTORE OUR DAMAGE FLAGS
	JSR	FINDNEXT	;TRY ANOTHER
	BEQ	CMD362
CMD364:	RTS	


CMD3610:			;ITS HURT ALL
	LDY	#0		;START WITH ENEMY 0
CMD3611:
	JSR	VALID2		;SKIP IF US OR INVALID
	BEQ	CMD3620
	LDA	ENEMYJSTAT,Y	;SEE IF THIS ONE HAS A JOYSTICK ATTACHED
	BPL	CMD3620		;IF SO, DON'T HURT IT
	LDA	ENEMYD3,X
	PHA			;SAVE OUR DAMAGE FLAG
	LDA	DATA1
	STA	ENEMYD3,X	;FAKE IT FOR A CALL TO REPORT
	JSR	REPORT 		;REPORT DAMAGE TO THAT ENTITY
	PLA
	STA	ENEMYD3,X	;RESTORE OUR DAMAGE FLAGS
CMD3620:	
	INY
	CPY	#ECNT
	BNE	CMD3611
	RTS	


CMD37:
.ifdef XADDSCORE;IFDEF( `XADDSCORE', `		
	LDA	DATA3		;ADD TO THE SCORE
	STA	SAFEY2
	LDA	DATA2
	STA	SAFEY
	JSR	WORDREG
	JSR	FINDJOY		;FIGURE OUT WHICH JOYSTICK TO USE
	BNE	CMD372		;SKIP IF NONE
	LDA	SCOREL,Y
	CLC
	ADC	SAFEY		;ADD LOW BYTE
	STA	SCOREL,Y
	LDA	SCOREH,Y
	ADC	SAFEY2
	STA	SCOREH,Y
	LDX	SAFEY2		;GET BACK HIGH BYTE
	BMI	CMD375		;SKIP IF NEGATIVE
	BCC	CMD372		;PLUS SCORE MUST NOT HAVE CARRY
	LDA	#-1
CMD371:	STA	SCOREL,Y
	STA	SCOREH,Y
CMD372:	RTS

CMD375:	LDA	#0
	BCC	CMD371		;MINUS SCORE MUST HAVE CARRY
	RTS
.endif ;' )

CMD38:
.ifdef XSETSCORE;IFDEF( `XSETSCORE', `		
	JSR	FINDJOY		;SET THE SCORE
	BNE	CMD382		;SKIP IF NONE
	LDA	DATA2
	STA	SCOREL,Y
	LDA	DATA3
	STA	SCOREH,Y
CMD382:	RTS
.endif ;' )

CMD39: 
.ifdef XSCORE;IFDEF( `XSCORE', `		
	JSR	FINDJOY		;MOVE EXECUTE POINT IF SCORE
	BNE	CMD399		;SKIP IF NONE
	SEC
	LDA	SCOREL,Y
	SBC	DATA2		;SUBTRACT LOW BYTE
	LDA	SCOREH,Y
	SBC	DATA3		;AND HIGH
	BCC	CMD399		;SKIP IF NOT GREATER OR EQUAL
	LDA	DATA4
	STA	DATA1
	LDA	DATA5
	STA	DATA2
	JMP	MOVEPTR
CMD399:	RTS
.endif ;' )

CMD3A:	JSR	FINDJOY		;ADD TO THE HERO COUNT
	BNE	CMD3A2		;SKIP IF NONE
	LDA	DATA2
	JSR	REGVAL
CMD3A7:	CLC
	ADC	HEROCOUNT,Y	;ADD HERO COUNT
	STA	HEROCOUNT,Y
	LDX	DATA2		;GET BACK SIGN OF BYTE
	BMI	CMD3A5		;SKIP IF NEGATIVE
	BCC	CMD3A2		;PLUS SCORE MUST NOT HAVE CARRY
	LDA	#-1
CMD3A1:	STA	HEROCOUNT,Y
CMD3A2:	RTS
CMD3A5:	LDA	#0
	BCC	CMD3A1		;MINUS SCORE MUST HAVE CARRY
	RTS

CMD3B:	JSR	FINDJOY		;SET THE HERO COUNT
	BNE	CMD3B2		;SKIP IF NONE
	LDA	DATA2
	JSR	REGVAL
	STA	HEROCOUNT,Y
CMD3B2:	RTS

CMD3C:	JSR	FINDJOY		;MOVE IF HERO COUNT
	BNE	CMD3C9		;SKIP IF NONE
	LDA	HEROCOUNT,Y	;GET COUNT TO CHECK FOR
	CMP	DATA2		;SEE IF ABOVE OR EQUAL
	BCC	CMD3C9
	LDA	DATA3
	STA	DATA1
	LDA	DATA4
	STA	DATA2
	JMP	MOVEPTR		;IF SO, USE THE POINTER
CMD3C9:	RTS

CMD3D:	LDA	RESETFLG	;MOVE IF RESET FALSE
	LDY	#0
	STY	RESETFLG
	CMP	#0
	BNE	CMD3C9
	JMP	MOVEPTR

CMD3E:				;LOAD REGISTER
CMD3E1:	LDA	DATA1
	STA	ENEMYLREG,X
	LDA	DATA2
	STA	ENEMYHREG,X
	RTS

CMD3F:	JSR	CLEARHIGH	;FETCH REGISTER
	LDY	DATA1		
	LDA	ENEMYP2,X	;ASSUME PARAM2
	CPY	#PARAM2
	BNE	CMD3F3
CMD3F1:	JMP	CMD3F9

CMD3F3:	LDA	ENEMYP1,X	;ASSUME THE LAST WORLD COMMAND
	CPY	#WORLDCMD
	BEQ	CMD3F1	

	JSR	GETATTACK	;MOVE EXECUTE POINTER IF ATTACK #
	CPY	#ATTACK
	BEQ	CMD3F1

	LDA	ENEMYID,X	;GET LAST ATTACKER
	CPY	#ATTACKER	;LAST ATTACKER?
	BEQ	CMD3F1

	LDA	ENEMYVCTM,X	;GET LAST VICTIM
	CPY	#VICTIM		;LAST VICTIM?
	BEQ	CMD3F1

	LDA	CURWORLD	;CURRENT WORLD?
	CPY	#WORLD
	BEQ	CMD3F9

	LDA	ENEMYHEALTH,X	;HEALTH LEVEL?
	CPY	#HEALTH
	BEQ	CMD3F9

	LDA	ENEMY0,X	;ENTITY #?
	CPY	#ENTITY
	BEQ	CMD3F9

	LDA	ENEMYTRACK,X	;DIRECTION FLAG?
	AND	#$C0
	CPY	#FACE
	BEQ	CMD3F9

	LDA	ENEMYCENTR,X	;X LOCATION?
	CPY	#XVISUAL
	BEQ	CMD3F9

	LDA	ENEMYFEET,X	;Y LOCATION?
	CPY	#YVISUAL
	BEQ	CMD3F9

	LDA	ENEMYBEHAVE,X	;ENEMY BEHAVIOR BITS?
	CPY	#BEHAVIOR
	BEQ	CMD3F9

	LDA	ENEMYXMOM,X	;X MOMENTUM?
	CPY	#XMOM
	BEQ	CMD3F9
	
	LDA	ENEMYYMOM,X	;Y MOMENTUM?
	CPY	#YMOM
	BEQ	CMD3F9

	CPY	#SLOTS		;FREE SLOTS?
	BEQ	CMD3F8

	CPY	#XDIR		;X DIRECTION TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#YDIR		;Y DIRECTION TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#XDIST		;X DISTANCE TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#YDIST		;Y DISTANCE TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#DEF_SOLID	;DEFAULT SOLID FOR THIS ENTITY?
	BEQ	CMD3F20

	LDA	ENEMYXFRICT,X
	CPY	#XLINK
	BEQ	CMD3F9

	LDA	ENEMYYFRICT,X
	CPY	#YLINK
	BEQ	CMD3F9

	LDA	ENEMYFLGS,X
	CPY	#ENTITYBITS
	BEQ	CMD3F9

	CPY	#MUSTDEFEAT
	BEQ	CMD3F25

	LDA	ENEMYDAMG,X
	AND	#$07
	CPY	#DAMAGE
	BEQ	CMD3F9
	
	JSR	GETRANDOM

CMD3F9:	STA	ENEMYLREG,X
	RTS

CMD3F9A:   			;GO HERE TO RETURN VALUE IN BOTH REGISTERS
	STA	ENEMYLREG,X	;(TYPICALLY -1).
	STA	ENEMYHREG,X
	RTS

CMD3F8:	JSR	GETSLOTS

CMD3F2:	TYA
	LDX	SAFEBYTE
	JMP	CMD3F9

CMD3F7:	STY	SAFEX		;SET YDIR OR XDIR FLAG
	JSR	MAKETRACKS	;GET TARGET X AND Y 
	CMP	#-1
	BEQ	CMD3F9A		;IF NONE, RETURN -1.
	LDA	SAFEX		;GET WHICH WE WANTED.  Y=YDIR
	CMP	#YDIST		;Y DISTANCE?
	BEQ	CMD3F15
	CMP	#XDIST
	BEQ	CMD3F17
	CMP	#YDIR
	BEQ	CMD3F6
	LDY	#0		;ASSUME HE'S RIGHT OF US
	LDA	SUBSVAR1	;GET HIS LOCATION
       	CMP	ENEMYCENTR,X	;COMPARE TO OUR X SAME AS TRACKDIR DOES
	BCS	CMD3F2
	LDY	#1		;HE WAS TO THE LEFT.
	JMP	CMD3F2

CMD3F6:	LDY	#0		;ASSUME HE'S BELOW US
	LDA	SUBSVAR2
	CMP	ENEMYFEET,X
	BCS	CMD3F2
	LDY	#1    		;HE WAS ABOVE US
	JMP	CMD3F2

CMD3F20:
	JSR	POINTENEMY	;POINT TO THE ENEMY TABLE FOR THIS ONE
	LDY	#3
	LDA	(SUBSVAR1),Y	;GET THE SOLID VALUE
	JMP	CMD3F9

CMD3F15:
	LDA	SUBSVAR2
	SEC
	SBC	ENEMYFEET,X	;MAKE DISTANCE
CMD3F18:
	BPL	CMD3F16
	JSR	NEGATE		;RETURN ABSOLUTE VALUE
CMD3F16:
	JMP	CMD3F9

CMD3F17:
	LDA	SUBSVAR1
	SEC
	SBC	ENEMYCENTR,X	;RETURN ABSOLUTE X DISTANCE TO TARGET
	JMP	CMD3F18

CMD3F25:
	LDY	#0
	STY	SAFEWORD
CMD3F26:
	JSR	VALID2		;SKIP USJ OR INVALID ENTRIES
	BEQ	CMD3F28
	BEQ	CMD3F28
	LDA	ENEMYFLGS,Y	;GET THE FLAGS
	AND	#4
	BEQ	CMD3F28
	INC	SAFEWORD
CMD3F28:	
	INY
	CPY	#ECNT
	BNE	CMD3F26
	LDA	SAFEWORD
	JMP	CMD3F9

;THIS SUB WILL RETURN THE NUMBER OF FREE ENTITY SLOTS IN Y.  IT CHANGES
;ALL REGISTERS.

GETSLOTS:
	LDY	#0
	LDX	#0
GSL10:	LDA	ENEMY0,X
	CMP	#-1
	BNE	GSL20
	INY		;FOR EVERY AVAILABLE SLOT, INCREASE COUNT
GSL20:	INX
	CPX	#ECNT	;DONE?
	BNE	GSL10
	RTS	

CMD40:	LDA	DATA1		;AND REGISTER
	AND	ENEMYLREG,X
	STA	ENEMYLREG,X
	LDA	DATA2
	AND	ENEMYHREG,X
	STA	ENEMYHREG,X
CMD401:	RTS

CMD41:				;COMPARE REGISTER
CMD411:	LDA	ENEMYLREG,X	;GET REGISTER VALUE
	SEC
	SBC	DATA3
	LDA	ENEMYHREG,X
	SBC	DATA4
	BCC	CMD401
	JMP	MOVEPTR
		
CMD42:	LDA	DATA1		;ADD REGISTER
	CLC
	ADC	ENEMYLREG,X
	STA	ENEMYLREG,X
	LDA	DATA2
	ADC	ENEMYHREG,X
	STA	ENEMYHREG,X
	RTS

CMD43:	LDA	DATA1		;SET PAUSE
	EOR	#OFF		;MAKE OFF BE FALSE
	STA	PAUSEFLG
	RTS

CMD44:	LDA	ENEMYLREG,X	;INDEX		
	ASL	A
	CLC
	ADC	ENEMYPTR
	STA	ENEMYPTR
	BCC	CMD442
	INC	ENEMYPTR+1
CMD442:	LDX	#2		;GET THE SELECTION
	JSR	FILLCBUF
	LDX	SAFEBYTE 
	LDA	DATA1
	STA	DATA2
	LDA	CMDBUF
	STA	DATA1
CMD444:	JMP	MOVEPTR	

CMD45:
.ifdef XVICTOR;IFDEF( `XVICTIM', `		
	LDA	DATA3		;MOVE EXECUTE POINTER IF LAST VICTIM
	CMP	ENEMYVCTM,X	;SEE IF MATCH
	BEQ	CMD444
	RTS
.endif ;' )

CMD46:	JSR	DATAINDX		;LOAD BYTE FROM COMMON RAM
	BEQ	CMD465
	LDA	COMMONDATA,Y
	STA	ENEMYLREG,X
CLEARHIGH:			;CLEAR THE HIGH REGISTER FOR ENTITY X
	LDA	#0
	STA	ENEMYHREG,X
	RTS

CMD465:	LDA	STATERAM,Y	;WE ARE LOADING THE <STATE> VALUE
	STA	ENEMYLREG,X
	LDA	STATERAM+1,Y
	STA	ENEMYHREG,X
	RTS

CMD47:	JSR	DATAINDX		;STORE BYTE INTO COMMON RAM
	BEQ	CMD475
	LDA	ENEMYLREG,X
	STA	COMMONDATA,Y
	RTS

CMD475:	LDA	ENEMYLREG,X	;STORE INTO THE STATE VARIABLE
	STA	STATERAM,Y
	LDA	ENEMYHREG,X
	STA	STATERAM+1,Y
	RTS

;THIS SUB WILL TAKE A COMMON DATA AREA SPECIFIER IN DATA1 AND RETURN
;AN INDEX TO IT IN Y.  ON RETURN, IF Z THEN Y WAS <STATE>.

DATAINDX:
	LDY	DATA1		
	CPY	#STATE
	BNE	DIX10
	LDA	SAFEBYTE
	ASL	A
	TAY
	LDA	#0
DIX10:	RTS	

CMD48:	JSR	DATAINDX		;ADD BYTE FROM COMMON RAM
	BEQ	CMD485
	LDA	ENEMYLREG,X
	CLC
	ADC	COMMONDATA,Y
	STA	ENEMYLREG,X
	BCC	CMD481
	INC	ENEMYHREG,X
CMD481:	RTS

CMD485:	LDA	ENEMYLREG,X		;IF <STATE> ADD FULL WORD
	CLC
	ADC	STATERAM,Y
	STA	ENEMYLREG,X
	LDA	ENEMYHREG,X
	ADC	STATERAM+1,Y
	STA	ENEMYHREG,X
	RTS

CMD49:	LDA	#DINGSLOT	;NOISE
	LDA	#DINGSLOT
	JSR	SILENCE		;IF 0 OR PLAY, SILENCE THE CHANNEL

CMD50:	LDA	DATA2		;LOW PRIORITY NOISE
	BEQ	CMD499		;SKIP IF JUST SILENCE IT (ILLEGAL)
	TAY
	LDA	DATA1
	TAX
	LDA	#DINGSLOT 
	JSR	PLAY
CMD499:	RTS

CMD4A:	LDA	DATA1		;SET ALTERNATE COUNTER.  
	JSR	REGVAL		
	STA	ENEMYALT,X
CMD4A9:	RTS

CMD4B:	LDA	DATA3		;MOVE EXECUTE POINTER IF ALT COUNTER BELOW
	CMP	ENEMYALT,X	;BELOW THE VALUE?
	BCC	CMD4A9
	JMP	MOVEPTR

CMD4C:	LDA	DATA1		;SET DIRECTION FLAG
	JSR	REGVAL		
	STA	ENEMYFACE,X
	RTS	     

CMD4D:	LDX	DATA1		;SET BACKGROUND PALETTE
	LDY	DATA2
	CPY	#-1
	BNE	CMD4D5
	JSR	WORLD_BPAL
	RTS
CMD4D5:	JSR	BACKPAL
	RTS

CMD4E:	LDX	DATA1		;SET SPRITE PALETTE
	LDY	DATA2
	CPY	#-1
	BNE	CMD4E5
	JSR	WORLD_SPAL
	RTS
CMD4E5:	JSR	SPRITEPAL
	RTS

CMD4F:	LDA	DATA1		;SHAKE.
	STA	SHAKEAMT	;SET SHAKE AMOUNT
CMD4F5:	RTS

CMD51:	LDA	DATA3		;MOVE IF X<VALUE
	CMP	ENEMYCENTR,X
	BCC	CMD4F5
CMD515:	JMP	MOVEPTR

CMD52:	LDA	DATA3		;MOVE IF Y<VALUE
	CMP	ENEMYFEET,X	;COMPARE HIS LOW BYTE TO WHAT WE WANT
	BCS	CMD515
	RTS			;CARRY ALWAYS SET IF ITS BIGGER

CMD53:	LDA	DATA3		;EQUAL REGISTER
	CMP	ENEMYLREG,X	;GET REGISTER VALUE
	BNE	CMD4F5
	LDA	DATA4
	CMP	ENEMYHREG,X
	BEQ	CMD515
	RTS

CMD54: 	JSR	SETPTR		;SAVE ENEMYPTR
	LDA	DATA1		;INDEX INTO TABLE
	CLC
	ADC	ENEMYLREG,X	;INDEX INTO THE TABLE
	STA	ENEMYPTR
	LDA	DATA2
	ADC	ENEMYHREG,X
	STA	ENEMYPTR+1	;MAKE (ENEMYPTR) POINT TO THE DATA
	LDX	#2
	JSR	FILLCBUF	;GET THE DATA
	LDX	SAFEBYTE	;RESTORE OUR INDEX
	LDA	CMDBUF
	STA	ENEMYLREG,X
	LDA	DATA1
	STA	ENEMYHREG,X
 	JSR	EBACKUP		;RESTORE ENEMYPTR
	RTS	

CMD55: 
.ifdef XDISSCROLL;IFDEF( `XDISSCROLL', `		
	LDA	SCROLLFLG	;DISABLE SCROLLING
	ORA	DATA1		;SET THE BITS
	STA	SCROLLFLG
	RTS
.endif ;' )

CMD56:	LDA	SCROLLFLG	;ENABLE SCROLLING
	ORA	DATA1
	EOR	DATA1		;RESET THE BITS
	STA	SCROLLFLG
	RTS

CMD57: 
.ifdef XSETCOL;IFDEF( `XSETCOL', `		
	LDA	DATA1		;SET WORLD COLUMN
	STA	SAFEY
	LDA	DATA2
	STA	SAFEY2
	JSR	WORDREG
	LDA	SAFEY
	STA	ENEMYLCOL,X
	LDA	SAFEY2
	STA	ENEMYHCOL,X
	RTS
.endif ;' )

CMD58:	JSR	DATAINDX	;COMPARE TO COMMON DATA AREA RAM
	BEQ	CMD585
	LDA	#0
	STA	DATA4		;CLEAR HIGH BYTE FOR COMPARE
	LDA	COMMONDATA,Y
	JMP	CMD586		;GO SHARE CODE
CMD585:	LDA	STATERAM+1,Y
	STA	DATA4
	LDA	STATERAM,Y

CMD586:	TAY			;SAVE LOW BYTE FOR COMPARE
	LDA	DATA2
	STA	DATA1
	LDA	DATA3
	STA	DATA2
	STY	DATA3
	JMP	CMD411

CMD59:	LDA	DATA1		;ADD TO MOMENTUMS USING REGISTER
	JSR	REGVAL
	STA	DATA1
	LDA	DATA2
	JSR	REGVAL
	STA	DATA2
	JSR	USEMOM		
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD5A:	JSR	DATAINDX	;EXCHANGE BYTE WITH COMMON RAM
	BEQ	CMD5A5
	LDA	COMMONDATA,Y
	PHA
	LDA	ENEMYLREG,X
	STA	COMMONDATA,Y
CMD5A2:	PLA
	STA	ENEMYLREG,X
	RTS
CMD5A5:	LDA	STATERAM,Y	;IF <STATE> FULL WORD EXCHANGE
	PHA
	LDA	STATERAM+1,Y
	PHA
	LDA	ENEMYLREG,X
	STA	STATERAM,Y
	LDA	ENEMYHREG,X
	STA	STATERAM+1,Y
	PLA
	STA	ENEMYHREG,X
	JMP	CMD5A2


CMD5B:	LDA	DATA1		;XOR REGISTER
	EOR	ENEMYLREG,X
	STA	ENEMYLREG,X
	RTS

CMD5C: 
.ifdef XRGB;IFDEF( `XRG%, `		
	LDA	DATA1
	JSR	REGVAL		;RGB MONO CONTROL
	STA	DATA1
	LDA	REG2001
	AND	#30
	ORA	DATA1
	STA	REG2001
	RTS
.endif ;' )

CMD5D:	LDA	DATA1
	JSR	REGVAL		;SET BEHAVIOR BIT
	ORA	ENEMYBEHAVE,X
	STA	ENEMYBEHAVE,X
	RTS

CMD5E:	LDA	DATA1
	JSR	REGVAL		;RESET BEHAVIOR BIT
	STA	DATA1
	ORA	ENEMYBEHAVE,X
	EOR	DATA1
	STA	ENEMYBEHAVE,X
CMD5E5:	RTS

CMD5F:	LDA	DATA3		;IF BEHAVIOR BIT SET
	AND	ENEMYBEHAVE,X
	BEQ	CMD5E5
	JMP	MOVEPTR

CMD60:	LDA	DATA3		;IF BEHAVIOR BIT NOT SET
	AND	ENEMYBEHAVE,X
	BNE	CMD5E5
	JMP	MOVEPTR

;CREATE IS ALSO SHARED BY SPAWN.  SPAWN HAS THE SAME PARAMETERS BUT
;EXPECTS THAT ON RETURN Y WILL HAVE THE CREATED ENTITIES INDEX AND
;Z INDICATES SUCCESS.

CMD61: 	JSR	FINDFREE	;CREATE ENEMY
	BNE	CMD5E5		;DONE IF NONE AVAILABLE
	TXA
	TAY			;MAKE ENEMY INDEX HERE
	LDX	SAFEBYTE	;GET OUR INDEX FROM HERE
	LDA	DATA1		;GET ENEMY TYPE
	JSR	REGVAL
	STA	BYTE1		;SAVE FOR CMD1F20
	LDA	#-1
	STA	ENEMYLCOL,Y	;SET THAT THIS LAUNCH HAS NO ORIGIN
	STA	ENEMYHCOL,Y

	LDA	#0
	STA	ENEMYSTAT,Y	;SET AS NOT ASLEEP

	LDA	DATA4
	STA	ENEMYP2,Y	;SET PARAMETER 2 FROM OUR COMMAND.
	
	LDA	DATA2		;GET LAUNCH X
	STA	ENEMYX,Y
	LDA	DATA3
	STA	ENEMYY,Y	;MAKE LAUNCH Y
	TYA
	PHA
	JSR	CMD1F20
	PLA
	TAY
	LDA	#0
	RTS

CMD62:	LDA	ENEMYTRACK,X	;MOVE EXECUTE POINTER IF STAIR
	BPL	CMD621
	LDX	#-8
	JMP	CMD622
CMD621:	LDX	#8
CMD622:	LDY	#0
	STX	SAFEX2		;SAVE X MOVEMENT DIRECTION
	
	JSR	TESTMOVE	;MAKE SURE WE CAN'T MOVE 8 AHEAD
	BEQ	CMD662		;IF WE CAN, NO STAIR	

	LDA	DATA3
	ASL	A
	ASL	A
	ASL	A		;MAKE AMOUNT UP INTO PIXELS
	JSR	NEGATE		;ABOVE US
	TAY
	LDX	SAFEX2
	JSR	TESTMOVE	;SEE IF WE COULD MOVE THERE
	BNE	CMD662
CMD623:	JMP	MOVEPTR

CMD63:	LDA	DATA2		;ACTIVATE ANIMATION ONLY
	STA	SETUPFLG
	JSR	PICKMOD3	;SET IT UP
	RTS

CMD64:	LDA	DATA1		;CHEAT MODE
	EOR	#OFF
	STA	ENABLE_SELECT
	RTS

CMD65:				;RESET FRICTION COUNTER
	LDA	ENEMYFCTR,X	;GET STATUS BITS
	LDY	DATA1
	BEQ	CMD651
	AND	#$F0		;REMOVE COUNTER ON DELAY TO FRICTION ON
	ORA	#XFCTR
CMD651:	LDY	DATA2
	BEQ	CMD652
	AND	#$0F		;REMOVE Y COUNTER VALUE
	ORA	#YFCTR*16
CMD652:	STA	ENEMYFCTR,X
	RTS

CMD66:				;MOVE EXECUTE POINTER IF FLOOR

CMD661:	LDA	DATA3
	ASL	A
	ASL	A
	ASL	A		;MAKE INTO PIXELS
	TAY
	LDX	#0
	JSR	TESTMOVE	;SEE IF WE COULD MOVE THERE
	BNE	CMD623		;IF NOT, WE FOUND A LEDGE
	DEC	DATA3
	BNE	CMD661
CMD662:	RTS

CMD67: 	LDA	DATA3
	STA	SAFEX
	LDA	DATA4		;LINK TO ENEMY.  FIRST SKIP X AND Y DISPLACE
	STA	SAFEY
	LDA	DATA5
	STA	SAFEY2
	BNE	CMD671
	LDA	SAFEY
	JSR	REGVAL
	STA	SAFEY		;MAKE VALUES FOR FINDENEMY
CMD671:	JSR	FINDENEMY	;TRY TO FIND THIS ONE
	BNE	CMD662		;DON'T LINK IF NONE
	TYA
	STA	ENEMYLINK,X	;SET THIS ENTITY AS LINKED TO ENTITY Y
	LDA	DATA1
	CMP	#-1
	BNE	CMD672
       	LDA	ENEMYX,X
	SEC
	SBC	ENEMYX,Y	;MAKE OFFSET IF -1 SPECIFIED
CMD672:	STA	ENEMYXFRICT,X
	LDA	DATA2
	CMP	#-1
	BNE	CMD673
       	LDA	ENEMYY,X
	SEC
	SBC	ENEMYY,Y	;MAKE OFFSET IF -1 SPECIFIED
CMD673:	STA	ENEMYYFRICT,X	;SET OFFSETS FOR THE LINK
	JMP	NOCMDS		;LET EXIT CODE POSITION HIM

CMD68:	LDA	#-1		;UNLINK
	STA	ENEMYLINK,X
	LDA	#DEF_XFRICT
	STA	ENEMYXFRICT,X
	LDA	#DEF_YFRICT	;SET FRICTIONS
	STA	ENEMYYFRICT,X
	RTS	

CMD69:	LDA	DATA2		;SPAWN
	PHA			;SAVE RELATIVE OFFSET FOR X
	LDA	#255
	STA	DATA2		
	LDA	DATA3
	PHA	     		;SAVE Y RELATIVE OFFSET TOO
	LDA	#$F8
	SEC
	SBC	SPYADJ		;MAKE Y THAT HIDES IT UNTIL PUTLINK FIXES IT
	STA	DATA3
 	JSR	CMD61		;SPAWN ENEMY
	BNE	CMD691
	LDA	SAFEBYTE
	STA	ENEMYLINK,Y	;SET AS LINKED TO US
	PLA
	STA	ENEMYYFRICT,Y
	PLA
	STA	ENEMYXFRICT,Y	;SET RELATIVE OFFSETS FOR LINK
	LDA	SAFEBYTE
	PHA			;SAVE OUR INDEX
	STY	SAFEBYTE
	JSR	PUTLINK		;PUT HIM WITH CORRECT INVERSION
	PLA
	STA	SAFEBYTE	
	RTS
CMD691:	PLA			;IF CAN'T CREATE, THROW OUT RELATIVE OFFSETS
	PLA
	RTS

CMD6A:	LDA	ENEMYJSTAT,X		;HALF FREQUENCY
	AND	#$BF		;ASSUME OFF
	LDY	DATA1
	CPY	#OFF		;WAS IT OFF?
	BEQ	CMD6A5
	ORA	#$40
CMD6A5:	STA	ENEMYJSTAT,X
CMD6A6:	RTS

CMD6B:	LDA	ENEMYLINK,X	;MOVE IF LINKED
	CMP	#-1
	BEQ	CMD6A6
	JMP	MOVEPTR

CMD6C:	LDA	DATA1		;RELINK TO ENEMY.  
	CMP	#-1
	BEQ	CMD6C2
	JSR	REGVAL
	STA	ENEMYXFRICT,X

CMD6C2:	LDA	DATA2
	CMP	#-1
	BEQ	CMD6C4
	JSR	REGVAL
	STA	ENEMYYFRICT,X	;SET OFFSETS FOR THE LINK
CMD6C4:	JMP	NOCMDS		;LET EXIT CODE POSITION HIM

CMD6D:				;TOPSTAT
	LDA	DATA4		;SEE IF USE CURRENT SET
	BPL	CMD6D1
	LDY	CURWORLD
	LDA	USE_BCHRS,Y
	STA	DATA4
CMD6D1:	LDA	REG2000
	STA	$2000		;DISABLE NMI
	JSR	INITSTAT
	LDA	REG2000
	ORA	#$80		;ENABLE NMI INTS
	STA	$2000
	RTS

CMD6E:	LDA	STATLEN		;WRITE TO STATUS LINE
	BEQ	CMD6E1
CMD6E2:	JSR	EBACKUP		;WE CAN'T GO NOW, RESTORE OLD PTR
	JMP	NOCMDS		;AND EXIT

CMD6E1:	LDA	DATA1	
	STA	STATDATA
	LDA	DATA2
	STA	STATDATA+1	;SET THE POINTER
	LDA	DATA3
	STA	STATROW
	LDA	DATA4
	STA	STATCOL		;SET ROW AND COLUMN
	LDA	#WRITEVID
	STA	STATTYPE	;SET COMMAND TYPE
	LDA	DATA5
	STA	VIDTYPE		;SET VIDEO TYPE
	LDA	DATA6		;GET LENGTH
	STA	STATLEN
	RTS

CMD6F:	LDA	STATLEN		;FILL STATUS LINE
	BNE	CMD6E2
	LDA	DATA1
	STA	STATROW
	LDA	DATA2
	STA	STATCOL		;SET ROW AND COLUMN
	LDA	DATA3
	STA	STATDATA	;AND DATA
	LDA	#FILLVID
	STA	STATTYPE	;SET TYPE OF WRITE
	LDA	DATA4
	STA	VIDTYPE		;SET VIDEO TYPE
	LDA	DATA5
	STA	STATLEN		;SET LENGTH
	RTS

CMD70:	LDA	STATLEN		;SET STATUS LINE PALETTE COLORS
	BNE	CMD6E2
	LDA	DATA1
	STA	STATROW
	JSR	LOADPTR
	CLC
	ADC	#2
	STA	STATDATA	
	TYA
	ADC	#0
	STA	STATDATA+1	;SET POINTER TO THE 8 BYTES IN ROM
	LDA	#SETSTATPAL
	STA	STATTYPE	;SET TYPE OF WRITE
	LDA	#8
	STA	STATLEN		;SET LENGTH
	RTS

CMD71:	JSR	DATAINDX	;DIVIDE BY COMMON DATA AREA RAM
	BEQ	CMD715
	STY	SAFEWORD	;SAVE IT OUT
	LDA	COMMONDATA,Y	;GET BYTE TO DIVIDE BY
	PHA
	LDA	ENEMYHREG,X	;GET BYTE TO DIVIDE
	TAY
	LDA	ENEMYLREG,X
	TAX
	PLA
	JSR	DIVIDE		;DO THE DIVIDE
	TXA			;GET RESULT
	LDX	SAFEBYTE
	STA	ENEMYLREG,X	;SAVE RESULT
	TYA			;GET REMAINDER
	LDY	SAFEWORD
	STA	COMMONDATA,Y	;SET REMAINDER
	JMP	CLEARHIGH

CMD715:	STY	SAFEWORD	;SAVE WHERE TO PUT RESULT.  ITS <STATE>
	LDA	STATERAM,Y
	PHA
	LDA	ENEMYHREG,X
	TAY
	LDA	ENEMYLREG,X
	TAX
	PLA
	JSR	DIVIDE		;MAKE A FULL WORD DIVIDE BY A BYTE VALUE
	TXA
	LDX	SAFEBYTE
	STA	ENEMYLREG,X
	TYA
	LDY	SAFEWORD
	STA	STATERAM,Y	;SET REMAINDER
	LDA	#0
	STA	STATERAM+1,Y	;BUT CLEAR HIGH BYTE
	JMP	CLEARHIGH

CMD72:	JSR	DATAINDX	;MULTIPLY BY COMMON DATA AREA RAM
	BNE	CMD721
	LDA	STATERAM,Y
	JMP	CMD722
CMD721:	LDA	COMMONDATA,Y	;GET BYTE TO MULTIPLY BY
CMD722:	LDY	ENEMYLREG,X	;GET BYTE TO BE MULTIPLIED
	TAX
	JSR	MUL		;DO THE MULTIPLY
	TXA			;GET RESULT
	LDX	SAFEBYTE
	STA	ENEMYLREG,X	;SAVE RESULT
	TYA			;GET HIGH BYTE RESULT
	STA	ENEMYHREG,X	;SET HIGH RESULT
	RTS

CMD73:	JSR	FINDJOY		;GET HEROS COUNT
	BNE	CMD731		;SKIP IF NONE
	LDA	HEROCOUNT,Y	;GET COUNT TO RETURN
	STA	ENEMYLREG,X
	JMP	CLEARHIGH
CMD731:	RTS 

CMD74:
.ifdef XSHOWSCORE;IFDEF( `XSHOWSCORE', `		
	LDA	STATLEN		;SHOW THE SCORE
	BNE	CMD740
	JSR	FINDJOY		;FIGURE OUT WHICH SCORE TO USE
	BNE	CMD731		;END IF NONE APPLICABLE
	STY	STATDATA	;SET INDEX TO USE FOR THE SCORE HERE
	LDA	DATA2
	STA	STATROW
	LDA	DATA3
	STA	STATCOL
	LDA	DATA4
	STA	VIDTYPE		;SET VIDEO PAGE OR STAT FLAG HERE
	LDA	#SHOWSCORE
	STA	STATTYPE	;SET STATUS TYPE
	LDA	#5		;5 DIGITS MAX.  ITS ASSUMED WE INIT THIS!
	STA	STATLEN
	RTS
.endif ;' )
CMD740:	JMP	CMD6E2

CMD75:	LDA	STATLEN		;SHOW THE REGISTER
	BNE	CMD740
	LDA	DATA1
	STA	STATROW
	LDA	DATA2
	STA	STATCOL
	LDA	DATA3
	STA	VIDTYPE		;SET VIDEO PAGE OR STAT FLAG HERE
	LDA	#SHOWREG
	STA	STATTYPE	;SET STATUS TYPE
	LDA	ENEMYLREG,X
	STA	STATDATA	;SET THE REGISTER VALUE
	LDA	ENEMYHREG,X
	STA	STATDATA+1
	LDA	#5		;5 DIGITS MAX.  ITS ASSUMED WE INIT THIS!
	STA	STATLEN
	RTS

CMD76:	LDA	DATA1
	JSR	REGVAL		;SET HEALTH
	STA	ENEMYHEALTH,X
	RTS

CMD77:				;SKIP THE POINTER, GET THE FIRST 2 FLAGS
	LDX	DATA3		;CHECK FIRST
	LDA	#0
	JSR	CHECKCHANNEL
	LDX	DATA4		;CHECK NEXT
	LDA	#1
	JSR	CHECKCHANNEL
	LDX	DATA5		;CHECK NEXT
	LDA	#2
	JSR	CHECKCHANNEL
	LDX	DATA6		;CHECK NEXT
	LDA	#3
	JSR	CHECKCHANNEL
	RTS

CHECKCHANNEL:
	CPX	#DONTCARE
	BEQ	CMD778
	JSR	PLAYING
	BEQ	CMD778
	PLA
	PLA
CMD777:	JMP	MOVEPTR
CMD778:	RTS

CMD78: 	JSR	SETPTR		;REGISTER INDEXED SOUND TABLE
	LDA	#0		
	STA	ENEMYPTR+1
	LDA	ENEMYLREG,X
	ASL	A
	ROL	ENEMYPTR+1
	ASL	A
	ROL	ENEMYPTR+1
	ASL	A
	ROL	ENEMYPTR+1
	CLC	
	ADC	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	ADC	ENEMYPTR+1
	STA	ENEMYPTR+1	;MAKE BASE MUSIC POINTER
	LDX	#8
	JSR	FILL_POINT	;GET THE DATA AND RESTORE POINTERS
	LDA	SUBSVAR1
	STA	EXTRA_PTR
	LDA	SUBSVAR2
	STA	EXTRA_PTR+1

	LDA	#0
	STA	SAFEX		;SET CHANNEL FOR LOOP

CMD782:	ASL	A
	TAY
	LDA	(EXTRA_PTR),Y
	STA	SAFEWORD
	INY
	LDA	(EXTRA_PTR),Y
	STA	SAFEWORD+1
	JSR	DOCHANNEL	;DO THIS SOUND CHANNEL
	LDA	SAFEX
	CMP	#4		;DONE?
	BNE	CMD782
	RTS

CMD79:				;HIDE ALL ENEMIES
	STX	SAFEX		;SAVE OUR INDEX
	LDA	#ECNT-1
	STA	SAFEBYTE
CMD791:	LDA	SAFEBYTE	;GET NEXT ONE TO HIDE
	CMP	SAFEX
	BEQ	CMD792
	JSR	ENEMYGONE	;REMOVE THIS ONE
CMD792:	DEC	SAFEBYTE
	BPL	CMD791		;DO ALL OF THEM.
	LDX	SAFEX
	STX	SAFEBYTE	;RESTORE OUR INDEX
	RTS

CMD7A:	LDA	DATA1
	JSR	REGVAL		;GET HOW MANY OF A SPECIFIC ENTITY
	LDY	#0
	STY	DATA1
CMD7A2:	CMP	ENEMY0,Y	;MATCH?
	BNE	CMD7A3
	INC	DATA1
CMD7A3:	INY
	CPY	#ECNT
	BNE	CMD7A2
	LDA	#0
	STA	DATA2
	JMP	CMD3E1		;RETURN DATA1 IN REGISTER

CMD7B:	LDX	DATA3		;TEST FOR SOLID
	LDY	DATA4
	JSR	TESTMOVE	;SEE IF SOLIDS
	BEQ	CMD7B1
	JMP	MOVEPTR
CMD7B1:	RTS	

CMD7C:	LDA	#0		;WIPEOUT.
	STA	SAFEX		;SET VIDEO PAGE TO DO
	STA	SAFEX2		;SET TOP FLAG = 0 (1=BOTTOM)
	STA	SAFEY		;SET TOP ROW TO DO
	LDA	#29
	STA	SAFEY2		;SET BOTTOM ROW TO DO
	
CMD7C1:	LDA	STATLEN		;WAIT FOR BUFFER AVAILABLE
	BNE	CMD7C1

	LDY	SAFEY		;ASSUME TOP ROW IS BEING DONE
	LDA	SAFEX2		;SEE IF ITS SO
	BEQ	CMD7C2
	LDY	SAFEY2		;IF NOT TOP, ITS BOTTOM
CMD7C2:	STY	STATROW		;SET ROW TO WRITE TO

	LDA	SAFEX		;GET VIDEO PAGE TO DO
	STA	VIDTYPE		;SET FOR THE SUB

	LDA	#ERASECHAR
	STA	STATDATA	;SET CHAR TO USE FOR ERASE

	LDA	#0
	STA	STATCOL		;SET COLUMN

	LDA	#FILLVID
	STA	STATTYPE	;SET TYPE OF WRITE

	LDA	#32
	STA	STATLEN		;SET LENGTH TO FILL


	LDA	SAFEX		;GET BACK VIDEO PAGE TO DO
	EOR	#1		;MOVE TO NEXT
	STA	SAFEX		;IF NOW 0, TIME TO GO TO BOTTOM
	BNE	CMD7C1

	LDA	SAFEX2		;GET TOP/BOTTOM FLAG
	EOR	#1
	STA	SAFEX2
	BNE	CMD7C1		;IF HAVEN'T DONE BOTTOM YET, DO IT

	INC	SAFEY		;GO TO NEXT ROW ON TOP IF DONE
	DEC	SAFEY2		;AND GO UP 1 ON THE BOTTOM
	LDA	SAFEY2		;DONE WHEN BOTTOM ROW=14 AND TOP=15
	CMP	#15
	BCS	CMD7C1
CMD7C3:	LDA	STATLEN
	BNE	CMD7C3
	LDA	SCCNT
	BNE	CMD7C3
	JSR	ALLSILENCE	;TURN OFF ALL SOUNDS
	LDY	#0
	LDX	SAFEBYTE
	JMP	CMD0F		;FINISH WITH THE WORLD COMMAND.

CMD7D:	LDA	DATA1		;THROW BACK
	JSR	REGVAL
	STA	DATA1
	LDA	DATA2
	JSR	REGVAL
	STA	DATA2
	LDY	ENEMYATK,X	
	LDA	ENEMYTRACK,Y	;GET THE DIRECTION OF THE OTHER ENEMY
	BPL	CMD7D1	
	LDA	DATA1
	JSR	NEGATE
	STA	DATA1
CMD7D1:	JSR	USEMOM3
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD7E:	JSR	MAKE_ECOL	;MAKE THIS ENTITIES COLUMN
	LDA	SAFEWORD
	STA	ENEMYLREG,X
	LDA	SAFEWORD+1
	STA	ENEMYHREG,X
	RTS

CMD7F:	LDA	STATLEN		;TABLED WRITE TO STATUS LINE
	BEQ	CMD7F1
	JMP	CMD6E2

CMD7F1:	JSR	SETPTR
	LDA	ENEMYLREG,X
	ASL	A
	CLC
	ADC	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	ADC	#0
	STA	ENEMYPTR+1	;POINT TO THE DATA
	LDX	#2
	JSR	FILLCBUF	;GET THE ENTRY
	LDX	SAFEBYTE
	JSR	EBACKUP
	LDA	DATA1
	STA	DATA2
	LDA	CMDBUF
	STA	DATA1
	JMP	CMD6E1

CMD80:	LDA	DATA1			;LIMIT
	SEC
	SBC	ENEMYLREG,X
	LDA	DATA2
	SBC	ENEMYHREG,X
	BCS	CMD801		;IF ITS ABOVE THE REGISTER, ITS OK
	LDA	DATA1
	STA	ENEMYLREG,X
	LDA	DATA2
	STA	ENEMYHREG,X
CMD801:	RTS

CMD81:	LDA	DATA1	  	;MOVE IN
	JSR	REGVAL
	STA	DATA1
	LDA	DATA2
	JSR	REGVAL
	STA	DATA2
	LDA	ENEMYTRACK,X	;SEE IF NEED REVERSAL FOR FACING LEFT
	BPL	CMD811
	LDA	DATA1
	CMP	#-1
	BEQ	CMD811
	JSR	NEGATE
	STA	DATA1
CMD811:	LDA	ENEMYTRACK,X
	AND	#$40
	BEQ	CMD812
	LDA	DATA2
	CMP	#-1
	BEQ	CMD812
	JSR	NEGATE
	STA	DATA2
CMD812:	JSR	USEMOM4
	JMP	SEECMDS

CMD82:	LDA	DATA3		;EQUAL REGISTER
	CMP	ENEMYLREG,X	;GET REGISTER VALUE
	BNE	CMD821
	LDA	DATA4
	CMP	ENEMYHREG,X
	BEQ	CMD801
CMD821:	JMP	MOVEPTR

CMD83:	LDA	STATLEN		;SET PALETTE COLOR
	BNE	CMD839
	LDA	DATA1
	STA	STATCOL		;SET PALETTE COLOR TO WRITE TO
	LDA	DATA2
	STA	STATROW		;SET VALUE TO WRITE OUT
	LDA	#PALCLR
	STA	STATTYPE	;SET TYPE OF WRITE
	LDA	#1
	STA	STATLEN		;SET LENGTH
	RTS
CMD839:	JMP	CMD6E2

CMD84:	JSR	GETJOY		;SPECIFY SELECT FUNCTION
	LDA	DATA1
	STA	SELKEY,Y	
	RTS

CMD85:	LDA	ENEMYHREG,X	;DIVIDE BY CONSTANT
	TAY
	LDA	ENEMYLREG,X
	TAX
	LDA	DATA1		;GET BYTE TO DIVIDE BY
	JSR	DIVIDE		;DO THE DIVIDE
	TXA			;GET RESULT
	LDX	SAFEBYTE
	STA	ENEMYLREG,X	;SAVE RESULT
	JSR	CLEARHIGH
CMD851:	RTS

CMD86:	JSR	ACCESS_JOY		;GET JOYSTICK ENTITIES HEALTH
	LDA	ENEMYHEALTH,Y
	STA	ENEMYLREG,X	
	JMP	CLEARHIGH
				;CALL HERE WITH JOYSTICK SPECIFIER (CMD86)
ACCESS_JOY:			;IN DATA1 TO POINT Y TO THAT ENTITY.  IT
				;POPS STACK AND RETURNS IF NONE.
	JSR	FINDJOY		;GET JOYSTICK ENTITIES HEALTH
	BNE	AJY10		;SKIP IF NONE
	LDA	JOYENEMY,Y	;SEE IF THERE IS AN ENTITY ATTACHED TO IT
	TAY
	BPL	AJY20
AJY10:	PLA
	PLA
AJY20:	RTS

CMD87:	JSR	ACCESS_JOY	;SET JOYSTICK ENTITIES HEALTH
	LDA	ENEMYLREG,X	
	STA	ENEMYHEALTH,Y
	RTS

CMD88:	LDA	DATA1		;SET ENEMYFLG
	JSR	REGVAL
	STA	ENEMYFLGS,X
	RTS	

CMD89:	JSR	SETPTR		;WORLD GOTO
	LDY	#7
	LDA	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	STA	ENEMYPTR+1	;GET BASE OFFSET OF TABLE
CMD890:	LDA	ENEMYLREG,X
	CLC
	ADC	ENEMYPTR
	STA	ENEMYPTR
	LDA	ENEMYPTR+1
	ADC	#0
	STA	ENEMYPTR+1
	DEY
	BNE	CMD890		;ADD 7*REGISTER TO CURRENT POINTER
	LDX	#7
	JSR	FILLCBUF
	LDX	SAFEBYTE
	JSR	EBACKUP		;RESTORE NEXT EXECUTION POINT	
	LDA	CMDBUF
	CMP	#NOCHANGE
	BNE	CMD891A
	JMP	CMD899

CMD891A:
	LDA	DATA4
	CMP	#-1		;SEE IF DON'T CARE
	BNE	CMD891
       	LDA	DATA3
	CMP	#-1
	BNE	CMD891		;THE LEFTMOST MUST BE FLOATING TO NOT RELAUNCH
	
	CMP	CURWORLD	;SEE IF SAME WORLD AS CURRENT
	BEQ	CMD899		;IF SAME WE MIGHT BE ABLE TO DO IT HERE.
	
;MOVE THE HERO TO THE NEW LOCATION AHEAD OF TIME.  THIS IS BECAUSE WE
;DON'T HAVE ENOUGH STORAGE TO SAVE IT NOW AND OUR FLAG MAKES US NOT GO AWAY

CMD891:	LDA	#-1
	STA	SPECGOTO	;SET GOTO LOCATION
	
	LDA	CURWORLD
	STA	WORLD_REQUEST
	LDA	#0
	STA	CHEATMODE	;FLAG ITS NOT A CHEAT MODE ENTERED WORLD
	LDA	CMDBUF
	CMP	#NOCHANGE
	BEQ	CMD893
	STA	WORLD_REQUEST	;REQUEST THE WORLD

CMD893:	LDA	DATA3
	STA	LEFTCOL		;SET LEFTMOST COLUMN FOR THE WORLD
	LDA	DATA4
	STA	LEFTCOL+1
	CMP	#-1		;SEE IF DON'T CARE
	BNE	CMD892
       	LDA	DATA3
	CMP	#-1
	BNE	CMD892
	LDA	DATA5
	SEC
	SBC	#16		;IF DON'T CARE, CENTER IT
	STA	LEFTCOL
	LDA	DATA6
	SBC	#0
	STA	LEFTCOL+1
	BCS	CMD892		
	LDA	#0
	STA	LEFTCOL
	STA	LEFTCOL+1	;IF CAN'T BACK UP 16, BACK UP 0.

CMD892:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

	LDA	DATA2
	STA	TOPROW		;SET TOPMOST ROW FOR THE WORLD
	CMP	#-1		;SEE IF DONT CARE
	BNE	CMD894
	LDA	DATA1
	SEC
	SBC	#16		;IF DONT CARE, CENTER IT
	STA	TOPROW
	BCS	CMD893A
	LDA	#0
	STA	TOPROW
CMD893A:
	LDA	TOPROW
	STA	DATA2	
	.endif ;' )

;THIS CODE TO MOVE THE HERO TO THE NEW LOCATION IS SHARED.

CMD894:	LDA	DATA1
	SEC
	SBC	DATA2		;MAKE Y LOCATION RELATIVE TO TOP
	JSR	TIMES8		;MAKE PIXEL OFFSET
	STA	ENEMYY,X
	LDA	DATA5
	SEC
	SBC	LEFTCOL
	AND	#$1F		;MAKE X COLUMN 0-31 FROM DIFFERENCE
	JSR	TIMES8		;MAKE *8
	STA	ENEMYX,X
	JSR	FINDLOCS	;UPDATE HERO'S FLAGS
	JMP	NOCMDS

CMD898:	JMP	CMD891

;WE ARE STAYING IN THIS WORLD. SEE IF WE CAN DO IT WITHOUT HAVING TO
;MOVE THE SCREEN

CMD899:	LDA	DATA5
	SEC
	SBC	STARTCOL
	STA	SAFEWORD
	LDA	DATA6
	SBC	STARTCOL+1	;SEE OUT HERO'S LOCATION IS ON SCREEN
	BCC	CMD898
	BNE	CMD898
	LDA	SAFEWORD
	CMP	#31		;HE HAS TO BE AT LEAST 1 FROM RIGHT
	BCS	CMD898
	CMP	#1
	BCC	CMD898		;AND AT LEAST 1 FROM LEFT

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

	LDA	DATA1		;GET WHERE WE WANT HEROS FEET
	SEC
	SBC	STARTROW	;SEE HOW FAR FROM TOP
	CMP	#24		;MUST BE WITHIN 24
	BCS	CMD898
	CMP	#5
	BCC	CMD898		;AND BELOW 5
	.endif ;' )

;WE CAN STAY WHERE WE ARE.  

	LDA	DATA1		;GET Y LOCATION
	SEC
	SBC	DATA2		;MAKE IT RELATIVE TO TOP
	JSR	TIMES8		;MAKE PIXEL OFFSET
	TAY
	STA	ENEMYY,X
	LDA	DATA5
	SEC
	SBC	STARTCOL
	AND	#$1F		;MAKE X COLUMN 0-31 FROM DIFFERENCE
	JSR	TIMES8		;MAKE *8
	STA	SAFEWORD
	LDA	XBACK
	AND	#7		;GET ODD PIXELS
	CLC
	ADC	SAFEWORD
	STA	ENEMYX,X
	JSR	FINDLOCS
	JMP	NOCMDS

CMD8A:	LDA	DATA1		;RESET ENTITY MEMORY
	CMP	#ALL		;RESET ALL OF THEM?
	BNE	CMD8A3
	LDA	#0
	TAX
	LDY	#32		;IF ALL, DO ALL
CMD8A1:	STA	REMEMBER,X	;SET THE SPECIFIED BYTE(S) TO -1
	INX
	DEY
	BNE	CMD8A1
CMD8A2:	RTS	

CMD8A3:	JSR	MAKELIFE
	LDX	SAFEBYTE
	STA	SAFEWORD
	ORA	REMEMBER,Y
	EOR	SAFEWORD	;RESET THE BIT TO MAKE IT ALIVE AGAIN
	STA	REMEMBER,Y
	RTS

CMD8B:	LDA	CHEATMODE	;BRANCH IF NOT CHEAT MODE ENTERED WORLD
	PHA
	LDA	#0
	STA	CHEATMODE	;FLAG ITS NOT A CHEAT MODE ENTERED WORLD
	PLA
	BNE	CMD8A2
	JMP	MOVEPTR

CMD8C:	JSR	FULLMINUS	;WHOS LINKED TO US
	LDY	#0
CMD8C1:	JSR	VALID2
	BEQ	CMD8C2
	LDA	ENEMYLINK,Y
	CMP	SAFEBYTE	;SEE IF HE'S LINKED TO US
	BNE	CMD8C2
	LDA	ENEMY0,Y	;GET HIS ENTITYTAB NUMBER
	STA	ENEMYLREG,X
	JSR	CLEARHIGH
	RTS
CMD8C2:	INY
	CPY	#ECNT
	BNE	CMD8C1
CMD8C3:	RTS

CMD8D:
.ifdef XGETSCORE;IFDEF( `XGETSCORE', `		
	JSR	FINDJOY		;GET THE JOYSTICK SCORE BYTE
	BNE	CMD8C3
	LDA	SCOREL,Y
	STA	ENEMYLREG,X
	LDA	SCOREH,Y
	STA	ENEMYHREG,X
	RTS
.endif ;' )

CMD8E:
.ifdef XPUTSCORE;IFDEF( `XPUTSCORE', `		
	JSR	FINDJOY		;PUT THE JOYSTICK SCORE BYTE
	BNE	CMD8C3
	LDA	ENEMYLREG,X
	STA	SCOREL,Y
	LDA	ENEMYHREG,X
	STA	SCOREH,Y
	RTS
.endif ;' )

CMD8F:	LDA	ENEMYLREG,X	;SWAP REGISTER BYTES
	PHA
	LDA	ENEMYHREG,X
	STA	ENEMYLREG,X
	PLA
	STA	ENEMYHREG,X
	RTS

CMD90: 
.ifdef XPEEK;IFDEF( `XPEEK', `		
	JSR	GETADDR		;PEEK
	LDA	(SUBSVAR1),Y
	STA	ENEMYLREG,X
	JMP	CLEARHIGH
.endif ;' )

CMD91:
.ifdef XPOKE;IFDEF( `XPOKE', `		
	JSR	GETADDR		;POKE
	LDA	ENEMYLREG,X
	STA	(SUBSVAR1),Y
	RTS
.endif ;' )

GETADDR:			;GETS DATA2:DATA1 INTO SUBSVAR1 WORD.
	LDA	DATA1		;ALSO CLEARS Y.
	STA	SUBSVAR1
	LDA	DATA2
	STA	SUBSVAR2
	LDY	#0
CMD912:	RTS

CMD92:	JSR	GETJOY		;MOVE EXECUTE POINTER IF JOYSTICK BITS ARE OFF
	LDA	DATA3
	AND	J1FLAGS,Y	;GET THE SPECIFIED BITS
	BNE	CMD8C3
	JMP	MOVEPTR		;IF SO, MOVE EXECUTE POINTER

CMD93:	LDA	DATA3		;MOVE EXECUTE POINTER IF COUNTER ABOVE
	CMP	ENEMYCNT,X	;ABOVE THE VALUE?
	BCS	CMD8C3
	JMP	MOVEPTR

CMD94:	LDA	ENEMYCENTR,X	;IF EDGE
	BPL	CMD942		;IF LEFT HALF, USE THIS AS DISTANCE
CMD941:	JSR	NEGATE
CMD942:	CMP	DATA3		;NEAR EDGE?
	BCS	CMD8C3
	JMP	MOVEPTR

CMD95:	LDX	#4		;CASE TABLE
	JSR	FILLCBUF	;GET NEXT POSSIBLE ENTRY
	LDX	SAFEBYTE	;RESTORE INDEX
	JSR	INCINC		;WE ALWAYS SKIP AT LEAST 1 WORD
	LDA	CMDBUF
	ORA	DATA1		;SEE IF END OF LIST
	BEQ	CMD912		;IF SO, JUST CONTINUE EXECUTION WITH NEXT
	JSR	INCINC		;SKIP THE REG VALUE TOO
	LDA	DATA2
	CMP	ENEMYLREG,X	;SEE IF FULL WORD MATCH
	BNE	CMD95
	LDA	DATA3
	CMP	ENEMYHREG,X
	BNE	CMD95
	LDA	DATA1
	STA	DATA2
	LDA	CMDBUF
	STA	DATA1
	JMP	MOVEPTR		;IF WE FOUND IT, MOVE THE POINTER

CMD96: 
.ifdef XEDGEMOM;IFDEF( `XEDGEMOM', `		
	LDA	DATA1		;EDGE ADJUSTED MOMENTUM
	LDY	ENEMYCENTR,X
	BPL	CMD961
	JSR	NEGATE		
CMD961:	STA	DATA1
	LDA	DATA2
	LDY	ENEMYFEET,X
	BPL	CMD962
	JSR	NEGATE
CMD962:	STA	DATA2
	JSR	USEMOM4
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.
.endif ;' )

CMD97:	JSR	DATAINDX		;AND FROM COMMON RAM
	BEQ	CMD975
	LDA	ENEMYLREG,X
	AND	COMMONDATA,Y
	STA	ENEMYLREG,X
	LDA	ENEMYHREG,X
	AND	COMMONDATA+1,Y
	STA	ENEMYHREG,X
	RTS

CMD975:	LDA	ENEMYLREG,X		;IF <STATE> ADD FULL WORD
	AND	STATERAM,Y
	STA	ENEMYLREG,X
	LDA	ENEMYHREG,X
	AND	STATERAM+1,Y
	STA	ENEMYHREG,X
	RTS

CMD98:	LDA	CURWORLD		;STATREQUEST
	STA	SAVEDWORLD		;SAVE THE WORLD
	LDA	STARTCOL
	STA	LEFTCOL
	LDA	STARTCOL+1
	STA	LEFTCOL+1		;SAVE THE CURRENT COLUMN FOR RESUMEING

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	STARTROW
	STA	TOPROW		;SAVE THE CURRENT ROW FOR RESUMEING

.endif ;' )

	LDA	JOYENEMY
	STA	SAVEJOY
	LDA	JOYENEMY+1	;SAVE WHO HAS THE JOYSTICKS
	STA	SAVEJOY+1

	LDA	SELKEY
	STA	SAVESEL
	LDA	SELKEY+1
	STA	SAVESEL+1	;SAVE WHAT SELECT DOES

	LDA	DATA1
	STA	WORLD_REQUEST		;REQUEST THE STATUS WORLD

	LDA	#ECNT-1
	STA	SAFEWORD		;SET LOOP TO HIDE ALL SPRITES
	LDA	#$F8
	SEC
	SBC	SPYADJ		;MAKE LOCATION TO HIDE THE SPRITE
	STA	SAFEWORD+1
CMD981:	LDX	SAFEWORD
	LDA	ENEMYJSTAT,X
	ORA	#$20		;SET HIDDEN BIT
	STA	ENEMYJSTAT,X	;PROTECT THIS SPRITE FROM BEING DISPLAYED
	LDA	SAFEWORD
	LDY	SAFEWORD+1
	JSR	PUTSPRT		;HIDE THE SPRITE
	DEC	SAFEWORD	;HIDE THE NEXT ONE
	BPL	CMD981
CMD991:	RTS

CMD99:	LDA	#-1		;END REQUEST WORLD
	STA	SPECGOTO	;SET DOUBLE FLAG TO SIGNAL END OF REQUEST 

	LDA	SAVED1
	STA	DATA1
	LDA	SAVED2
	STA	DATA2
	LDA	SAVED3
	STA	DATA3
	LDA	SAVED4
	STA	DATA4		;SET UP TO RESTORE TOP STATUS LINE
	JSR	INITSTAT	;RESTORE IT

	LDA	SAVEDWORLD
	JMP	CMD0F2		;SHARE <WORLD> CODE

CMD9A:	JSR	INSTAT		;IF REQUEST WORLD
	BEQ	CMD991		;IF SO, MOVE EXECUTE POINTER
	JMP	MOVEPTR

INSTAT:				;RETURNS NZ IF WE ARE IN OR GOING INTO A
				;WORLD VIA STATREQUEST.
	LDA	SAVEDWORLD	;OR IF STATREQUEST WORLD
	CMP	#-1
	RTS

CMD9B:
.ifdef XUSERSUB;IFDEF( `XUSERSU%, `		
	LDA	DATA2		;USER SUB
	PHA
	LDA	DATA1
	PHA
	RTS
.endif ;' )

CMD9C:	LDA	DATA1		;ROTATION ON OR OFF
	EOR	#OFF		;SET OFF TO 0
	STA	ROTATEFLG
	RTS

CMD9D:
.ifdef IFDEF XLOWEXEC;( `XLOWEXEC', `		
	LDA	ENEMYCTRL,X	;LOW PRIORITY BIT CONTROL
	AND	#223		;ASSUME ITS OFF
	LDY	DATA1
	CPY	#OFF
	BEQ	CMD9D1
	ORA	#32
CMD9D1:	STA	ENEMYCTRL,X
.endif ;' )
CMD9D2:	RTS

CMD9E:	
.ifdef XXVIRTUAL;IFDEF( `XXVIRTUAL', `		
 	LDA	ENEMYCENTR,X	;MOVE IF VIRTUAL X<VALUE
	CLC
	ADC	XBACK
	STA	SAFEWORD
	LDA	XBACK+1
	ADC	#0
	STA	SAFEWORD+1
CMD9E4:	LDA	DATA3		
	SEC
	SBC	SAFEWORD
	LDA	DATA4
	SBC	SAFEWORD+1
	BCC	CMD9D2
.endif ;' )
CMD9E5:	JMP	MOVEPTR

CMD9F:
.ifdef XYVIRTUAL;IFDEF( `XYVIRTUAL', `		
 	LDA	ENEMYFEET,X	;MOVE IF VIRTUAL Y<VALUE
	CLC
	ADC	YBACK
	STA	SAFEWORD
	LDA	YBACK+1
	ADC	#0
	STA	SAFEWORD+1
	JMP	CMD9E4
.endif ;' )

CMDA0:
.ifdef XBVIRTUAL;IFDEF( `XBVIRTUAL', `		
 	LDA	ENEMYFEET,X	;MOVE IF VIRTUAL Y<VALUE
	CLC
	ADC	YBACK
	STA	SAFEWORD
	LDA	YBACK+1
	ADC	#0
	STA	SAFEWORD+1
	
	LDA	#0
	STA	SAFEX
	LDA	WORLD_HEIGHT

	ASL	A
	ROL	SAFEX
	ASL	A
	ROL	SAFEX
	ASL	A
	ROL	SAFEX		;MAKE HEIGHT IN PIXELS FOR BACKGROUND HEIGHT

	SEC
	SBC	SAFEWORD
	STA	SAFEWORD
	LDA	SAFEX
	SBC	SAFEWORD+1
	STA	SAFEWORD+1	;MAKE COUNT OF PIXELS FROM BOTTOM UP
	JMP	CMD9E4
.endif ;' )

CMDA1: 
.ifdef XBLOAD;IFDEF( `XBLOAD', `		
	JSR	DATAINDX	;LOAD BYTE FROM COMMON RAM WITHOUT ZERO HIGH
	LDA	COMMONDATA,Y
	STA	ENEMYLREG,X
	RTS
.endif ;' )

CMDA2:
.ifdef XLINKMOM;IFDEF( `XLINKMOM', `		
	LDY	ENEMYLINK,X	;GET MOMENTUM OF ENTITY WE ARE LINKED TO
	LDA	ENEMYXMOM,Y
	STA	ENEMYXMOM,X
	LDA	ENEMYYMOM,Y
	STA	ENEMYYMOM,X
	RTS
	.endif ;' )

CMDA4: 
.ifdef XLINKFACE;IFDEF( `XLINKFACE', `		
	LDA	ENEMYJSTAT,X	;LINKED ENTITY FACE CONTROL
	AND	#251		;ASSUME WE FACE DIRECTION OF WHO WE ARE LINKED
	LDY	DATA1
	CPY	#OFF
	BEQ	CMDA41
	ORA	#4		;IF NOT, SET BIT
CMDA41:	STA	ENEMYJSTAT,X
	RTS
.endif ;' )

CMDA5:
.ifdef XREADCHAR;IFDEF( `XREADCHAR', `		
	LDA	ENEMYX,X	;READ CHAR UNDER CURSOR
	CLC
	ADC	ENEMYLREG,X
	STA	TESTX
	LDA	ENEMYY,X
	CLC
	ADC	ENEMYHREG,X
	STA	TESTY
	JSR	GETCHAR
	LDX	SAFEBYTE
	STA	ENEMYLREG,X
	JMP	CLEARHIGH
.endif ;' )


CMDA6:
.ifdef XREGLAUNCH;IFDEF( `XREGLAUNC$, `		
	LDA	DATA2		;REGISTER LAUNCH
	STA	DATA4
	LDA	ENEMYLREG,X
	STA	DATA2
	LDA	ENEMYHREG,X
	STA	DATA3
	JMP	CMD1F
.endif ;' )

CMDA7:
.ifdef XWHOSTHERE;IFDEF( `XWHOSTHERE', `		
	LDA	ENEMYX,X	;WHOS THERE
	CLC
	ADC	ENEMYLREG,X
	STA	DATA1
	LDA	ENEMYY,X
	CLC
	ADC	ENEMYHREG,X
	STA	DATA2		;MAKE LOCATIONS TO CHECK

	LDY	#0		;START ENTITY CHECK WITH #0
DA7100:	JSR	VALID2		;MAKE SURE VALID AND NOT US
	BEQ	DA7150		

	LDA	ENEMYY,Y 	;GET ENTITY TO CHECKS TOP EDGE
	SEC
	SBC	#8
	BCS	DA7102
       	LDA	#0
DA7102:	CMP	DATA2		;SEE IF TOP IS ABOVE ATTACK AREA TOP
	BCS	DA7150
	LDA	ENEMYFEET,Y	;IF SO, BOTTOM MUST BE BELOW ATTACK TOP
	CLC
	ADC	#8
	BCC	DA7103
	LDA	#-1
DA7103:	CMP	DATA2
	BCC	DA7150		;IF Y OUT OF RANGE, END	

	LDA	ENEMYX,Y	;Y IS IN RANGE.   REPEAT LOGIC FOR X
	SEC
	SBC	#8
	BCS	DA7104
       	LDA	#0
DA7104:	CMP	DATA1		
	BCS	DA7150
	LDA	ENEMYX,Y
	CLC
	ADC	ENEMYWIDE,Y	
	BCC	DA7132
      	LDA	#-1
DA7132:	CLC
	ADC	#8
	BCC	DA7133
       	LDA	#-1
DA7133:	CMP	DATA1
	BCC	DA7150		
	LDA	ENEMY0,Y
	STA	ENEMYLREG,X
	JMP	CLEARHIGH	;WE FOUND ONE

DA7150:	INY
	CPY	#ECNT		;DONE WITH CHECK?
	BNE	DA7100
.endif ;' )

FULLMINUS:
	LDA	#-1		
	STA	ENEMYLREG,X	;RETURN FULL WORD OF -1
	STA	ENEMYHREG,X
	RTS

CMDA8:
.ifdef XALIGNXY;IFDEF( `XALIGNXY', `		
	LDA	ENEMYLREG,X	;ALIGN X AND Y
	CLC
	ADC	XBACK
	AND	#7		;GET ODD BITS
	JSR	NEGATE
	CLC
	ADC	ENEMYLREG,X
	STA	ENEMYLREG,X

      	LDA	ENEMYHREG,X	;ALIGN Y
	CLC
	ADC	YBACK
	AND	#7
	JSR	NEGATE
	CLC
	ADC	ENEMYHREG,X
	STA	ENEMYHREG,X
	RTS
.endif ;' )

CMDA9:
.ifdef XMOVEOVER;IFDEF( `XMOVEOVER', `		
	LDA	DATA1		;MOVE OVER
	BNE	CMDA91
	LDA	DATA2
	BNE	CMDA91
	LDA	ENEMYLREG,X
	STA	DATA1
	LDA	ENEMYHREG,X
	STA	DATA2		;IF BOTH ZERO, USE REGISTER
CMDA91:	LDA	ENEMYX,X
	CLC
	ADC	DATA1
	STA	ENEMYX,X
	LDA	ENEMYY,X
	CLC
	ADC	DATA2
	STA	ENEMYY,X
	JSR	FINDLOCS	;UPDATE HEROS FLAGS
	RTS
.endif ;' )


;THIS SUB WILL FINISH A TOPSTAT COMMAND (CMD6D) ASSUMING FILLCBUF SET UP
;THE VALUES.  IT SAVES THE 4 BYTES NEEDED TO ACCOMPLISH THIS SO THAT YOU
;CAN RESTORE THEM IN CASE OF ENDREQUEST.  IT ONLY SAVES THEM IF
;INSTAT RETURNS Z.   

INITSTAT:
	JSR	INSTAT		;SEE IF WE SHOULD SAVE THE INFO FOR ENDREQUEST
	BNE	INST10
	LDA	DATA1		;SAVE THESE FOR ENDREQUEST
	STA	SAVED1
	LDA	DATA2
	STA	SAVED2
	LDA	DATA3
	STA	SAVED3
	LDA	DATA4
	STA	SAVED4

INST10:	LDA	#$F8		;ASSUME NO TOP OF SCREEN STATUS BAR
	STA	PUTBAR		;SET INVISIBLE PLACE TO PUT SPRITE 0
	LDA	DATA1
       	STA	STARTSTAT	;IF DISABLED (LENGTH=0) SET THIS TO 0.
	BEQ	INST12		;AND LEAVE IT.  BUT WE NEED OTHER CALCULATIONS

	LDA	#$F0		;VIDEO WRAPS AT F0 CAUSE OF PALLETTE INFO
	SEC
	SBC	DATA1		;MAKE STATUS BAR SCROLL START
	STA	STARTSTAT	;SO WE USE THIS AS THE SCROLL VALUE

	LDA	DATA2
	SEC
	SBC	#9		;MAKE THE Y POSITION VALUE FOR THE SPRITE
	STA	PUTBAR

INST12:	LDA	DATA3
	STA	CUTOFF		;SET SCROLL VALUE FOR AFTER THE STATUS BAR

	LDA	DATA4
	AND	#1
	ASL	A
	ASL	A
	ASL	A
	ASL	A		;GET UPPER/LOWER SET BIT INTO REG2000 POSITION
	ORA	#8		;AND WE ALWAYS USE UPPER FOR SPRITES
	STA	STATBITS
	
	LDA	DATA4
	ROL	A
	ROL	A
	ROL	A		;MOVE SET # UP INTO VIDEO SET NIBBLE
	AND	#$F0		;KEEP ONLY VIDEO BITS
	JSR	MAKEBANK	;MAKE INDEX AND BANK SELECT VALUE
	STA	STATBANK	;SET THE VALUE TO WRITE TO PAGETAB
	STX	STATINDX	;AND SET THE INDEX TO USE WHEN IN STAT BAR

	LDA	DATA2		;GET SCAN LINES DISPLAYED IN STATUS BAR
	CLC
	SBC	DATA3		;SUBTRACT BACKGROUND CUTTOFF TO 
	STA	SPYADJ		;MAKE SPRITE Y CENTERING AMOUNT

	JSR	TOPSPRITE

	LDA	#$27
	STA	STATHI
	LDA	#$C0
	STA	STATLO		;SET UP STATUS BAR LOCATION FOR SUBTRACT

	LDA	DATA1		;GET BACK STARTING SCAN LINE
	CLC
	ADC	#7		;ROUND UP
	AND	#$F8		;THROW OUT EXTRA
	ASL	A
	ASL	A		;MULTIPLY BY 32
	STA	DATA2
	LDA	STATLO
	SEC
	SBC	DATA2		;MAKE LOCATION OF TOP OF STATUS BAR
	STA	STATLO
	LDA	STATHI
	SBC	#0
	STA	STATHI		;LOCATE THE STATUS BAR	
 	RTS

;THIS ROUTINE WILL TAKE A VIDEO AND PROGRAM ROM BANK VALUE IN A AND
;MAKE THE VALUE AND INDEX TO USE WITH PAGETAB FOR A ROM VERSION.
;A HAS THE VALUE TO WRITE TO PAGETAB AND X HAS THE INDEX.

MAKEBANK:
	TAY			;SAVE THE ORIGINAL VALUE
	AND	#1		;GET JUST THE ROM BIT
	STA	SAFEWORD	;SAVE THEM
	TYA			;GET THE ORIGINAL VALUE
	LSR	A
	LSR	A
	LSR	A		;MOVE HIGH BITS DOWN TO ADD IN LOWEST.
	ORA	SAFEWORD
	TAX			;MAKE IT INTO AN INDEX
	TYA			;GET BACK ORIGINAL VALUE
	ORA	#12		;PUT IN THE KEY CIRCUIT BITS
	RTS

;THIS ROUTINE WILL TAKE A USER JOYSTICK IDENTIFIER IN DATA1 AND PUT
;THE JOYSTICK INDEX INTO Y.  SEE COMMAND 37 FOR THE VALUES.  IF NONE
;EXISTS, NZ ON RETURN.  IF ONE EXISTS, Z AND Y=INDEX 0 OR 1.

FINDJOY:
	LDA	DATA1
	CMP	#2		;CATCH 0 OR 1
	BCC	FJY10
	BNE	FJY5
	LDA	ENEMYJSTAT,X	;IF 2, ITS OUR JOYSTICK
	BPL	FJY8
FJY4:	RTS			;NZ IF -1

FJY5:	LDA	ENEMYATK,X	;IF 3, LAST ATTACKER
	CMP	#-1
	BEQ	FJY4	
	TAY
	LDA	ENEMYJSTAT,Y	;IF HAVE LAST ATTACKER, HE HAS JOYSTICK?
	BMI	FJY4
FJY8:	AND	#$03

FJY10:	TAY			;HAVE INDEX IN A
	LDA	#0		;SET Z
	RTS	

;THIS SUB WILL POP THE RETURN STACK AND RETURN IF WE ARE NOT IN CHARGE
;OF A JOYSTICK.  OTHERWISE IT PUTS THAT JOYSTICK INDEX IN Y.  IF
;SUCCESS, A AND X ARE NOT CHANGED.

GETJOY:	PHA
	LDA	ENEMYJSTAT,X
	AND	#$83
	TAY	     	;GET OUR JOYSTICK
	PLA
	CPY	#$80	;SEE IF ACTIVE
	BCC	GJ10
	PLA
	PLA
GJ10:	RTS

;****** DONE EXECUTING ****************
;WE HAVE TO MAKE SURE THE ENTITY IS STILL ALIVE.  SOME ENTRY
;POINTS WILL HAVE GOTTEN RID OF IT.

ME250: 	LDA	WORLD_REQUEST	;SEE IF WORLD REQUESTED
	BNE	GJ10		;IF SO, DON'T DO GRAVITY.  WORLDGOTO MESSES UP
	LDA	ENEMY0,X
	CMP	#-1
	BNE	ME251
	RTS			;END IF GONE NOW

;EXERT FRICTION ON THE ENTITY.

ME251:	LDA	ENEMYLINK,X	;NO FRICTION IF LINKED ENTITY
	BMI	ME252
	JMP	EF200

ME252:	LDA	#-1
	STA	SAFEX		;SET FLAG OF FRICTION ENABLED
	LDA	ENEMYFLGS,X	;SEE IF FRICTION IS DEPENDANT ON SOLID
	AND	#1
	BNE	EF10		;IF SET, ALWAYS HAVE FRICTION

	LDA	ENEMYSTAT,X	;IF DEPENDANT ON SOLID, ARE WE TOUCHING IT?
	AND	#$10
	BNE	EF10
	LDA	#0
	STA	SAFEX		;IF NOT, DISABLE FRICTION

EF10:	LDA	ENEMYFCTR,X	;SEE IF WE APPLIED X MOMENTUM RECENTLY
	AND	#$0F
	BEQ	EF15		;IF NOT, USE FRICTION
	DEC	ENEMYFCTR,X	;IF WE DID, LOWER THE COUNT
	JMP	EF100		;BUT DON'T APPLY FRICTION ON X AXIS

EF15: 	LDA	SAFEX		;SEE IF WE ARE GOING TO HAVE FRICTION
	BEQ	EF100
	LDA	ENEMYXMOM,X
	BEQ	EF100
	BMI	EF30
	SEC
	SBC	ENEMYXFRICT,X
	BEQ	EF19
	BPL	EF20
EF19:	LDA	#1
EF20:	STA	ENEMYXMOM,X	;SET RESULT
	JMP	EF100
EF30:	CLC
 	ADC	ENEMYXFRICT,X
	BMI	EF40
	LDA	#-1		;KEEP A BIT SO WE WILL FACE LEFT.
EF40:	STA	ENEMYXMOM,X	;IF NEGATIVE, MAKE MORE POSITIVE

EF100:	LDA	ENEMYFCTR,X	;SEE IF WE APPLIED Y MOMENTUM RECENTLY
	AND	#$F0
	BEQ	EF115		;IF NOT, USE FRICTION
	LDA	ENEMYFCTR,X
	SEC
	SBC	#$10		
	STA	ENEMYFCTR,X	;IF WE DID, LOWER THE COUNT
	JMP	EF200

EF115: 	LDA	SAFEX		;SEE IF WE HAVE FRICTION
	BEQ	EF200
	LDA	ENEMYYMOM,X
	BEQ	EF200
	BMI	EF130
	SEC
	SBC	ENEMYYFRICT,X
	BEQ	EF119
	BPL	EF120
EF119:	LDA	#1
EF120:	STA	ENEMYYMOM,X	;IF PLUS NOW, MAKE MORE NEGATIVE DOWN TO 0.
	JMP	EF200
EF130: 	CLC
	ADC	ENEMYYFRICT,X
	BMI	EF140
	LDA	#-1
EF140:	STA	ENEMYYMOM,X	;IF NEGATIVE, MAKE MORE POSITIVE

;******   APPLY GRAVITY TO THE ENEMY.  ********

EF200:	LDA	ENEMYGRAV,X
	CLC
	ADC	ENEMYYMOM,X
	BVS	ME260
	STA	ENEMYYMOM,X

;APPLY MOMENTUM LIMITS TO THE ENEMY'S MOMENTUM

ME260:	LDY	#0		;SET FLAG OF DIDN'T NEED NEGATE
	LDA	ENEMYXMOM,X	;GET X MOMENTUM
	BPL	ME262
	JSR	NEGATE
	LDY	#1
ME262:	CMP	ENEMYXLIM,X	;SEE IF OVER LIMIT
	BCC	ME264
	LDA	ENEMYXLIM,X
ME264: 	CPY	#0
	BEQ	ME266
	JSR	NEGATE
ME266:	STA	ENEMYXMOM,X

	LDY	#0		;SET FLAG OF DIDN'T NEED NEGATE
	LDA	ENEMYYMOM,X	;GET X MOMENTUM
	BPL	ME272
	JSR	NEGATE
	LDY	#1
ME272:	CMP	ENEMYYLIM,X	;SEE IF OVER LIMIT
	BCC	ME274
	LDA	ENEMYYLIM,X
ME274: 	CPY	#0
	BEQ	ME276
	JSR	NEGATE
ME276:	STA	ENEMYYMOM,X

;NOW MOVE THE ENEMY ACCORDING TO HIS MOMENTUM.  

	LDA	ENEMYLINK,X	;LINKED ENEMY?
	BMI	ME290
	JSR	PUTLINK		;IF ITS LINKED, SEPERATE LOGIC FOR IT
	JMP	FE100

ME290:	LDA	ENEMYYMOM,X
	BPL	ME291
      	JSR	NEGATE		;IF NEGATIVE, MAKE + FOR SHIFT
ME291:	JSR	DIV8
	STA	SAFEX		;NEED ABSOLUTE VALUE FOR LATER
	LDY	ENEMYYMOM,X	;SEE IF WE ADJUSTED FOR NEGATIVE
	BPL	ME292
	JSR	NEGATE

;NOW HAVE Y MOVEMENT DESIRED.  BUT WE NEED TO CASE SPECIAL CASE OF ENTITIES
;THAT AREN'T ALLOWED TO GO ABOVE TOP OR BELOW BOTTOM.

ME292:	STA	SAFEY
	LDA	ENEMYFLGS,X	;SEE IF CAN'T GO ABOVE TOP OR BELOW BOTTOM
	AND	#$28
	BEQ	ME293
	LDA	SAFEY		;IF SO, GET AMOUNT TO MOVE
	BPL	ME292A		;HANDLE IT DIFFERENTLY IF +

	LDA	ENEMYY,X	;ASSUME ITS CONDITION HEAD CAN'T MOVE UP
	STA	SAFEWORD
	LDA	ENEMYFLGS,X
	AND	#$20		;IS IT THE HEAD?
	BNE	ME292D
	LDA	ENEMYFEET,X
	STA	SAFEWORD	;IF NOT, ITS THE FEET

ME292D:	LDA	SAFEX		;GET ABSOLUTE VALUE OF MOVE
	CMP	SAFEWORD	;SEE IF TOO MUCH
	BCC	ME293
	LDA	SAFEWORD
	STA	SAFEX
	JSR	NEGATE
	JMP	ME292C		;USE MAX IF TOO MUCH

ME292A:	CLC
	ADC	ENEMYFEET,X	;IF PLUS MOVEMENT, ADD IT TO THE FEET
	BCS	ME292B
	CMP	#239
	BCC	ME293		;DON'T ALLOW BELOW 239
ME292B:	LDA	#239
	SEC
	SBC	ENEMYFEET,X	;MOVE MAX THAT GETS US TO THE BOTTOM
	STA	SAFEX
ME292C:	STA	SAFEY

;NOW BREAK THAT Y MOVEMENT UP INTO 2 CHUNKS IN CASE ITS LARGER THAN 8.
;THE ABSOLUTE VALUE IS IN SAFEX.

ME293: 	LDA	SAFEY
	STA	SAFEY2		;SAVE FIRST AMOUNT TO MOVE
	LDA	#0
	STA	SAFEY		;SET SECOND AMOUNT TO MOVE AS 0
	LDA	SAFEX
	SEC
	SBC	#8
	BCC	ME190		;IF NOT ABOVE 8, ITS OK AS IS
	BEQ	ME190
	STA	SAFEY
	LDA	#8
	STA	SAFEY2		;SET THE TWO AMOUNTS TO MOVE
	LDA	ENEMYYMOM,X	;SEE IF NEED NEGATE
	BPL	ME190
	LDA	SAFEY
	JSR	NEGATE
	STA	SAFEY
	LDA	SAFEY2
	JSR	NEGATE
	STA	SAFEY2		;MAKE THE CORRECT DIRECTION IF NEGATIVE

;NOW MAKE THE DESIRED X MOVEMENT.  AGAIN, IF MORE THAN 8 PIXELS WE HAVE
;TO BREAK IT UP INTO 2 MOVEMENT AMOUNTS.  ALSO, WE DON'T ALLOW SOME ENEMIES
;TO MOVE RIGHT OFF THE VISUAL SCREEN.

ME190: 	LDA	#0
	STA	SAFEX		;ASSUME THE SECOND MOVEMENT IS 0
	LDA	ENEMYXMOM,X
	BPL	ME294
	JSR	NEGATE
	JSR	DIV8	;MAKE /8 VALUE
	LDX	#$FF	;SET FLAG OF WE HAD TO NEGATE IT.
	JMP	ME294A
ME294:	JSR	DIV8	;MAKE ACTUAL MOVEMENT
	STA	SAFEX2	;SAVE HERE FOR CAN'T MOVE RIGHT OFF SCREEN FLAG
	LDA	ENEMYFLGS,X
	AND	#$10	;CAN'T MOVE RIGHT OFF VISUAL SCREEN?
	BEQ	ME191
	LDA	ENEMYX,X	;SEE IF WE ARE ANYWHERE NEAR RIGHT SIDE
	BPL	ME191		;IF NOT, DON'T BOTHER WITH CHECK
	JSR	NEGATE		;MAKE DISTANCE TO RIGHT
	SEC
	SBC	ENEMYWIDE,X	;MAKE PIXELS TO RIGHT OF HERO
	BCS	ME192
      	LDA	#0
	STA	SAFEX2		;IF ERROR, ZERO AMOUNT TO MOVE
ME192:	CMP	SAFEX2		;MAKE SURE ITS MORE THAN ENOUGH
	BCS	ME191
	STA	SAFEX2		;IF NOT, USE WHAT WE HAVE LEFT
ME191: 	LDX	#0	;SET FLAG OF DIDN'T HAVE TO NEGATE IT
	LDA	SAFEX2	;GET BACK AMOUNT TO MOVE

ME294A:	STA	SAFEX2	;PUT IT HERE AS THE FIRST CHUNK TO MOVE
	SEC
	SBC	#8	
	BCC	ME294B		;IF NOT ABOVE 8, ITS OK AS IS
	BEQ	ME294B
	STA	SAFEX
	LDA	#8
	STA	SAFEX2		;SET THE TWO AMOUNTS TO MOVE
ME294B:	CPX	#0		;SEE IF NEED NEGATE
	BEQ	ME295
	LDA	SAFEX
	JSR	NEGATE
	STA	SAFEX
	LDA	SAFEX2
	JSR	NEGATE
	STA	SAFEX2		;MAKE THE CORRECT DIRECTION IF NEGATIVE

;RESET THE BITS THAT SIGNAL WE MOVED ON AN AXIS.  THEY ARE NEEDED FOR
;BOUNCING.

ME295: 	LDX	SAFEBYTE	;GET ENEMY INDEX
	LDA	ENEMYSTAT,X	;GET MOVEMENT BITS FOR X AND Y
	LDY	SAFEY2
	BNE	MEY3
	AND	#$FE		;IF Y VELOCITY 0, RESET Y MOVED BIT  
MEY3:	LDY	SAFEX2		;NOW CHECK X FOR 0
	BNE	MEY4
	AND	#$FD		;IF X IS 0, RESET X MOVED BIT
MEY4:	STA	ENEMYSTAT,X

;WE HAVE THE DESIRED X AND Y MOVEMENTS.  IF THERE WAS MORE THAN 8 PIXELS
;TO MOVE WE BROKE IT UP INTO 2 MOVEMENTS IN SAFEX AND SAFEX2 (OR SAFEY).
;IF WE TRIED TO MOVE MORE THAN 8 IN A PASS WE'D MISS 1 HIGH SOLIDS.

MEY32:	LDX	SAFEX2
	LDY	SAFEY2
	TXA
	ORA	SAFEY2		;END IF NOTHING TO MOVE
	BNE	MEY6
	JMP	MEY50

MEY6:	JSR	MOVESET
	BNE	MEY10		;IF IT WOULDN'T MOVE, GO DO IT PIXEL WISE
	LDA	SAFEX2		;SEE IF REAL X MOVEMENT
	BEQ	MEY5
	JSR	REALXMOVE	;SET FLAG FOR REAL X MOVEMENT
MEY5:	LDA	SAFEY2
	BEQ	MEY7
	JSR	REALYMOVE	;AND FOR Y IF APPLICABLE
	LDA	ENEMYSTAT,X
	AND	#$EF
	STA	ENEMYSTAT,X	;RESET CONTACTED SOLID BIT
MEY7: 	LDA	SAFEY
	STA	SAFEY2
	LDA	SAFEX
	STA	SAFEX2
	LDA	#0
	STA	SAFEX
	STA	SAFEY
	JMP	MEY32

;ENEMY WOULD NOT MOVE.  MOVE X AS FAR AS POSSIBLE.  WE HAVE TWO AMOUNTS
;LEFT TO MOVE IN SAFEX2 AND SAFEX.

MEY10:	LDX	SAFEX2
	BEQ	MEY20
	LDY	#0
	JSR	MOVESET		;TRY TO MOVE JUST THE X
	BNE	MEY12
	JSR	REALXMOVE	;SET FLAG TO SIGNAL WE DID FOR BOUNCE
 	LDA	SAFEX
	STA	SAFEX2		;MOVE THE SECOND AMOUNT UP
	LDA	#0
	STA	SAFEX		;ZERO THE SECOND AMOUNT
	JMP	MEY10

MEY12:	LDA	ENEMYSTAT,X	;IF WE NEED TO BOUNCE, SEE IF WE MOVED BEFORE
	AND	#2
	BNE	MEY13		;IF SO, MAKE BOUNCE FACTOR.
	LDA	ENEMYXMOM,X	;IF NOT, WE WANT TO ZERO BUT PRESERVE SIGN
	AND	#$80
	BEQ	MEY13B
	LDA	#-1
	JMP	MEY13B

MEY13:	LDA	ENEMYXMOM,X	;GET OLD MOMENTUM
	JSR	MAKEMOM		;FIX IT FOR BOUNCE FACTOR
MEY13B:	STA	ENEMYXMOM,X	;REVERSE THE X MOMENTUM, WE HIT SOLID
	
MEY15: 	LDA	SAFEX2		;GET CURRENT VALUE
	ROL	A
	LDA	SAFEX2
	ROR	A		;DO SIGNED DIVIDE BY 2
	STA	SAFEX2		;SET FOR NEXT TIME
	TAX			;AND WE'LL TRY TO MOVE THAT AMOUNT
	BNE	MEY17
	INX			;BUT DON'T MOVE 0
MEY17:	LDY	#0
	JSR	MOVESET	
	BNE	MEY18
	JSR	REALXMOVE
	JMP	MEY15		;IF DIDN'T HIT, CONTINUE

MEY18:	LDA	SAFEX2
	BEQ	MEY20		;IF WE TRIED 1 AND COULDN'T, DONE
	CMP	#-1		;OR IF WE TRIED -1
	BNE	MEY15
	
;MOVE Y AS FAR AS POSSIBLE

MEY20:	LDY	SAFEY2
	BEQ	MEY50
	LDX	#0
	JSR	MOVESET		;TRY TO MOVE JUST THE Y
	BNE	MEY22
	JSR	REALYMOVE	;SET FLAG FOR BOUNCE THAT WE DID MOVE SOME
 	LDA	SAFEY
	STA	SAFEY2		;MOVE THE SECOND AMOUNT UP
	LDA	#0
	STA	SAFEY		;ZERO THE SECOND AMOUNT
	JMP	MEY20

MEY22:	LDA	SAFEY2		;SEE IF IT WAS + ON Y (DOWN)
	BMI	MEY23
	LDA	ENEMYSTAT,X
	ORA	#$10		;SET STANDING BIT
	STA	ENEMYSTAT,X	
MEY23:	LDA	ENEMYSTAT,X	;IF WE NEED TO BOUNCE, SEE IF WE MOVED BEFORE
	AND	#1
	BNE	MEY24		;IF SO, MAKE BOUNCE FACTOR.
	LDA	ENEMYYMOM,X	;IF NOT, WE WANT TO ZERO BUT PRESERVE SIGN
	AND	#$80
	BEQ	MEY24B
	LDA	#-1
	JMP	MEY24B

MEY24:	LDA	ENEMYYMOM,X	;GET OLD MOMENTUM
	JSR	MAKEMOM		;FIX IT FOR BOUNCE FACTOR
MEY24B:	STA	ENEMYYMOM,X	;REVERSE THE X MOMENTUM, WE HIT SOLID
	
MEY25:	LDA	SAFEY2		;GET CURRENT VALUE
	ROL	A
	LDA	SAFEY2
	ROR	A		;DO SIGNED DIVIDE BY 2
	STA	SAFEY2		;SAVE FOR NEXT TIME
	TAY			;AND WE'LL TRY TO MOVE THAT AMOUNT
	BNE	MEY27
	INY			;BUT DON'T LET CARRY GO OUT
MEY27:	LDX	#0
	JSR	MOVESET	
	BNE	MEY28
	JSR	REALYMOVE
	JMP	MEY25		;IF DIDN'T HIT, CONTINUE

MEY28:	LDA	SAFEY2
	BEQ	MEY50		;ZERO IS 1 FROM ABOVE, IF WE COULDN'T: DONE.
	CMP	#-1		;AND ALSO DONE IF -1 WOULDN'T MOVE.
	BNE	MEY25
	
;DONE MOVING ENEMY. SET THE DIRECTION THE ENEMY FACES.  

MEY50:	JSR	USEFACE
	JSR	MIRRORINVERT

;CHECK FOR A NEW WORLD COLUMN TO TEST.

FE100:	LDX	SAFEBYTE
	LDA	ENEMYFLGS,X
	BPL	ME350		;SKIP IF THIS ENTITY DOESN'T CHECK COLUMNS
	JSR	MAKE_ECOL	;MAKE THIS ENTITIES COLUMN
	LDA	SAFEWORD
	CMP	ENEMYLTST,X	;SEE IF LAST COLUMN MATCHES IT
	BNE	ME340		;IF NOT, WE NEED TEST AGAIN
	LDA	SAFEWORD+1
	CMP	ENEMYHTST,X
	BNE	ME340
	LDA	SAFEY
	CMP	ENEMYLROW,X	;SEE IF LAST ROW MATCHES IT
	BEQ	ME350		;IF IT DOES, DON'T TEST AGAIN

ME340:	LDA	SAFEWORD
	STA	ENEMYLTST,X	;SET AS ONE WE JUST TESTED
	LDA	SAFEWORD+1
	STA	ENEMYHTST,X
	LDA	SAFEY
	STA	ENEMYLROW,X	;AND SET ROW TOO
	JSR	TESTFLGS	
ME350:	RTS

;THIS SUB WILL CORRECTLY MIRROR OR INVERT THE ENTITY SAFEBYTE ACCORDING
;TO ITS FACE BITS.  IT USES ENEMYFACE:

;				<CURRENT> ($80) FOR NO CHANGE
;				<TRAVELING> ($40) LEFT/RIGHT TRAVEL DIRECTION
;				<RISING> ($20) UP/DOWN TRAVEL DIRECTION
;				<JOYDIR> ($10) JOYSTICK LEFT/RIGHT DIRECTION
;				<UP> (8) TO TURN THE SPRITE UPSIDE DOWN
;				<DOWN> (4) TO REVERT THE SPRITE TO THE WAY IT
;				<LEFT> (2) TO MIRROR THE SPRITE AND LOCK IT
;				<RIGHT> (1) TO FACE RIGHT
USEFACE:
	LDX	SAFEBYTE
	LDA	ENEMYFACE,X	;GET DIRECTION FLAG
	BPL	UFE20
	JMP	UFE100

UFE20:	TAY			;KEEP A COPY
	AND	#$40		;SEE IF DIRECTION OF TRAVEL
	BNE	UFE40
	TYA			;GET BACK A COPY
	AND	#$10		;JOYSTICK DIRECTION?
	BNE	UFE30
	TYA
	AND	#3		;GET LEFT/RIGHT BITS
	BEQ	UFE60		;IF NEITHER, LEAVE X AXIS ALONG
	LSR	A
	JMP	UFE50		;IF NONE OF ABOVE, USE LEFT BIT

;JOYSTICK DIRECTION.

UFE30:	LDY	ENEMYLINK,X	;SEE IF WE ARE LINKED TO SOMEONE
	BMI	UFE31	
	LDA	ENEMYJSTAT,Y	;IF SO, USE THEIR JOYSTICK DIRECTION BIT
	JMP	UFE32
UFE31:	LDA	ENEMYJSTAT,X	;IF JOYSTICK DIRECTION, GET STAT BIT
UFE32:	AND	#$10
	BNE	UFE45
     	LDA	#0		;RIGHT IF NOT SET
	JMP	UFE50

UFE40:	LDA	#0		;ITS THE MOMENTUM DIRECTION
	LDY	ENEMYXMOM,X	;GET MOMENTUM FOR HORIZONTAL TRAVEL
	BPL	UFE50
UFE45:	LDA	#1		;IF NEGATIVE MOMENTUM, MIRROR ENEMY
UFE50: 	ASL	ENEMYTRACK,X
	ROR	A
	ROR	ENEMYTRACK,X	;MOVE THE BIT INTO BIT $80 OF ENEMYTRACK

UFE60:	LDX	SAFEBYTE	;NOW CHECK Y DIRECTION.
	LDA	ENEMYFACE,X
	TAY			;KEEP A COPY
	AND	#$20		;SEE IF DIRECTION OF TRAVEL UP AND DOWN
	BNE	UFE80
	TYA
	AND	#$0C		;GET UP/DOWN BITS
	BEQ	UFE99		;IF NEITHER, LEAVE Y AXIS ALONG
	JSR	DIV8
	JMP	UFE90		;OTHERWISE, USE UP BIT

UFE80:	LDA	#0		;ITS THE MOMENTUM DIRECTION
	LDY	ENEMYYMOM,X	;GET MOMENTUM FOR VERTICAL TRAVEL
	BPL	UFE90
UFE85:	LDA	#1		;IF NEGATIVE MOMENTUM, INVERT ENEMY
UFE90: 	CLC
	ROR	A
	ROR	A
	ROR	A		;MOVE THE BIT INTO BIT $40 
	STA	SAFEWORD
	LDA	ENEMYTRACK,X
	AND	#$BF
	ORA	SAFEWORD
	STA	ENEMYTRACK,X	;SET DIRECTION WE ARE FACING
UFE99:	RTS

;CALL HERE TO MIRROR OR INVERT ACCORDING TO THE ENEMYTRACK BITS.
;X RETURNS SAFEBYTE

MIRRORINVERT:

	LDX	SAFEBYTE
	LDA	ENEMYTRACK,X
	AND	#$80
	TAX
	LDA	SAFEBYTE
	JSR	MIRROR
	LDX	SAFEBYTE
	LDA	ENEMYTRACK,X
	AND	#$40
	TAX
	LDA	SAFEBYTE
	JSR	INVERT
	LDX	SAFEBYTE
UFE100:	RTS

;THIS SUB WILL MAKE THE SCREEN COLUMN THAT THE ENTITY IN X IS 
;CURRENTLY ON AND RETURN IT IN SAFEWORD (WORD).  IT RETURNS THE ROW
;THAT THE ENTITY'S FEET ARE CURRENTLY ON IN SAFEY (BYTE).

MAKE_ECOL:
	LDA	ENEMYCENTR,X	;GET ENEMIES CENTER LINE
	CLC
	ADC	XBACK
	STA	SAFEWORD
	LDA	XBACK+1
	ADC	#0	
	STA	SAFEWORD+1
	LSR	SAFEWORD+1
	ROR	SAFEWORD
	LSR	SAFEWORD+1
	ROR	SAFEWORD
	LSR	SAFEWORD+1
	ROR	SAFEWORD
	LDA	ENEMYFEET,X
	JSR	DIV8
	STA	SAFEY		;SET ROW HE'S ON
	RTS

REALXMOVE:		;CALL HERE TO SET THE X MOVED BIT IN ENEMYSTAT.
	LDA	ENEMYSTAT,X
	ORA	#2
	STA	ENEMYSTAT,X
	RTS

REALYMOVE:		;CALL HERE TO SET THE Y MOVED BIT IN ENEMYSTAT.
	LDA	ENEMYSTAT,X
	ORA	#1
	STA	ENEMYSTAT,X
	RTS

;THIS ROUTINE WILL POSITION AN ENTITY THAT IS LINKED TO ANOTHER ENTITY
;AND CORRECTLY MIRROR/INVERT IT.  YOU MUST MAKE SURE IT IS LINKED
;(ENEMYLINK <> -1).  SAFEBYTE MUST HAVE ITS INDEX.  IF THE ENTITY TO
;WHICH YOURS IS LINKED DIES YOUR ENTITY WILL UNLINK.

PUTLINK:
	LDX	SAFEBYTE
	LDY	ENEMYLINK,X
	JSR	VALID		;MAKE SURE ITS STILL ALIVE
	BNE	PLN5
     	STA	ENEMYLINK,X	;IF NOT, UNLINK US
	RTS

;SEE IF WE ARE GOING TO USE OUR OWN FACE FLAG OR DO IT FROM THE
;ONE WE ARE LINKED TO.

PLN5: 	LDA	ENEMYJSTAT,X	;SEE IF IT HONORS FACE BITS ANYWAY
	AND	#4
	BEQ	PLN6

;WE ARE CALCULATING OFF OUR OWN BITS.

	JSR	USEFACE		;USE ITS OWN FACE FLAG
	JMP	PLN7

;WE ARE CALCULATING OFF THE ENTITY WE ARE LINKED TO.

PLN6:	LDA	ENEMYTRACK,Y	;GET ONE ITS LINKED TO'S DIRECTION BITS
	AND	#$C0
	STA	SAFEWORD
	LDA	ENEMYTRACK,X
	AND	#$3F
	ORA	SAFEWORD
	STA	ENEMYTRACK,X	;SET AS OUR DIRECTION BITS

PLN7:	JSR	MIRRORINVERT	;USE THE BITS WE CREATED

	LDY	ENEMYLINK,X
	LDA	ENEMYTRACK,Y	;GET ONE TO WHOM WE ARE LINKED'S BITS
	STA	SAFEWORD
	ROL	A		;MOVE MIRROR BIT INTO CARRY
	LDA	ENEMYXFRICT,X	;GET OUR RELATIVE X
	BCC	PLN10
	JSR	NEGATE		;NEGATE IT IF MIRRORED
	CLC
	ADC	ENEMYWIDE,Y	;AND CORRECT FOR HIS WIDTH
	SEC
	SBC	ENEMYWIDE,X	;AND CORRECT FOR OUR WIDTH
PLN10:	CLC
	ADC	ENEMYX,Y	;POSITION OUR X RELATIVE TO HIS
	STA	ENEMYX,X	;SET OUR NEW X POSITION

	LDA	ENEMYYFRICT,X	;GET OUR RELATIVE Y
	ROL	SAFEWORD
	ROL	SAFEWORD	;GET UPSIDE DOWN BIT
	BCC	PLN20
	JSR	NEGATE		;IF UPSIDE DOWN, INVERT OUR RELATIVE Y
	CLC
	ADC	ENEMYHIGH,Y	;AND CORRECT FOR HIS HEIGHT
	SEC
	SBC	ENEMYHIGH,X
PLN20:	CLC
	ADC	ENEMYY,Y
	STA	ENEMYY,X	;SET OUR NEW Y
	JSR	FINDLOCS
	RTS

;THIS ROUTINE WILL TAKE A MOMENTUM VALUE IN A AND APPLY THE BOUNCE FACTOR
;TO IT AND REVERSE ITS DIRECTION.  IT RETURNS THE RESULT IN A.  
;IT USES SAFEWORD.  X AND SAFEBYTE MUST HAVE THE ENEMY INDEX.
;IF THE BOUNCE IS SET TO ZERO, IT WILL PRESERVE THE SIGN OF THE OLD
;MOMENTUM BUT SET IT TO -1 OR 0.

MAKEMOM:
	STA	SAFEWORD+1	;SAVE ORIGINAL VALUE HERE FOR SIGN CHECK
	BPL	MM5
	JSR	NEGATE
MM5:	STA	SAFEWORD	;SAVE ABSOLUTE VALUE HERE
	LDA	ENEMYBOUNCE,X	;GET BOUNCE
	BEQ	MM20		;CATCH SPECIAL CONDITION OF 0 TO SAVE TIME
	TAX			;GET BOUNCE FACTOR HERE
	LDY	SAFEWORD	;MULTIPLY BY ABSOLUTE VALUE
	INX			;INCREASE BOUNCE FACTOR AS PROMISED
	BEQ	MM6
	JSR	MUL
MM6:	TYA			;THEN DIVIDE BY 256
	LDY	SAFEWORD+1	;SEE IF WE NEED SIGN REVERSAL
	BMI	MM10
	JSR	NEGATE		;REVERSE SIGN OF ORIGINAL AMOUNT
MM10: 	LDX	SAFEBYTE
	RTS

MM20:	LDA	SAFEWORD+1	;IF NO BOUNCE, GET SIGN TO PRESERVE IT
	AND	#$80
	BEQ	MM10
	LDA	#-1
	JMP	MM10

;CALL HERE WITH DATA1 AND DATA2 TO APPLY IT TO THE ENTITIES X AND Y MOMENTUM 
;CHANGES. IT WILL SIGN CORRECT FOR THE TRACKING DIRECTION BUT WILL
;NOT LIMIT IT OR APPLY GRAVITY.  IT PREVENTS OVERFLOW AND IT SETS THE 
;STATUS BITS THAT FRICTION USES AND DETECTS.  ENTITY INDEX SHOULD BE 
;IN SAFEBYTE ON ENTRY.  THIS ROUTINE USES SAFEX AND SAFEY AND SAFEX2.

;IN REPLACEMENT MODE, -1 WILL MEAN DON'T CHANGE THE OLD VALUE.

USEMOM:				;CALL HERE FOR ADD TO MOMENTUM WITH SIGN 
	LDA	#0		;CORRECTION ACCORDING TO TRACKING.
	JMP	USM5

USEMOM2:	     		;CALL HERE FOR REPLACE MOMENTUM WITH SIGN
	LDA	#$80		;CORRECTION ACCORDING TO TRACKING.
	JMP	USM5

USEMOM3:			;CALL HERE FOR REPLACE MOMENTUM WITHOUT 
	LDA	#$C0		;TRACKING.
	JMP	USM5

USEMOM4:			;CALL HERE FOR ADD MOMENTUM WITHOUT TRACKING.
	LDA	#$40
	
USM5:	STA	SAFEX2		;SET CONDITION OF ADJUSTMENT FLAGS.
				;80H = REPLACE, 40H=DON'T TRACK
	LDX	SAFEBYTE
	LDA	ENEMYFCTR,X	;GET STATUS BITS
	LDY	DATA1
	STY	SAFEX		;SAVE IT HERE IN CASE OF REPLACE
	BEQ	USM10
	AND	#$F0		;REMOVE COUNTER ON DELAY TO FRICTION ON
	ORA	#XFCTR
USM10:	LDY	DATA2
	STY	SAFEY		;SAVE HERE IN CASE OF REPLACE
	BEQ	USM20
	AND	#$0F		;REMOVE Y COUNTER VALUE
	ORA	#YFCTR*16
USM20:	STA	ENEMYFCTR,X

	LDA	SAFEX2		;SEE IF TRACKING DESIRED
	AND	#$40
	BNE	USM44

	JSR	TRACKDIR	;SEE WHAT THE TRACKING DIRECTION CORRECTION IS
	BPL	USM42		;IF PLUS, VALUE IS OK	
	LDA	DATA1
	JSR	NEGATE
	STA	DATA1
USM42: 	LDA	SUBSVAR5	;GET BACK TRACKDIR
	AND	#1
	BEQ	USM44
	LDA	DATA2
	JSR	NEGATE
	STA	DATA2

USM44:	LDA	SAFEX2		;TIME TO UPDATE.  GET ADD OR REPLACE BIT
	BPL	USM50

	LDA	SAFEX
	CMP	#-1
	BEQ	USM45
	LDA	DATA1
	STA	ENEMYXMOM,X
USM45:	LDA	SAFEY
	CMP	#-1
	BEQ	USM47
	LDA	DATA2
	STA	ENEMYYMOM,X	;DO REPLACEMENT IF SO SPECIFIED
USM47:	RTS

USM50:	LDA	DATA1
	CLC
	ADC	ENEMYXMOM,X
	BVS	USM55
	STA	ENEMYXMOM,X	;IF NO OVERFLOW, USE NEW VALUE

USM55:  LDA	DATA2
	CLC
	ADC	ENEMYYMOM,X
	BVS	USM65
	STA	ENEMYYMOM,X	
USM65:	RTS

;THIS ROUTINE WILL TAKE AN ENEMY INDEX IN SAFEBYTE AND AN ANIMATION INDEX
;IN A AND WILL SETUP UP THE ANIMATION, DO ITS INIT OPTIONS, GET ITS
;AUXILARY FLAG, AND SET THE EXECUTE POINTER.  ON RETURN, EVERYTHING
;IS SETUP UP UNLESS THERE WAS NO ROOM TO INITIALIZE THE ANIMATION.
;IF THAT WAS THE CASE, THIS ROUTINE RETURNS NZ.  IF Z, SUCCESS.

;ON ENTRY, ENEMYX AND ENEMYY MUST HAVE YOUR DESIRED X, Y COORDINATE TO
;PUT THE ENEMY DOWN.  THIS ROUTINE WILL ATTEMPT TO PREVENT PUTTING DOWN
;ON TOP OF SOLID IN A HORIZONTAL DIRECTION.  ENEMYCENTR
;MUST HAVE THE CENTER OF THE LAST ANIMATION THIS ENEMY WAS USING OR 0
;IF YOU ARE STARTING OUT WITH A COMPLETELY NEW ONE.  THIS ROUTINE WILL
;"CENTER" THE ENEMY IF THE NEW WIDTH IS DIFFERENT.  SETUPFLG MUST BE SET
;AS DESCRIBED BELOW.

;THIS ROUTINE SETS ENEMYPTR TO THE NEW INDEX BECAUSE SOME CALLERS
;EXPECT THAT TOO.  SAFEWORD IS USED.

;YOU MAY USE THIS ROUTINE TO PICK AN ANIMATION ONLY (AND OPTIONALLY ITS
;DAMAGE FLAGS) BY SETTING SETUPFLG:
;0 = USE ALL INFORMATION FROM THE TABLE
;1 = USE JUST THE ANIMATION, NO DAMAGE FLAGS OR MOVEMENT TABLE.
;2 = USE THE ANIMATION, DAMAGE FLAGS, NOT THE MOVEMENT TABLE.

SETUPANIM:
	PHA			;SAVE INDEX INTO THE ANIMATION LIST
	JSR	POINTENEMY
SETUPA2:
	LDY	#0
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;MAKE POINTER TO THE ANIMATION LIST
	PLA
	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	#0
	STA	SUBSVAR2	;MAKE DIRECT POINTER TO THE ANIMATION ENTRY

;CALL HERE WITH (SUBSVAR1) POINTING TO THE ANIMATION/MOVEMENT ENTRY TO USE.

SETUP2:	LDA	ENEMYPTR
	PHA
	LDA	ENEMYPTR+1
	PHA
	LDA	SUBSVAR1
	STA	ENEMYPTR
	LDA	SUBSVAR2
	STA	ENEMYPTR+1
	LDX	#10
	JSR	FILLCBUF	;ALLOW THE DATA TO BE IN ANY PAGE
	PLA
	STA	ENEMYPTR+1
	PLA
	STA	ENEMYPTR	;BUT PRESERVE THE NEEDED ENEMYPTR
	JSR	POINT_CMDBUF	;POINT TO THE DATA WE GOT	

	LDX	SAFEBYTE
	LDY	#3
	LDA	SETUPFLG	;DON'T USE THE MOVEMENT TABLE AT ALL?
	BNE	SAM2
	LDA	(SUBSVAR1),Y	;GET EXECUTE INDEX HIGH
	CMP	#-1		;IS IT THE DON'T CHANGE FLAG?
	BEQ	SAM2
	DEY
	STA	ENEMYINH,X
	STA	ENEMYPTR+1
	LDA	(SUBSVAR1),Y
	STA	ENEMYINL,X	;SET INTO STORAGE
	STA	ENEMYPTR	;SET HERE FOR SOME CALLERS AS PROMISED

	
SAM2: 	LDY	#1		;SEE IF WE ARE GOING TO USE THE ANIMATION
	LDA	(SUBSVAR1),Y
	CMP	#-1		;-1 MEANS WE ARE NOT
	BNE	SAM3
	JMP	SAM40		;SKIP REST IF NOT
SAM3: 	LDY	#4
	LDA	(SUBSVAR1),Y
	STA	SAFEWORD	;SAVE INIT OPTIONS HERE

	LDA	SETUPFLG	;SEE IF WE WANT THE DAMAGE FLAGS OR NOT
	CMP	#1
	BEQ	SAM4		;1 = DON'T USE THEM

	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #1
	STA	ENEMYD1,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #2
	STA	ENEMYD2,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #3
	STA	ENEMYD3,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #4
	STA	ENEMYD4,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #5
	STA	ENEMYD5,X

	LDA	ENEMYSTAT,X	;GET STATUS BITS
	ORA	#$28
	EOR	#8		;RESET THE WE ATTACKED SOMEONE BIT
	STA	ENEMYSTAT,X	;REARM ATTACK, ITS A NEW ANIMATION

SAM4:	LDY	#0
	LDA	(SUBSVAR1),Y
	STA	EXTRA_PTR
	PHA			;SAVE COPY
	INY
	LDA	(SUBSVAR1),Y
	STA	EXTRA_PTR+1	;GIVE OURSELVES ACCESS TO THE ANIMATION INFO
	STA	SUBSVAR2	;PUT RESULTING ANIMATION HERE
	PLA
	STA	SUBSVAR1	;NOW SUBSVAR1 HAS INIT PTR FOR INITSPRT.

	LDY	#0
	LDA	(EXTRA_PTR),Y	
	CMP	#83		;ASCII "S"?
	BNE	SAM5		;IF NOT, IT WAS A SIMPLE SPRITE.

	LDY	#3		;OTHERWISE ITS AN ANIMATION.
	LDA	(EXTRA_PTR),Y
	PHA
	INY
	LDA	(EXTRA_PTR),Y
	STA	EXTRA_PTR+1	;SET A POINTER TO THE FIRST ANIMATION FRAME
	PLA
	STA	EXTRA_PTR

SAM5: 	LDY	#0
	LDA	(EXTRA_PTR),Y	;GET DOUBLE BIT
	ROL	A		;MOVE IT INTO THE CARRY
	LDY	#2
	LDA	(EXTRA_PTR),Y	;GET HEIGHT OF ANIMATION IN CELLS
	BCC	SAM5A	
	ASL	A		;DOUBLE BECAUSE HE'S 2 BY 2 MODE
SAM5A:	JSR	TIMES8
	LDY	ENEMYHIGH,X	;GET OLD HEIGHT
	STA	ENEMYHIGH,X	;SAVE HEIGHT IN PIXELS
	TYA
	BEQ	SAM5B
	SEC
	SBC	ENEMYHIGH,X	;MAKE DIFFERENCE IN HEIGHT
	CLC
     	ADC	ENEMYY,X
	STA	ENEMYY,X

SAM5B:	LDY	#1
	LDA	(EXTRA_PTR),Y	;GET WIDTH OF ANIMATION IN CELLS
	JSR	TIMES8
	STA	ENEMYWIDE,X	;SET NEW WIDTH FOR ENTITY
	LSR	A		;MAKE HALF WIDTH
	STA	SAFEWORD+1	;SAVE HERE FOR CENTER CORRECTION

	LDA	ENEMYCENTR,X	;SEE IF WE HAD AN OLD CENTER TO LOCATE FROM
	BEQ	SAM8		;IF OLD CENTER 0, NO CORRECTION NEEDED
	SEC
	SBC	SAFEWORD+1	;MAKE LOCATION OF LEFT HALF TO KEEP CENTER
	BCS	SAM7		
	LDA	#0
SAM7: 	STA	ENEMYX,X

SAM8:  	LDA	ENEMY0,X	;GET ENEMY FLAG BEFORE WE CHANGE HIM
	PHA
	LDA	#-1
	STA	ENEMY0,X	;MARK IT OFF SO LOW LEVEL WON'T MOVE IT
	TXA
	JSR	KILLSPRT	;GET RID OF THE OLD SPRITE
	LDY	SUBSVAR2
	LDX	SUBSVAR1
	LDA	SAFEBYTE
	JSR	INITSPRT	;PUT UP THE NEW ONE
	BEQ	SAM10
	PLA			;THROW OUT THE SAVED ENEMY0 IF CAN'T INIT
	PHA
	JSR	MAKEDING
	LDX	SAFEBYTE
	PLA
	CMP	#0
      	RTS			;OOPS!!! WE COULDN'T SET IT UP.

SAM10: 	LDX	SAFEBYTE
       	LDY	ENEMYY,X
       	LDA	ENEMYX,X
       	TAX
       	LDA	SAFEBYTE
       	JSR	PUTSPRT		;WE HAVE TO PUT IT ASAP, CAN'T WAIT FOR NMI
				;OR IT'LL FLASH A BIT.
 	JSR	FINDLOCS
	PLA			;GET BACK ENEMY0 FLAG
	STA	ENEMY0,X	;RESTORE IT

	LDA	ENEMYSTAT,X	;SEE IF SOLID IS ON
	AND	#4
	BEQ	SAM20		;IF NOT, IGNORE OUR SOLID VALUE
	JSR	SOLIDON

	LDY	ENEMYY,X
	LDA	ENEMYX,X
	TAX
	LDA	SAFEBYTE	;SEE IF THE NEW POSITION IS COOL
	JSR	TESTPUT
	BEQ	SAM20

;THE ENTITY WAS LAUNCHED OVER SOLID.  TRY MOVING TO THE LEFT BY 8 PIXELS
;OR TO THE RIGHT BY 8.

	LDX	SAFEBYTE
	LDY	ENEMYY,X
	LDA	ENEMYX,X
	SEC
	SBC	#8
	BCS	SAM12
      	LDA	#0
SAM12:	TAX
	LDA	SAFEBYTE
	JSR	TESTPUT		;TRY 8 TO THE LEFT
	BEQ	SAM19

	LDX	SAFEBYTE
	LDY	ENEMYY,X
	LDA	ENEMYX,X
	CLC
	ADC	#8
	BCC	SAM13
      	LDA	#-1
SAM13:	TAX
	LDA	SAFEBYTE
	JSR	TESTPUT		;TRY 8 TO THE RIGHT
	BNE	SAM20

SAM19:	LDX	SAFEBYTE
	LDA	TESTX
	STA	ENEMYX,X	;IF WE CORRECTED LOCATION, SET NEW PLACE
	LDA	TESTY
	STA	ENEMYY,X

SAM20:	LDA	SAFEWORD
	AND	#$30		;SEE IF ANY ALIGNMENT SPECIFIED
	BEQ	SAM30
	TAX			;IF SO, THESE BITS HAVE TYPE OF ALIGNMENT
	LDA	SAFEWORD
	AND	#7		;THESE HAVE SHIFT COUNT
	TAY
	LDA	SAFEBYTE
	JSR	ALIGNANIM		;MAKE HERO ALIGN TO BACKGROUND

;SEE IF ITS AN AUTOFREEZE ANIMATION.

SAM30: 	LDA	SAFEWORD	;SEE IF AUTOFREEZE ANIMATION
	AND	#$40
	BEQ	SAM40
      	LDA	SAFEBYTE
	JSR	AUTOFREEZE

SAM40:	LDX	SAFEBYTE
	LDA	#0		;RETURN SUCCESS
	RTS

;THIS ROUTINE WILL MAKE AN INDEX TO THE ENEMY INFO IN ENTITYTAB FOR THE
;ENEMY IN SAFEBYTE.  ON RETURN, (SUBSVAR1) POINTS TO THE ENTITYTAB ENTRY
;AND X HAS SAFEBYTE.

POINTENEMY:
	LDX	SAFEBYTE
	LDA	ENEMY0,X	;GET ENEMY NUMBER

POINTE2:			;SET UP YOUR OWN ENEMY0 AND X

	STA	SUBSVAR1	;PUT INDEX INTO POINTER
	LDA	#0
	STA	SUBSVAR2
	ASL	SUBSVAR1	;MAKE *2 INDEX
	ROL	SUBSVAR2

	LDA	SUBSVAR1	;GET *2 INDEX

	ASL	SUBSVAR1
	ROL	SUBSVAR2	;MAKE *4 INDEX

	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	#0
	STA	SUBSVAR2	;MAKE *6 INDEX

	LDA	#ENTITYTAB & $FF
	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	#ENTITYTAB >> 8
	ADC	SUBSVAR2
	STA	SUBSVAR2	;SET UP AN INDIRECT POINTER TO THE ENEMY ENTRY
	RTS

;THIS SUB WILL INCREMENT THE WORD VALUE ENEMYPTR.  NO REGS ARE CHANGED.

INCINC:	JSR	INCPTR		;CALL HERE FOR DOUBLE INC

INCPTR:
	INC	ENEMYPTR
	BNE	IPT10
	INC	ENEMYPTR+1
IPT10:	RTS

;THIS SUBS WILL RETURN A FLAG IN A THAT REPRESENTS WHAT SIGN CORRECTIONS
;WE SHOULD MAKE FOR A MOMENTUM VALUE ACCORDING TO THE CURRENT TRACKING
;STATUS AND TARGET.  A HAS THE FLAG ON RETURN (X ASSUMED TO BE ENEMY INDEX
;AND IT'S NOT CHANGED).  SUBSVAR5 ALSO HAS THE FLAG:
;80 = SET IF REVERSE X DIRECTION
;01 = SET IF REVERSE Y DIRECTION

;SAFEX,X2, Y, Y2 ARE NOT USED.

TRACKDIR:
	LDA	#0
	STA	SUBSVAR5	;ZERO THE FLAG FOR RETURN
	JSR	MAKETRACKS	;GET THE LOCATION OF THE ONE TO TRACK
	CMP	#-1		;SEE IF THE NOTHING TO TRACK CONDITION EXISTS
	BEQ	TDR100

;SEE IF WE HAVE X TRACKING

	LDA	ENEMYTRACK,X	;GET THE TRACKING FLAG
	AND	#$03		;X TRACKING?
	BEQ	TDR50
	CMP	#3		;ORIGIN?
	BEQ	TDR50
	AND	#$01		;SEE IF TRACK TOWARDS TARGET ($01 TRUE)
	STA	SUBSVAR4	;BUT WE MUST SAVE IT 
	LDY	#0		;ASSUME PLUS TOWARDS TARGET
	LDA	SUBSVAR1	;GET X LOCATION OF TARGET
	CMP	ENEMYCENTR,X	;SEE IF PLUS
	BCS	TDR30
      	LDY	#$80		;IF TARGET BEHIND US, USE NEGATIVE
TDR30:	TYA			;GET BACK VALUE TO USE
	LDY	SUBSVAR4	;GET TOWARDS BIT
	BNE	TDR40
	EOR	#$80		;IF TRACK AWAY, INVERT SIGN
TDR40:	STA	SUBSVAR5	;SET DIRECTION WE NEED ON X
	
;SEE IF WE HAVE Y TRACKING	

TDR50:	LDA	ENEMYTRACK,X
	AND	#$30
	BEQ	TDR100
	AND	#$10		;SEE IF TRACK TOWARDS TARGET ($10 TRUE)
	STA	SUBSVAR4	;BUT WE MUST SAVE IT 
	LDY	#0		;ASSUME TOWARDS
	LDA	SUBSVAR2	;GET Y LOCATION OF TARGET
	CMP	ENEMYFEET,X	;SEE WHAT DIRECTION WE WANT
	BCS	TDR80
	LDY	#1		;IF TRACK AWAY, INVERT SIGN
TDR80:	TYA
	LDY	SUBSVAR4	;SEE IF TOWARDS OR AWAY
	BNE	TDR90
	EOR	#1
TDR90:	ORA	SUBSVAR5
	STA	SUBSVAR5

;DONE.  BUT WE NEED TO CHECK FOR SPECIAL CONDITION OF TRACK TOWARDS ORIGIN
;REGARDLESS OF TARGET.

TDR100:	LDA	ENEMYTRACK,X	;GET THE TRACKING FLAG
	AND	#$03		;X ORIGIN TRACKING?
	EOR	#3
	BNE	TDR110
	JSR	MAKE_ECOL
	LDY	#0		;ASSUME PLUS DIRECTION
	LDA	ENEMYLCOL,X
	SEC
	SBC	SAFEWORD
	LDA	ENEMYHCOL,X
	SBC	SAFEWORD+1
	BCS	TDR105
	LDY	#$80
TDR105:	STY	SAFEWORD
	LDA	SUBSVAR5
	AND	#$7F
	ORA	SAFEWORD
	STA	SUBSVAR5
TDR110:	LDA	SUBSVAR5	;GET RESULTING FLAG
	RTS

;THIS SUB WILL SET SUBSVAR1 AND SUBSVAR2 TO THE CENTER X AND HEAD 
;Y OF THE CURRENT TARGET THAT THE ENEMY SPECIFIED IN X IS SUPPOSED TO BE 
;TRACKING.  IF THE ENEMY IS SUPPOSED TO BE TARGETING ENEMIES ONLY, AND NO 
;OTHER ENEMY EXISTS, SUBSVAR2 WILL BE SET TO -1 (AN IMPOSSIBLE Y LOCATION).  
;IF THE ENEMY IS SUPPOSED TO ATTACK THE LAST ATTACKER AND THAT ONE IS DEAD, 
;HIS LAST ATTACKER WILL BE CORRECTED TO THE HERO AND HE WILL RETURN THE HERO'S
;VALUE.  ON RETURN FROM THIS ROUTINE SUBSVAR2 IS ALWAYS IN A SO YOU CAN
;CHECK FOR THE -1 CONDITION.

MAKETRACKS:

	LDA	ENEMYTRHI,X	;SEE IF LAST ATTACKER (SPECIAL CASE
	BPL	GTT100		;SKIP IF NOT
	LDA	ENEMYATK,X	;IF LAST ATTACKER, IS THERE ONE?
	CMP	#-1
	BEQ	GTT100
	TAY			;IF THERE WAS A LAST ATTACKER, STILL ALIVE?
	JSR	VALID
	BNE	GTT50
	STA	ENEMYATK,X	;IF NONE ALIVE, RESET LAST ATTACKER
	JMP	GTT100

;		LAST ATTACKER IS TARGET

GTT50:	LDA	ENEMYCENTR,Y	;JUMP HERE TO USE ENEMY SPECIFIED IN Y.
	STA	SUBSVAR1
	LDA	ENEMYFEET,Y
	STA	SUBSVAR2
	RTS

;		3 = ENEMY MATCHING OUR ATTACK LEVEL IS TARGET 

GTT100:	LDA	#-1
	STA	SUBSVAR1	;SET MAX DISTANCE FOR COMPARE OF CLOSEST
	STA	SUBSVAR2	;SET NONE PICKED
	LDY	#0		;START BY CHECKING WITH ENEMY 0

GTT110:	JSR	VALID		;CHECK NEXT ENEMY
	BEQ	GTT140		;SKIP IF INVALID
	TYA
	CMP	SAFEBYTE	;BUT IS IT US?
	BEQ	GTT140		;IF SO, CAN'T ATTACK OURSELVES

	LDA	ENEMYTLLOW,Y	;GET ENEMIES TARGET LEVEL
	AND	ENEMYTRLOW,X	;SEE IF WE HAVE A MATCH
	BNE	GTT112
	LDA	ENEMYTLHI,Y	
	AND	ENEMYTRHI,X	;CHECK THE FULL WORD
	BEQ	GTT140

GTT112:	LDA	ENEMYX,Y	;GET THIS ENEMIES X
	SEC
	SBC	ENEMYX,X
	BCS	GTT115
	JSR	NEGATE
GTT115:	CMP	SUBSVAR1	;SEE IF ITS SMALLER THAN CURRENT
	BCS	GTT140		;IF NOT, DON'T USE THIS ONE
	STA	SUBSVAR1
	STY	SUBSVAR2	;IF IT IS, REPLACE ENEMY TO USE WITH THIS ONE
GTT140:	INY			;SKIP TO NEXT ENEMY
	CPY	#ECNT		;DONE?
	BNE	GTT110	
	LDY	SUBSVAR2	;GET WHO WE PICKED
	CPY	#-1
	BNE	GTT50		;IF THERE WAS ONE, RETURN ITS VALUES.	
	TYA			;RETURN THE -1 FLAG AS PROMISED
	RTS

;-----------------------------------------------------------------------------
; Seed random number generator.
;
SEEDRANDOM:
		LDA	#$FD
		STA	RNDNUM1
		LDA	#$43
		STA	RNDNUM2
		LDA	#$03
		STA	XRANDOM
		RTS

;THIS SUB WILL RETURN A RANDOM NUMBER FROM 0-255 IN A.  ITS ALSO STORED
;IN XRANDOM.  X AND Y ARE NOT CHANGED.

GETRANDOM:
		LDA	RNDNUM1
		CLC
		ADC	#$c3
		STA	RNDNUM1
		LDA	RNDNUM2
		ADC	#$9e
		STA	RNDNUM2
		LDA	XRANDOM
		ADC	#$26
		STA	XRANDOM
		LDY	#0
		LDA	(RNDPTR),Y
		CLC
		ADC	XRANDOM	
		STA	XRANDOM
		PHA
		LDA	RNDPTR
		CLC
		ADC	#1
		STA	RNDPTR
		AND	#1		;KEEP LOW BIT OF POINTER
		TAY
		LDA	RNDPTR+1
		ADC	#0
		ORA	#$80
		AND	#%10111111	;KEEP IN ROM CODE RANGE
		STA	RNDPTR+1
		PLA
		CPY	#0
		BEQ	GETR10
       		EOR	#$80		;INVERT TOP BIT FOR GOOD 50/50 LOGIC
GETR10:		RTS

;THIS ROUTINE WILL DO A TESTPUT USING A RELATIVE X AND Y MOVEMENT
;FOR ENTITY SLOT SAFEBYTE.
;IF SUCCESSFULL WILL SET THE NEW X AND Y ENEMY VARIABLES (ENEMYX,ENEMYY,
;ENEMYCENTR, ENEMYFEET). X ALWAYS RETURNS THE ENEMY INDEX.  A HAS THE 
;RESULT CODE, BUT Z IS ALSO SET.
;IF SOLID ON REQUEST IS SET, THIS ROUTINE WILL TRY TO TURN SOLIDS ON AND
;RESET THE BIT. 

;ON ENTRY, X AND Y HAVE THE SIGNED MOVEMENT VALUES TO APPLY TO THE CURRENT
;ENTITIES LOCATION.

MOVESET:
	JSR	MAKEXY
	LDA	SAFEBYTE
	JSR	TESTPUT
	LDX	SAFEBYTE
	CMP	#0
	BNE	MST5
	LDA	TESTX
	STA	ENEMYX,X	;SET RESULTING POSITION TO SAVE TIME ON GET
	LDA	TESTY
	STA	ENEMYY,X
	JSR	FINDLOCS
	LDA	ENEMYSTAT,X	;SEE IF SOLID ON REQUEST
	AND	#$40		
	BEQ	MST3
	JSR	TRYON		;TRY TO TURN ON SOLIDS IF SO
MST3:	LDA	#0
MST5:	RTS

;THIS ROUTINE FUNCTIONS SIMILAR TO MOVESET EXCEPT THAT ONLY THE FLAG IS
;RETURNED, ENEMYX AND Y ARE NOT CHANGED.  ITS LIKE THE OLD MOVESPRT CALL
;IN THE OLD SUBS.

TESTMOVE:
	JSR	MAKEXY
	LDA	SAFEBYTE
	JSR	TESTPUT
	LDX	SAFEBYTE
	CMP	#0
	RTS

;THIS ROUTINE GENERATES X AND Y FOR TESTMOVE AND MOVESET.

MAKEXY:	
	STX	TESTX
	LDX	SAFEBYTE
      	CLC
	TYA
	BMI	TRM10
	ADC	ENEMYY,X
;	BCC	TRM20
;	LDA	#239		;JUST CAN CORRECTIONS FOR NOW ON Y AXIS
	JMP	TRM20

TRM10:	ADC	ENEMYY,X
;	BCS	TRM20
;	LDA	#0		;THIS PREVENTS JUMPING ONTO STAT BAR
TRM20:	TAY			;MAKE DESIRED Y LOCATION

      	CLC
	LDA	TESTX
	BMI	TRM30
	ADC	ENEMYX,X
	BCC	TRM40
	LDA	#-1
	JMP	TRM40

TRM30:	ADC	ENEMYX,X
	BCS	TRM40
	LDA	#0
TRM40:	TAX			;MAKE DESIRED X LOCATION
	RTS

;CALL HERE TO CALCULATE THE CENTER OF AN ENEMY AND PUT IT INTO ENEMYCENTR
;AND THE FEET AND PUT IT INTO ENEMYFEET.
;SAFEBYTE SHOULD HAVE THE ENEMY INDEX AND IT IS RETURNED IN X.

FINDLOCS:			
	LDX	SAFEBYTE
	JSR	FINDCENTR
	JSR	FINDFEET
	RTS

FINDCENTR: 	 		;CALL HERE WITH X TO FIND IF ENEMYCENTR.
	LDA	ENEMYWIDE,X
	LSR	A
	CLC
	ADC	ENEMYX,X
	BCC	MST2
	LDA	#$FF
MST2:	STA	ENEMYCENTR,X
	RTS

FINDFEET:			;CALL HERE WITH X TO FIND ENEMYFEET
	LDA	ENEMYY,X
	CLC
	ADC	ENEMYHIGH,X
	STA	ENEMYFEET,X
	DEC	ENEMYFEET,X	
	RTS

;************* CODE INSIDE THE VERTICAL RETRACE INTERRUPT *************
;
;THE MAIN STATE MACHINE LOGIC RUNS OUTSIDE NMI (VERTICAL RETRACE INTERRUPT).
;BECAUSE OF THIS, THE ROUTINES INSIDE THIS INTERRUPT MUST BE CAREFUL OF 
;MIXING SPRITE OR BACKGROUND CALLS BECAUSE KUNGSUBS DOES NOT ALLOW MIXING
;SOME LEVELS (KEY VARIABLES ARE NOT SAVED DURING INT).  THIS CODE
;MUST RESTRICT ITSELF TO SPECIFIC FUNCTIONS.  ALSO, IT MUST NOT
;USE VARIABLES USED BY THE NON-NMI CODE.
;
;THE TIMER ROUTINE HERE SETS THE FLAG "PHASE4" BIT 01 TRUE EVERY X NMI 
;INTERRUPTS AS SPECIFIED BY THE VARIABLE CLOCKPHASE IN KUNGTAB.ASM
;THIS GIVES A 15-30 TICKS PER SECOND CLOCK ON NTSC SYSTEMS AND A 50/60
;PHASE CLOCK ON PAL.  SINCE SMOOTH ANIMATION REQUIRES 12 FRAMES,
;WE ARE SAFE FOR SPRITE MOVEMENT ON BOTH SYSTEMS.  AT ANY RATE,
;ONLY THE FLAG IS SET HERE, THE MAINLINE CODE OUTSIDE NMI WILL
;RESET AND USE THIS FLAG.

;******************** NMI PROCESSING CODE **************
;
;THIS ROUTINE IS CALLED AT THE END OF EACH NMI INTERRUPT.  THERE ARE
;ONLY ABOUT 8 MILLISECONDS REMAINING TILL THE NEXT NMI WHEN THIS 
;CODE IS CALLED SO DON'T TAKE TOO LONG!

USER_NMI:

	LDA	BPAUSE		;IF PAUSE, DON'T INC THE CLOCK
	ORA	WORLD_REQUEST	;OR IF WORLD CHANGE IN PROGRESS
	BEQ	RSP5
	RTS

RSP5:	LDA	SAFEBYTE
	PHA			;WE NEED A LOOP COUNTER DURING NMI.

;DEC THE TIME CLOCK.

 	DEC	TIMETICK	;KEEP OUR CLOCK GOING
	BEQ	RSP13
	JMP	RSP20

RSP11:	INC	TIMETICK
	JMP	RSP20

RSP13:	LDA	PHASE4		;MAKE SURE MAINLINE FINISHED ROTATING SPRITES
	AND	#1
	BNE	RSP11		

;ITS ANOTHER CLOCK PHASE

	LDA	CLOCKP
	STA	TIMETICK
	INC	PHASE4		;SET THE NEW MOVEMENT INTERVAL FLAG
				;FOR THE HIGH LEVEL
	INC	ALTPHASE	;FOR HALF FREQUENCE EXECUTERS

;SEE IF THERE'S DATA TO WRITE OUT

RSP20:	LDA	STATLEN
	BEQ	RSP100
	ADC	#4		;ADD HEADER AMOUNT
	STA	SUBSVAR1
	JSR	GET_ROOM		;SEE HOW MUCH ROOM WE HAVE LEFT
	CMP	SUBSVAR1		;MAKE SURE THERE'S ENOUGH ROOM NOW
	BCC	RSP100

;WE HAVE TO WRITE DATA OUT TO THE STATUS LINE.  WE CALL THE SUB BECAUSE
;IT MONKEYS WITH THE STACK TO GET THE DATA.

	JSR	STATWRITE

RSP100:	PLA
	STA	SAFEBYTE	;RESTORE THE LOOP COUNTER WE NEEDED
	RTS

;THIS SUB PROCESSES A STATUS BAR WRITE.  CALL ONLY IF STATLEN IS TRUE
;AND THERE IS ENOUGH ROOM.  STATLEN IS RESET.  

STATWRITE:
	TSX
	TXA
	SEC
	SBC	#33		;MAKE ROOM TO HOLD DATA FOR SOUND COMMANDS
	TAX
	TXS

	LDA	STATTYPE
	CMP	#PALCLR
	BNE	SWR24
	JMP	SWR50

SWR24:	CMP	#SETSTATPAL
	BEQ	SWR23
 	CMP	#WRITEVID
	BNE	SWR25

SWR23:	LDA	STATDATA
	STA	SUBSVAR1
	LDA	STATDATA+1
	STA	SUBSVAR2	;POINT TO THE DATA
	LDA	STATLEN
	STA	SUBSVAR3
	JSR	FILLSTACK	;GET THE DATA INTO THE BUFFER
	TSX
	INX			;POINT TO WHERE THE DATA WENT
	STX	STATDATA
	LDA	#$01
	STA	STATDATA+1	;NOW POINT TO THE DATA IN THE BUFFER
	LDA	STATTYPE
	CMP	#SETSTATPAL	;PALETTE COMMAND IS DIFFERENT
	BNE	SWR25
	JMP	SWR40

SWR25:	LDA	VIDTYPE		;SEE IF VIDEO OR STATUS LINE
	CMP	#STATVID
	BEQ	SWR26
	LDX	STATROW
	LDY	#$20
	JSR	MUL		;IF VIDEO MEMORY, MAKE ROW
	LDA	STATCOL
	JSR	ADD_WORD	;AND ADD COLUMN
	STX	SUBSVAR1
	STY	SUBSVAR2	;MAKE POINTER
	LDA	VIDTYPE
	ASL	A
	ASL	A
	ORA	#$20		;MAKE PAGE 20 OR 24
	CLC
	ADC	SUBSVAR2
	STA	SUBSVAR2	;SET UPPER LOCATION FOR WRITE TO VID
	JMP	SWR27		;GO DO THE WRITE

SWR26:	LDA	STATROW
	STA	SUBSVAR1
	LDA	#0
	STA	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1		;MAKE 1 WORD OFFSET OF ROW
	ROL	SUBSVAR2
	CLC
	LDA	STATCOL
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	#0
	STA	SUBSVAR2		;MAKE OFFSET OF THIS ROW AND COLUMN
	LDA	SUBSVAR1
	CLC
	ADC	STATLO
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	STATHI
	STA	SUBSVAR2
SWR27:	LDA	STATTYPE		;SEE IF SHOW SCORE
	CMP	#SHOWSCORE		;DO WE NEED TO MAKE THE SCORE?
	BNE	SWR32	
	JSR	CONVSCORE	;CONVERT SCORE TO DATA WE NEED AND SET LEN
	JMP	SWR34

SWR32:	CMP	#SHOWREG
	BNE	SWR34
	LDA	STATDATA
	STA	SUBSVAR3
	LDA	STATDATA+1
	STA	SUBSVAR4
	JSR	CONVWORD

SWR34:	LDX	SCCNT
	LDA	#0
	STA	SCNBUF,X
	INX
	LDA	SUBSVAR2
	STA	SCNBUF,X
	INX
	LDA	SUBSVAR1
	STA	SCNBUF,X		;SET HI AND LOW OFFSET
	INX
	LDA	STATLEN
	STA	SCNBUF,X		;SET COUNT
	STA	SUBSVAR1	;SET AS USABLE COUNTER
	INX					      
	LDA	STATTYPE	;SEE WHAT TYPE OF COMMAND IT WAS
	CMP	#FILLVID	;FILL VIDEO?
	BEQ	SWR35		;ITS AN EXCEPTION

	LDY	#0
SWR30:	LDA	(STATDATA),Y
	STA	SCNBUF,X
	INX
	INY
	DEC	SUBSVAR1
	BNE	SWR30
	JMP	SWR38

SWR35:	LDA	STATDATA	;IF SO, GET FILL DATA

SWR37:	STA	SCNBUF,X
	INX
	DEC	SUBSVAR1
	BNE	SWR37
SWR38:	STX	SCCNT
	LDA	#0
	STA	STATLEN		;ZERO LENGTH TO WRITE OUT

	TSX
	TXA
	CLC
	ADC	#33		;RESTORE THE STACK POINTER
	TAX
	TXS
	RTS

;ITS THE STATUS LINE PALETTE COMMAND.  WE MUST MAKE CALCULATIONS

SWR40:	LDA	STATROW
	ASL	A
	ASL	A
	ASL	A		;MAKE A SET OF 8 BYTES FROM THE GROUP ROW
	STA	STATROW

	LDA	#$F8
	SEC
	SBC	STATROW
	STA	SUBSVAR1
	LDA	#$27
	SBC	#0
	STA	SUBSVAR2	;MAKE LOCATION TO WRITE TO

	LDA	#WRITEVID	;FAKE A WRITE OUT DATA COMMAND
	STA	STATTYPE	
	JMP	SWR27		;SHARE CODE

SWR50:	LDA	#$3F
	STA	SUBSVAR2
	LDA	STATCOL
	STA	SUBSVAR1	;SET PLACE TO WRITE
	LDA	#STATROW & $FF
	STA	STATDATA
	LDA	#STATROW >> 8
	STA	STATDATA+1	;POINT TO IT
	JMP	SWR34		;SHARE THE ENDING TO WRITE IT OUT

;THIS ROUTINE WILL CHECK IF A JOYSTICK CONTROLLED ENTITY IS TOO CLOSE TO
;THE LEFT OR RIGHT OF THE SCREEN.  IT FINDS THE BEST COMPROMISE FOR
;SCROLL IF THERE ARE 2 JOYSTICK ENTITIES.  IT SUPPORTS LEFT AND RIGHT
;SCROLL LIMIT COMMANDS.  THIS ROUTINE IS RESPONSIBLE FOR SETTING 
;THE VARIABLE "GLOBAL_XSCR" WHICH IS USED TO ADJUST 
;THE ENTITIES EACH MOVEMENT CYCLE.   IT ALSO MAINTAINS THE HALF AND
;QUARTER SCROLL VALUES.

;FIRST WE MUST SEE IF THERE ARE 2 OR JUST 1.

CHECKSCROLL:
	LDX	JOYENEMY	;SET UP TO USE FIRST FOR SCROLL
	LDY	JOYENEMY+1	;BUT SEE IF THE SECOND IS VALID
	BMI	CSR90		;IF THIS ONE INVALID, CAN USE FIRST
	
  	LDX	JOYENEMY+1	;SET UP TO USE THIS ONE INSTEAD
	LDY	JOYENEMY	;AND SEE IF FIRST IS VALID
	BMI	CSR90		;IF SO, WE CAN USE THE SECOND FOR SCROLL.

;THERE ARE 2 JOYSTICK ENTITIES.  WE ONLY LET THE SCREEN SCROLL IF
;THEY ARE BOTH ON THE SAME HALF OF THE SCREEN.

	JSR	VALID		;SEE IF FIRST IS INVALID ENEMY
	BEQ	CSR90		;IF SO, X HAS SECOND AND MAKESCROLL IS OK.
	LDA	ENEMY0,X	;OR IS JOYENEMY+1 INVALID?
	CMP	#-1
	BNE	CSR10
	STA	JOYENEMY+1	;IF IT WAS, STOP IT FROM EXISTING
	JMP	CHECKSCROLL	;AND LET THE LOGIC TRY AGAIN.

CSR10:	LDA	#0		;ASSUME CONFLICT
	STA	GLOBAL_XSCR
	LDA	ENEMYCENTR,X
	EOR	ENEMYCENTR,Y	;SEE IF THEY ARE BOTH ON THE SAME SIDE
	BMI	CSR100		;IF NOT, DON'T ALLOW SCROLLING.	
	LDA	ENEMYCENTR,X	;IF BOTH ON SAME SIDE, WHICH IS CLOSEST?
	BPL	CSR20
	CMP	ENEMYCENTR,Y	;IF WE ARE ON RIGHT SIDE, GET BIGGER ONE
	BCS	CSR90
	JMP	CSR30

CSR20:	CMP	ENEMYCENTR,Y	;SEE IF WE SHOULD SWAP
	BCC	CSR90		;WE SHOULDN'T IF TO LEFT AND +

CSR30:	LDX	JOYENEMY	;SWAP IF OTHER IS CLOSER

;WE HAVE THE ONE TO MAKE THE SCROLL WITH IN X.

CSR90:	JSR	MAKESCROLL	
	STA	GLOBAL_XSCR

;GLOBAL_XSCR HAS BEEN MADE.  MAKE THE OTHER VALUES.  ALSO, CHECK IF
;SCROLLING IS ENABLED IN THE DIRECTION WE ARE GOING.

CSR100:	LDA	GLOBAL_XSCR
	BPL	CSR105
	LDA	SCROLLFLG	;SEE IF RIGHT SCROLL ENABLED
	AND	#RIGHT
	BNE	CSR107
	JMP	CSR110

CSR105:	LDA	SCROLLFLG
	AND	#LEFT		;SEE IF LEFT ENABLED
	BEQ	CSR110

CSR107:	LDA	#0	     	;IF DISABLED, ZERO IT
	STA	GLOBAL_XSCR

CSR110:	LDA	GLOBAL_XSCR
	BNE	CSR111
       	STA	HALF_XSCR
	STA	QUAR_XSCR	;SAVE PROCESSOR POWER IF 0
	RTS

CSR111:	CLC
	ADC	HALFXLOST	;GET 1/2 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	STA	HALF_XSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	HALFXLOST	;SAVE FOR NEXT TIME


	LDA	GLOBAL_XSCR
	CLC
	ADC	QUARTERXLOST	;GET 1/4 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	JSR	HALFIT
	STA	QUAR_XSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;DOUBLE IT
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	QUARTERXLOST	;SAVE FOR NEXT TIME
	RTS

;THIS ROUTINE WILL CHECK IF A JOYSTICK CONTROLLED ENTITY IS TOO CLOSE TO
;THE TOP OR BOTTOM OF THE SCREEN.  IT FINDS THE BEST COMPROMISE FOR
;SCROLL IF THERE ARE 2 JOYSTICK ENTITIES.  
;THIS ROUTINE IS RESPONSIBLE FOR SETTING 
;THE VARIABLE "GLOBAL_YSCR" WHICH IS USED TO ADJUST 
;THE ENTITIES EACH MOVEMENT CYCLE.   IT ALSO MAINTAINS THE HALF AND
;QUARTER SCROLL VALUES.

;FIRST WE MUST SEE IF THERE ARE 2 OR JUST 1.

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `

CHECKYSCROLL:
	LDX	JOYENEMY	;SET UP TO USE FIRST FOR SCROLL
	LDY	JOYENEMY+1	;BUT SEE IF THE SECOND IS VALID
	BMI	CYR90		;IF THIS ONE INVALID, CAN USE FIRST
	
  	LDX	JOYENEMY+1	;SET UP TO USE THIS ONE INSTEAD
	LDY	JOYENEMY	;AND SEE IF FIRST IS VALID
	BMI	CYR90		;IF SO, WE CAN USE THE SECOND FOR SCROLL.

;THERE ARE 2 JOYSTICK ENTITIES.  WE ONLY LET THE SCREEN SCROLL IF
;THEY ARE BOTH ON THE SAME HALF OF THE SCREEN.

	JSR	VALID		;SEE IF FIRST IS INVALID ENEMY
	BEQ	CYR90		;IF SO, X HAS SECOND AND MAKESCROLL IS OK.
	LDA	ENEMY0,X	;OR IS JOYENEMY+1 INVALID?
	CMP	#-1
	BNE	CYR10
	STA	JOYENEMY+1	;IF IT WAS, STOP IT FROM EXISTING
	JMP	CHECKYSCROLL	;AND LET THE LOGIC TRY AGAIN.

CYR10:	LDA	#0		;ASSUME CONFLICT
	STA	GLOBAL_YSCR
	LDA	ENEMYFEET,X
	EOR	ENEMYFEET,Y	;SEE IF THEY ARE BOTH ON THE SAME HALF
	BMI	CYR100		;IF NOT, DONT ALLOW SCROLLING.	
	LDA	ENEMYFEET,X	;IF BOTH ON SAME SIDE, WHICH IS CLOSEST?
	BPL	CYR20
	CMP	ENEMYFEET,Y	;IF WE ARE ON RIGHT SIDE, GET BIGGER ONE
	BCS	CYR90
	JMP	CYR30

CYR20:	CMP	ENEMYFEET,Y	;SEE IF WE SHOULD SWAP
	BCC	CYR90		;WE SHOULDNT IF TO LEFT AND +

CYR30:	LDX	JOYENEMY	;SWAP IF OTHER IS CLOSER

;WE HAVE THE ONE TO MAKE THE SCROLL WITH IN X.

CYR90:	JSR	MAKEYSCROLL	
	STA	GLOBAL_YSCR

;GLOBAL_YSCR HAS BEEN MADE.  MAKE THE OTHER VALUES.  ALSO, CHECK IF
;SCROLLING IS ENABLED IN THE DIRECTION WE ARE GOING.

CYR100:	LDA	GLOBAL_YSCR
	BPL	CYR105
	LDA	SCROLLFLG	;SEE IF DOWN SCROLL ENABLED
	AND	#DOWN
	BNE	CYR107
	JMP	CYR110

CYR105:	LDA	SCROLLFLG
	AND	#UP		;SEE IF UP ENABLED
	BEQ	CYR110

CYR107:	LDA	#0	     	;IF DISABLED, ZERO IT
	STA	GLOBAL_YSCR

CYR110:	LDA	GLOBAL_YSCR
	BNE	CYR111
       	STA	HALF_YSCR
	STA	QUAR_YSCR	;SAVE PROCESSOR POWER IF 0
	RTS

CYR111:	CLC
	ADC	HALFYLOST	;GET 1/2 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	STA	HALF_YSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	HALFYLOST	;SAVE FOR NEXT TIME


	LDA	GLOBAL_YSCR
	CLC
	ADC	QUARTERYLOST	;GET 1/4 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	JSR	HALFIT
	STA	QUAR_YSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;DOUBLE IT
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	QUARTERYLOST	;SAVE FOR NEXT TIME
	RTS
.endif ;' )

HALFIT:	PHA			;CALL HERE FOR A SIGNED HALF OF A.
	ROL	A
	PLA
	ROR	A
	RTS

;THIS SUB WILL MAKE THE SCROLL REQUEST FOR ENTITY X AND RETURN IT IN
;A.  IT CHECKS FOR ENEMY NOT VALID AND ALSO FOR SCREEN LIMIT STOPS.
;THE VALUE IS ALSO RETURNED IN SUBSVAR3.  THIS ROUTINE CHANGES TESTCOL.

MAKESCROLL:
	LDA	#0
	STA	SUBSVAR3	;ZERO RESULT
	CPX	#-1		;INVALID ENEMY NUMBER?
	BEQ	MSR45
	LDA	ENEMY0,X	;SEE IF THIS ENEMY IS VALID
	CMP	#-1
	BNE	MSR5
MSR4:	JMP	MSR100

;SEE IF WE WANT TO SCROLL LEFT.  

MSR5: 	LDA	#LEFTSCROLL
	SEC
	SBC	ENEMYCENTR,X	;SEE IF POSITIVE LEFT SCROLL (-) NEEDED
	BEQ	MSR4
	BCC	MSR50		;POSSIBLE RIGHT NEEDED IF X BIGGER THAN LEFT
	CMP	#XSCROLLSPEED	;SEE IF TRYING TO MOVE TOO FAST
	BCC	MSR10
	LDA	#XSCROLLSPEED
MSR10:	STA	SUBSVAR4	;SAVE AMOUNT WE WANT HERE BUT WE NEED NEGATE

	LDA	XBACK
	STA	TESTCOL
	LDA	XBACK+1						    
	STA	TESTCOL+1	;NEED TO MAKE COLUMN OF REAL LEFT OF SCREEN
	LSR	TESTCOL+1
	ROR	TESTCOL
	LSR	TESTCOL+1
	ROR	TESTCOL
	LSR	TESTCOL+1
	ROR	TESTCOL

	LDA	TESTCOL+1	;SEE IF NEAR LEFT
	BNE	MSR15
	LDA	STARTCOL
	CMP	#2
	BCS	MSR15
	
	LDA	XBACK
	CMP	SUBSVAR4	;MAKE SURE THERE'S ENOUGH LEFT IF NEAR LEFT
	BCS	MSR15		
	STA	SUBSVAR4	;IF NOT, USE WHAT'S LEFT

MSR15:	JSR	SEEKCMD2	;OR SAME IF LEFT LIMIT COMMAND
	CMP	#$F3		;CONDITIONAL LEFT LIMIT?
	BNE	MSR17
      	JSR	MUSTKILL	;SEE IF ANY MUST KILL IF CONDITIONAL STOP SCRL
	BEQ	MSR40
	JMP	MSR20
MSR17:	CMP	#$F1		;LEFT LIMIT?
	BNE	MSR40
MSR20:	LDA	XBACK		;IF ON COMMAND, GET ODD PIXELS OF SCROLL
	AND	#7		;MAKE MAX WE CAN DO
	BEQ	MSR100		;IF NONE LEFT, NO ACTION NEEDED.
	STA	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANTED TOO MUCH
	BCC	MSR40
	LDA	SUBSVAR6
	STA	SUBSVAR4
MSR40:	LDA	SUBSVAR4
	STA	SUBSVAR3
MSR45:	JMP	MSR100

;SEE IF WE WANT TO SCROLL RIGHT

MSR50: 	LDA	ENEMYCENTR,X
	SEC
	SBC	#RIGHTSCROLL	;MAKE RIGHT SCREEN SCROLL
	BEQ	MSR100
	BCC	MSR100		;SKIP IF NONE OR NEGATIVE
	CMP	#XSCROLLSPEED	;DON'T GO FASTER THAN THE MAX ALLOWED
	BCC	MSR55
	LDA	#XSCROLLSPEED
MSR55:	STA	SUBSVAR4		;SAVE IT HERE FOR A BIT
	JSR	GET_RIGHT	;GET MAX WE ARE ALLOWED TO DO IT
	STX	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANT TOO MUCH
	BCC	MSR60	
	LDA	SUBSVAR6
MSR60:	JSR	NEGATE		;NEED TO REVERSE FOR ENTITIES.
	STA	SUBSVAR3		;SET RIGHT SCROLL REQUEST	

MSR100:	LDA	SUBSVAR3		;RETURN RESULT
	RTS	

;THIS SUB WILL MAKE THE SCROLL REQUEST FOR ENTITY X AND RETURN IT IN
;A.  IT CHECKS FOR ENEMY NOT VALID AND ALSO FOR SCREEN LIMIT STOPS.
;THE VALUE IS ALSO RETURNED IN SUBSVAR3.  THIS ROUTINE CHANGES TESTCOL.

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `

MAKEYSCROLL:
	LDA	#0
	STA	SUBSVAR3	;ZERO RESULT
	CPX	#-1		;INVALID ENEMY NUMBER?
	BEQ	MSY45
	LDA	ENEMY0,X	;SEE IF THIS ENEMY IS VALID
	CMP	#-1
	BEQ	MSY100

;SEE IF WE WANT TO SCROLL UP

 	LDA	#TOPSCROLL
	SEC
	SBC	ENEMYFEET,X	;SEE IF POSITIVE UP SCROLL (-) NEEDED
	BEQ	MSY100
	BCC	MSY50		;POSSIBLE RIGHT NEEDED IF X BIGGER THAN LEFT
	CMP	#YSCROLLSPEED	;SEE IF TRYING TO MOVE TOO FAST
	BCC	MSY10
	LDA	#YSCROLLSPEED
MSY10:	STA	SUBSVAR4	;SAVE AMOUNT WE WANT HERE BUT WE NEED NEGATE
	LDA	STARTROW	;SEE IF AT TOP OF SCREEN
	BNE	MSY40
	LDA	YBACK		;GET ODD PIXELS OF SCROLL
	AND	#7		;MAKE MAX WE CAN DO
	BEQ	MSY100		;IF NONE LEFT, NO ACTION NEEDED.
	STA	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANTED TOO MUCH
	BCC	MSY40
	LDA	SUBSVAR6
	STA	SUBSVAR4
MSY40:	LDA	SUBSVAR4
	STA	SUBSVAR3
MSY45:	JMP	MSY100

;SEE IF WE WANT TO SCROLL DOWN

MSY50: 	LDA	ENEMYFEET,X
	SEC
	SBC	#BOTSCROLL	;MAKE DOWN SCREEN SCROLL
	BEQ	MSY100
	BCC	MSY100		;SKIP IF NONE OR NEGATIVE
	CMP	#YSCROLLSPEED	;DONT GO FASTER THAN THE MAX ALLOWED
	BCC	MSY55
	LDA	#YSCROLLSPEED
MSY55:	STA	SUBSVAR4		;SAVE IT HERE FOR A BIT
	JSR	GET_BOT			;GET MAX WE ARE ALLOWED TO DO IT
	STX	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANT TOO MUCH
	BCC	MSY60	
	LDA	SUBSVAR6
MSY60:	JSR	NEGATE		;NEED TO REVERSE FOR ENTITIES.
	STA	SUBSVAR3		;SET RIGHT SCROLL REQUEST	

MSY100:	LDA	SUBSVAR3		;RETURN RESULT
	RTS	

.endif ;' )

;THIS ROUTINE WILL APPLY GLOBAL SCROLL TO AN ENEMY.  THE ENEMY INDEX SHOULD 
;BE IN X ON ENTRY.  IT WILL BE RETURNED THERE.  DON'T CALL
;IF GLOBAL_XSCR AND GLOBAL_YSCR ARE BOTH ZERO.  X MAY BE CHANGED ON RETURN

SCROLLENEMY:
	JSR	XINVALID	;SEE IF ENTITY IS VALID
	BEQ	SE00
	JSR	HIDDEN		;SEE IF HIDDEN ENEMY
	BNE	SE00
	JSR	MAKENEWX	;MAKE THE NEW X LOCATION
	BNE	SE00A		;SKIP IF HE'S STILL ON SCREEN
SE00B:	JMP	ENEMYG2		;IF HE'S OFF SCREEN, HIDE HIM.
SE00A:	STA	ENEMYX,X	;IF STILL ON SCREEN, SET NEW LOCATION
	LDA	ENEMYSTAT,X	;BUT IF ASLEEP, DON'T CHANGE CENTER LOCATION
	BMI	SE00		;OR Y EITHER.
	JSR	FINDCENTR	;AND CALCULATE CENTER LOCATION TOO

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `
	JSR	MAKENEWY	;MAKE THE NEW Y LOCATION
	BEQ	SE00B		;SKIP IF HES NOT ON SCREEN
	STA	ENEMYY,X	;IF STILL ON SCREEN, SET NEW LOCATION
	JSR	FINDFEET	;MAKE JUST NEW FEET LOCATION
.endif ;' )
SE00:	RTS	

XINVALID:			;THIS ROUTINE CHECKS ENEMY0,X FOR -1.  
	LDA	ENEMY0,X	;IT RETURNS Z IF INVALID.
	CMP	#-1		;INVALID?
     	RTS

HIDDEN:				;SEE IF ENTITY IS HIDDEN FOR A STATREQUEST.
				;RETURNS NZ FOR ENTITY X.
	LDA	ENEMYJSTAT,X	;SEE IF HIDDEN FROM SOME WORLD
	AND	#$20
	RTS

;THIS SUB WILL RETURN THE NEW X LOCATION OF AN ENTITY WHICH NEEDS
;TO BE SCROLLED.  (MAKE SURE ITS VALID
;BEFORE CALLING).  X SHOULD HAVE THE ENTITY INDEX.  ON RETURN, IF NZ
;THEN A HAS THE NEW LOCATION.  IF Z THEN IT SCROLLED OFF SCREEN.

;SLEEPING ENTITIES ARE ALLOWED TO REMAIN SO LONG AS THEIR LAUNCH COLUMN
;IS STILL IN THE SCREEN'S TESTING RANGE.

MAKENEWX:
	LDA	ENEMYSTAT,X
	BMI	SE20		;BIT $80 MEANS ASLEEP.  DIFFERENT LOGIC
	LDA	ENEMYCTRL,X	;GET THE FLAGS FOR HIM
	AND	#$03
	CMP	#$03		;NO SCROLLING AT ALL?
	BEQ	SE10
	TAY			;PUT IT HERE
	LDA	GLOBAL_XSCR	;GET THE SCROLL
	BEQ	SE10
	CPY	#0
	BEQ	SE25
	LDA	HALF_XSCR	;IF NOT FULL, USE 1/2 
	CPY	#$01
	BEQ	SE25
	LDA	QUAR_XSCR	;ITS 1/4 SCROLL.
SE25:	CLC
	ORA	#0		;TEST SIGN OF A
	BPL	SE02
	ADC	ENEMYX,X
	BCS	SE03
	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BEQ	SE04
	LDA	#0
	JMP	SE03		;IF SO, PUT AGAINST LEFT

SE02:	ADC	ENEMYX,X
	BCC	SE03		

	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BNE	SE05		;IF SO, PUT AGAINST SCREEN RIGHT

SE04:  	LDY	#0		;RETURN Z, HE WENT OFF SCREEN
	RTS

SE05:	LDA	#$FF		;IF SO, PUT AGAINST RIGHT
SE03:	LDY	#-1		;RETURN NZ, WE HAVE A LOCATION
	RTS

;NON-SCROLLER OR NO SCROLL TO USE.  RETURN THE CURRENT X.

SE10: 	LDA	ENEMYX,X
	LDY	#-1		;RETURN NZ
	RTS

;THIS ENTITY IS ASLEEP.  WE JUST NEED TO SEE IF HIS ORIGIN COLUMN
;IS STILL WITHIN THE TESTING RANGE.  ONCE ITS OUTSIDE, WE SHOULD REMOVE
;HIM BECAUSE WE CAN SCROLL BACK ONTO IT AND TEST IT AGAIN.

SE20:	LDA	ENEMYLCOL,X
	SEC
	SBC	STARTCOL	;SEE IF THE LAUNCH COLUMN IS TO THE LEFT
	TAY
	LDA	ENEMYHCOL,X
	SBC	STARTCOL+1
	BCC	SE04		;IF TO LEFT OF 0, HE'S OFF SCREEN
	TYA
	CMP	#32		;IS IT PAST THE RIGHTMOST SCREEN COLUMN?
	BCS	SE04
	LDY	#-1		;IF NOT, RETURN THAT WE HAVE A LOCATION
	RTS		

;THIS SUB WILL RETURN THE NEW Y LOCATION OF AN ENTITY WHO NEEDS TO BE
;SCROLLED.  (MAKE SURE ITS VALID
;BEFORE CALLING).  X SHOULD HAVE THE ENTITY INDEX.  ON RETURN, IF NZ
;THEN A HAS THE NEW LOCATION.  IF Z THEN IT SCROLLED OFF SCREEN.
;Y SCROLLING WILL NOT REMOVE AN ENTITY THAT IS ASLEEP WAITING TO COME
;ONTO SCREEN.

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `
MAKENEWY:
	LDA	ENEMYCTRL,X	;GET THE FLAGS FOR HIM
	AND	#12
	CMP	#12		;NO SCROLLING AT ALL?
	BEQ	SEY10
	TAY			;PUT IT HERE
	LDA	GLOBAL_YSCR	;GET THE SCROLL
	BEQ	SEY10
	CPY	#0
	BEQ	SEY25
	LDA	HALF_YSCR	;IF NOT FULL, USE 1/2 
	CPY	#4
	BEQ	SEY25
	LDA	QUAR_YSCR	;ITS 1/4 SCROLL.
SEY25:	CLC
	ORA	#0		;TEST SIGN OF A
	BPL	SEY02
	ADC	ENEMYY,X
	BCS	SEY03
	LDA	ENEMYSTAT,X
	BMI	SEY03		;BIT H80 MEANS ASLEEP.   NO REMOVAL ON Y.
	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BEQ	SEY04
	LDA	#0
	JMP	SEY03		;IF SO, PUT AGAINST LEFT

SEY02:	ADC	ENEMYY,X
	BCC	SEY03		

	LDA	ENEMYSTAT,X
	BMI	SEY03		;BIT H80 MEANS ASLEEP.  NO REMOVAL ON Y AXIS.
	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BNE	SEY05		;IF SO, PUT AGAINST SCREEN BOTTOM
SEY04: 	LDY	#0		;RETURN Z, HE WENT OFF SCREEN
	RTS

SEY05:	LDA	#247		;IF SO, PUT AGAINST BOTTOM
SEY03:	LDY	#-1		;RETURN NZ, WE HAVE A LOCATION
	RTS

;NON-SCROLLER OR NO VALUE TO SCROLL.  RETURN THE CURRENT Y.

SEY10: 	LDA	ENEMYY,X
	LDY	#-1		;RETURN NZ
	RTS
.endif ;' )

;THIS ROUTINE WILL RETURN AN AMOUNT IN X IN PIXELS THAT IT IS OK TO SCROLL
;RIGHT WITHIN THE CURRENT BACKGROUND.  IT ALSO CHECKS FOR HITTING A RIGHT
;SCROLL LIMIT.  IF THE AMOUNT IS OVER 255, 255 IS RETURNED.

GET_RIGHT:
	LDA	STARTCOL
	CLC
	ADC	#31
	STA	TESTCOL
	LDA	STARTCOL+1
	ADC	#0
	STA	TESTCOL+1
	JSR	SEEKCMD2
	CMP	#$F4		;CONDITIONAL RIGHT LIMIT?
	BNE	GR9
      	JSR	MUSTKILL	;SEE IF ANY MUST KILL IF CONDITIONAL STOP SCRL
	BNE	GR8
	JMP	GR10
GR9:	CMP	#$F2		;RIGHT LIMIT COMMAND?
	BNE	GR10		;IF NOT, ITS OK TO SCROLL	
GR8:	LDX	#0
	RTS	

GR10:	LDA	RIGHTLIMIT
	SEC
	SBC	XBACK
	TAX			;ASSUME LOW BYTE IS AMOUNT LEFT
	LDA	RIGHTLIMIT+1
	SBC	XBACK+1		;MAKE AMOUNT WE CAN STILL SCROLL, 2 BYTES
	BEQ	GR20
	LDX	#255		;IF HIGH BYTES NON-ZERO, SET MAX AS SCROLLABLE
GR20:	RTS

;THIS ROUTINE WILL RETURN AN AMOUNT IN X IN PIXELS THAT IT IS OK TO SCROLL
;DOWN WITHIN THE CURRENT BACKGROUND.  
;IF THE AMOUNT IS OVER 255, 255 IS RETURNED.

.ifdef BLOCKMODE;IFDEF( `BLOCKMODE', `
GET_BOT:
	LDA	BOTLIMIT
	SEC
	SBC	YBACK
	TAX			;ASSUME LOW BYTE IS AMOUNT LEFT
	LDA	BOTLIMIT+1
	SBC	YBACK+1		;MAKE AMOUNT WE CAN STILL SCROLL, 2 BYTES
	BEQ	GBR20
	LDX	#255		;IF HIGH BYTES NON-ZERO, SET MAX AS SCROLLABLE
GBR20:	RTS
.endif ;' )

;THIS ROUTINE WILL TAKE THE DATA SET UP BY THE SHOWSCORE ROUTINE AND
;CONVERT THE APPROPRIATE SCORE INTO DATA IN NUMBUF.  IT SETS STATLEN
;TO THE LENGTH OF THAT DATA AND IT SUPPRESSES LEADING ZEROS.

CONVSCORE:
	LDY	STATDATA	;GET INDEX TO USE
	LDA	SCOREL,Y
	STA	SUBSVAR3
	LDA	SCOREH,Y
	STA	SUBSVAR4	;NOW WE HAVE THE SCORE TO USE 

;CALL HERE TO TAKE THE 1 WORD MAX NUMBER IN SUBSVAR3 AND 4 AND
;CONVERT INTO BASE 10 WITH RESULT IN NUMBUF AND LENGTH IN 
;STATLEN.  5 WILL BE LENGTH ALWAYS.   IT DOES LEADING ZERO SUPPRESSION.
;IT USES BASENUM (FROM KUNGTAB) TO MAKE THE RESULT INTO ASCII NUMBERS
;FROM THE VIDEO CHARACTER SET.  ON RETURN:
;
;THE NUMERIC DATA IS IN NUMBUF, LEADING ZEROS SUPPRESSED
;STATDATA POINTS TO THE DATA IN THE BUFFER (NOT NECESSARILY AT THE START)
;STATLEN HAS THE LENGTH OF THE DATA.

CONVWORD:
	LDA	#5
	STA	STATLEN		;SET MAX LENGTH POSSIBLE
	JMP	CSO0

CONVBYTE:			;CALL HERE TO DISPLAY 3 DIGITS MAX
	LDA	#3
	STA	STATLEN

CSO0:	LDA	#NUMBUF & $FF
	STA	STATDATA
	LDA	#NUMBUF >> 8
	STA	STATDATA+1	;SET POINTER TO THE DATA
	LDA	#0		;SET PLACE TO WRITE TO IN VIDEO BUFFER
	STA	NUMBUF		;AND ZERO TOP DIGIT
CSO5:	SEC
	LDA	SUBSVAR3
	SBC	#$10
	STA	SUBSVAR5
	LDA	SUBSVAR4
	SBC	#$27		;SUBTRACT 10,000 FROM THE SCORE
	BCC	CSO10
	STA	SUBSVAR4
	LDA	SUBSVAR5
	STA	SUBSVAR3	;PUT IT BACK IF IT WORKED
	INC	NUMBUF		;INCREMENT THE 10,000s
	JMP	CSO5
CSO10:	LDX	SUBSVAR3
	LDY	SUBSVAR4	;GET THE RESULTING NUMBER
	LDA	#100
	JSR	DIVIDE		;MAKE A 0-55 100s
	STX	SUBSVAR3
	STY	SUBSVAR4	;REMAINDER UNDER 100 IN HERE
	LDX	SUBSVAR3	
	LDY	#0
	LDA	#10
	JSR	DIVIDE		;MAKE NUMBER OF 1000s
	STX	NUMBUF+1	;SAVE 1000s
	STY	NUMBUF+2	;SAVE 100s
	LDX	SUBSVAR4
	LDY	#0
	LDA	#10
	JSR	DIVIDE		;MAKE 10s AND 1s
	STX	NUMBUF+3
	STY	NUMBUF+4	;NOW WE HAVE ALL DIGITS
	LDX	#0		;MAKE A SUPPRESSION FLAG
	LDY	#0		;MAKE AN INDEX
CSO20:	LDA	NUMBUF,Y	;GET A DIGIT
	BNE	CSO30
	CPX	#0		;FOUND ONE YET?
	BNE	CSO30
	CPY	#4		;BUT IS IT THE LAST DIGIT?
	BEQ	CSO30
	LDA	#$41		;ROGER CHANGED THIS 
	JMP	CSO32	
CSO30:	INX			;SET FLAG OF FOUND NON-ZERO DIGIT
	CLC
	ADC	#BASENUM	;CORRECT THE DIGIT
CSO32:	STA	NUMBUF,Y
	INY
	CPY	#5		;DID ALL DIGITS?
	BNE	CSO20

	LDA	STATLEN		;SEE IF WORD OR BYTE
	CMP	#5
	BEQ	CSO40
      	LDA	STATDATA
	CLC
	ADC	#2
	STA	STATDATA
	LDA	STATDATA+1
	ADC	#0
	STA	STATDATA+1	;IF JUST 3 DIGITS, MOVE POINTER ALONG
CSO40:	RTS	

	
;***********************JOYSTICK ROUTINES.************************
;******* THEY ALSO HAPPEN INSIDE THE VERTICAL RETRACE INTERRUPT *****

A1:				;A BUTTON CHANGE ROUTINES.  A IS JUMP.
	LDA	#0		;A+START IS CONTINUE.
	JMP	A10	;SET FOR JOYSTICK 0

A2:	LDA	#1
A10:	STA	JOYINDX
	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.

;A MEANS JUMP

A250: 	LDX	JOYINDX		;GET THE JOYSTICK INDEX
	LDA	JOYENEMY,X	;SEE WHAT ENTITY TO EFFECT
	CMP	#-1
	BEQ	A253		;SKIP IF NO ENEMY ATTACHED TO THIS JOYSTICK
	TAY
	LDA	#JUMPING
	AND	ENEMYINTS,Y
	BNE	A253
	LDA	#EJUMP
	STA	ENEMYREQ,Y
A253:	RTS

;THIS SUBROUTINE WILL TWICE POP THE STACK AND RETURN IF WORLD_REQUEST OR
;BPAUSE ARE TRUE.  THIS STOPS US FROM DOING SOMETHING WHILE  PAUSED OR
;IN PROCESS OF REBOOTING.

NOTPAUSED:
	LDA	WORLD_REQUEST	;MAKE SURE NO REQUEST IN PROGRESS
	ORA	BPAUSE		;AND MAKE SURE NOT PAUSED.
	BEQ	NCH10
	PLA
	PLA			;THROW OUT A RETURN ADDRESS
NCH10:	RTS

;IF A+B+UP ARE ALL PRESSED (BUT NO OTHERS) THEN WE ENABLE 
;THE SELECT WORLD MODE.   IF JUST B, WE CALL ATTACK.

B1:	LDA	#0	;B BUTTON CHANGE ROUTINES
	JMP	B210
B2:	LDA	#1

B210:	STA	JOYINDX		;SET INDEX ACCORDING TO JOYSTICK

	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.

	LDA	J1FLAGS
	CMP	#%11001000	;A+B+UP?
	BNE	B110
	LDA	J2FLAGS
	CMP	#%00001000	;B MUST BE UP TOO
	BNE	B110

	JSR	NOTBOOT		;MAKE SURE NOT BOOT WORLD
	LDA	#-1
	STA	ENABLE_SELECT	;IF SO, SET ENABLE SELECT WORLD MODE
B105:	RTS

;ITS ATTACK.

B110:	LDA	J1FLAGS
	ORA	J2FLAGS
	AND	#$30		;MAKE SURE START OR SELECT ARE NOT DOWN
	BNE	B111

 	LDX	JOYINDX		;GET THE JOYSTICK INDEX
	LDA	JOYENEMY,X	;SEE WHAT ENTITY TO EFFECT
	CMP	#-1
	BEQ	B111		;SKIP IF NO ENEMY ATTACHED TO THIS JOYSTICK
	TAY
	LDA	#ATTACKING
	AND	ENEMYINTS,Y
	BNE	B111	
	LDA	#EATTACK
	STA	ENEMYREQ,Y
B111:	RTS

SEL1:			;SEL BUTTON CHANGE ROUTINES
 	LDA	#0	;SET INDEX
	JMP	SEL10
SEL2:	LDA	#1	;SEL+B BRINGS NEXT WORLD IF ENABLED.
SEL10:	STA	JOYINDX

	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.

	LDA	ENABLE_SELECT
	BEQ	SEL30

	JSR	NOTBOOT		;MAKE SURE NOT BOOT WORLD
	LDA	J1FLAGS		;BUT B MUST BE DOWN TOO WITH THE SELECT
	CMP	#%01100000	;B+SELECT?
	BNE	SEL30

;ITS SELECT WORLD MODE.  GET THE NEXT WORLD.

SEL3:	LDA	CURWORLD
	TAY
	INY
	CPY	#MAX_WORLD
	BCC	SEL7
	LDY	#1
SEL7:	STY	WORLD_REQUEST	;SET REQUEST FOR THIS NEW WORLD
	LDA	#-1
	STA	SILENCEIT
	STA	CHEATMODE	;FLAG ITS A CHEAT MODE ENTERED WORLD
SEL20:	RTS

;SELECT WAS PRESSED WITHOUT B OR SELECT MODE IS NOT ENABLED.  SEE IF
;WE ARE GENERATING AN INTERRUPT.

SEL30: 	LDX	JOYINDX		;GET THE JOYSTICK INDEX
	LDA	JOYENEMY,X	;SEE WHAT ENTITY TO EFFECT
	BMI	SEL20
	TAY

	LDA	#SELECTING
	AND	ENEMYINTS,Y
	BNE	SEL20		;MAKE SURE NOT DISABLED

	LDA	SELKEY,X	;SEE IF WE HAVE AN INTERRUPT FOR SELECT
	CMP	#-1
	BEQ	SEL20	
	STA	ENEMYREQ,Y	;IF SO, REQUEST IT
	RTS

;START BUTTON ROUTINE.  IF THE GAME IS PLAYING, WE PAUSE.  

STRT1:		
STRT2:	LDA	WORLD_REQUEST	;MAKE SURE NO REQUEST IN PROGRESS
	BNE	SEL20
	LDA	CURWORLD	;AND MAKE SURE NOT BOOT WORLD
	BEQ	SEL20

	LDA	PAUSEFLG	;AND MAKE SURE PAUSE IS ENABLED
	BEQ	SEL20

;WE NEED TO PAUSE OR UNPAUSE.

	LDA	#0	;ASSUME UNPAUSE
	LDX	BPAUSE	;SEE IF WE ARE ALREADY PAUSING
	BNE	STR10
	LDA	#0
	STA	$4015	;IF PAUSE, RESET SOUNDS
	LDA	REG4015
	STA	$4015
	LDA	#-1
STR10:	STA	BPAUSE
	RTS

DOWN1:	LDY	#0	;DOWN BUTTON CHANGE ROUTINES
	JMP	DON10
DOWN2:	LDY	#1
DON10:	LDA	#6		;POINT TO DOWN MOMENTUMS
	LDX	#2		;USE FLAG TO SIGNAL DOWN 
	JMP	UP210

LEFT1:	LDY	#0		;LEFT BUTTON CHANGE ROUTINES
	JMP	LEF10
LEFT2:	LDY	#1
LEF10:	LDA	JOYENEMY,Y	;GET ENEMY ATTACKED TO IT
	BMI	LEF15
      	TAX			;IF ENEMY, NEED TO SET LEFT BIT
	LDA	ENEMYJSTAT,X
	ORA	#$10
	STA	ENEMYJSTAT,X	;CAUSE WE'RE UNDER INTS WE MIGHT LOOSE THIS
				;BUT ITS NOT FATAL.
LEF15:	LDA	#0		;POINT TO THE LEFT MOMENTUMS IN DEFMOMS
	LDX	#0
	JMP	UP210

RIGHT1:	LDY	#0		;RIGHT BUTTON CHANGE ROUTINES
	JMP	RIT5
RIGHT2:	LDY	#1
RIT5: 	LDA	JOYENEMY,Y	;GET ENEMY ATTACKED TO IT
	BMI	RIT10
      	TAX			;IF ENEMY, NEED TO SET LEFT BIT
	LDA	ENEMYJSTAT,X
	AND	#$EF
	STA	ENEMYJSTAT,X	;CAUSE WE'RE UNDER INTS WE MIGHT LOOSE THIS
				;BUT ITS NOT FATAL.
RIT10:	LDA	#2		;POINT TO THE RIGHT MOMENTUMS IN DEFMOMS
	LDX	#0
	JMP	UP210

UP1:	LDY	#0		;UP BUTTON CHANGE ROUTINES
	JMP	UPY10
UP2:  	LDY	#1
UPY10:	LDA	#4		;SET UP FOR SHARED CODE. POINT TO UP MOMS.
	LDX	#1		;FLAG TO SIGNAL UP

UP210:	STA	MOMINDX		;SAVE MOMENTUM INDEX
	STY	JOYINDX		;SAVE JOYSTICK INDEX
	STX	NEWCOL		;SAVE FLAG OF NEED NEW COLUMN TEST

	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.
	JSR	NOTBOOT		;MAKE SURE NOT BOOT WORLD
	JSR	NOTINST		;MAKE SURE NOT INSTRUCTIONS WORLD

;UPDATE X MOMENTUM

	LDY	MOMINDX		;GET MOMENTUM INDEX
	LDX	JOYINDX		;GET JOYSTICK INDEX
	LDA	JOYX,X		;GET X JOYSTICK MOMENTUM
	CLC
	ADC	DEFMOMS,Y 	;GET X MOMENTUM VALUE TO USE
	BVS	UP211		;DON'T UPDATE IF SIGNED OVERFLOW
	STA	JOYX,X

;NOW UPDATE Y MOMENTUM.  

UP211:	LDA	JOYY,X
	CLC
	ADC	DEFMOMS+1,Y
	BVS	UP212
	STA	JOYY,X		;UPDATE ACCORDING TO MOMENTUM TABLE

;NOW SEE IF AN ENTITY IS ATTACKED TO IT AND WE NEED TO MAKE HIM TEST
;A COLUMN AGAIN.

UP212:	LDA	NEWCOL		;SEE IF NEW COLUMN FLAG SET CAUSE UP OR DOWN
	BEQ	UP220
      	LDA	JOYENEMY,X	;GET ENEMY ATTACKED TO IT
	BMI	UP220
	TAX
	LDA	#-1
	STA	ENEMYLROW,X	;SET LAST ROW AS 255 TO FORCE TEST

	LDA	NEWCOL
	CMP	#2		;SEE IF DOWN KEY
	BNE	UP220
	LDA	#DUCKING
	AND	ENEMYINTS,X	;MAKE SURE ITS ENABLED
	BNE	UP220
	LDA	#EDUCK		;IF DOWN ON SOLID, REQUEST DUCK MODE
	STA	ENEMYREQ,X	
UP220:	RTS

;THIS ROUTINE MAKES A DING SOUND USING A SLOT THAT IS NOT USED FOR
;ANYTHING ELSE.

MAKEDING:				
	LDA	#DINGSLOT
	JSR	SILENCE
	LDX	#PNOISE & $FF
	LDY	#PNOISE >> 8
	LDA	#DINGSLOT
	JSR	PLAY
	RTS

;THIS ROUTINE WILL POP A RETURN ADDRESS AND RETURN IF WE ARE IN THE BOOT
;WORLD (WORLD 0).  IT CAN BE USED TO SKIP A SUB IF ITS THE BOOT WORLD.

NOTBOOT:
	LDA	CURWORLD
	BEQ	NTBT10
	RTS

;THIS ROUTINE WILL POP A RETURN ADDRESS AND RETURN IF WE ARE IN AN INSTRUCTIONS
;WORLD.  IT CAN BE USED TO SKIP A SUB IF ITS NOT A REAL WORLD.

NOTINST:
	LDA	CURWORLD
	BPL	NTBT15
NTBT10:	PLA
	PLA
NTBT15:	RTS

	;.END

;THIS END OF ASSEMBLY CODE WILL NOT INTERFERE WITH YOUR PROGRAM ORG WHICH
;COMES IMMEDIATLY AFTERWORDS.  IT IS HERE SO THAT YOU DON'T LOOSE TRACK
;OF IT AT THE BOTTOM OF YOUR ASSEMBLY.

;IFDEF( `BLOCKMODE', `
;.ORG	64928 	;(FDA0H)
;	', ` 
;.ORG	64992	;(FDE0H)
;	.endif ;' )

;THIS TABLE HAS THE LENGTH OF BYTES THAT EACH COMMAND TAKES.  WE USE
;THIS TO FETCH DATA AND INCREMENT THE POINTER PRIOR TO THE COMMAND.
;THE LENGTH HERE IS THE LENGTH INCLUDING THE COMMAND BYTE ITSELF.

CMDLEN:
	.byte	2,5,4,4,3,4,3,2,3,2,2,3,3,2,2,2		;CMD00
	.byte	2,1,1,1,1,4,3,1,1,1,2,4,3,3,2,5		;CMD10
	.byte	3,1,4,4,4,5,1,3,4,2,4,4,2,3,1,2		;CMD20
	.byte	2,9,2,1,1,6,5,4,4,6,3,3,5,3,3,2		;CMD30
	.byte	3,5,3,2,1,4,2,2,2,3,2,4,2,3,3,2		;CMD40
	.byte	3,4,4,5,3,2,2,3,4,3,2,2,2,2,2,4		;CMD50 
	.byte	4,5,4,3,2,3,4,6,1,5,2,3,3,5,7,6		;CMD60
	.byte	10,2,2,2,5,4,2,7,3,1,2,5,2,3,1,7	;CMD70
	.byte	3,3,5,3,2,2,2,2,2,3,2,3,1,2,2,1		;CMD80
 	.byte	3,3,4,4,4,1,3,2,2,1,3,3,2,2,5,5		;CMD90
 	.byte	5,2,1,5,2,1,3,1,1,3,1,1,1,1,1,1		;CMDA0

;THIS CODE IS USED TO FILL THE COMMAND BUFFER FROM THE COMMAND STREAM
;OR TO GET DATA FROM ONE OF THE COMMANDS.  ITS CALLED SINGLE THREADLY 
;BY MOVEENEMY IN KUNGFU.ASM OUTSIDE NMI.  THE DATA IS POINTED TO BY (ENEMYPTR) 
;EXCEPT THAT THE HIGH BIT IS NOT SET IF THE DATA IS IN THE SECOND PAGE.  
;CALL HERE WITH (ENEMYPTR) POINTING TO THE COMMAND BYTE OR DATA.  SET
;X=0 IF YOU ARE FETCHING A COMMAND (IT WILL DETERMINE HOW MUCH DATA)
;AND X<>0 TO FETCH JUST DATA FOR LENGTH X (16 MAX!). SUBSVAR1 RETURNS 
;THE LENGTH OF DATA WE GOT WHICH WILL ALWAYS BE X IF X<>0.

FILLCBUF:
	LDA	ENEMYPTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA			;SAVE IT
	BMI	FCB15
	ORA	#128
	STA	ENEMYPTR+1	;IN EITHER CASE, MAKE IT BE IN ROM
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
FCB15:	LDY	#0	
	CPX	#0
	BNE	FCB17
	LDA	(ENEMYPTR),Y
	TAX			;GET THE COMMAND BYTE
	LDA	CMDLEN,X	;GET THE COUNT FOR THIS COMMAND
	TAX
FCB17:	STX	SUBSVAR1	;RETURN THE COUNT BYTE
FCB20:	LDA	(ENEMYPTR),Y
	STA	CMDBUF,Y	;FETCH LENGTH REQUESTED
	INY
	DEX
	BNE	FCB20
	PLA
	BMI	FCB30
	STA	ENEMYPTR+1	;RESTORE ORIGINAL BANK SPECIFICATION
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
FCB30:	RTS	

;THIS SUB IS USED TO FETCH DATA FROM EITHER PAGE INTO THE STACK AREA.
;YOU WILL LOWER YOUR STACK POINTER FAR ENOUGH DOWN TO HOLD THE DATA
;AND THEN WHEN DONE MOVE IT BACK UP AND THUS THIS ROUTINE IS GOOD FROM
;BOTH INSIDE AND OUTSIDE NMI.
;
;ON ENTRY, (SUBSVAR1) SHOULD POINT TO THE DATA TO FETCH.  BIT H80 IS SET 
;IF ITS IN THE LOW PAGE, NOT SET IF IN THE HIGH.  LOAD SUBSVAR3 WITH THE COUNT 
;TO FETCH.  ON RETURN, YOUR DATA IS AT (SP)+1.  NO OTHER VARIABLES ARE CHANGED.

FILLSTACK:
	TSX
	INX
	INX
	INX			;GET PLACE TO PUT THE DATA
	LDA	SUBSVAR2	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	FSK10
	ORA	#128
	STA	SUBSVAR2
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
FSK10:	LDY	#0	
FSK20:	LDA	(SUBSVAR1),Y
	STA	256,X			
	INY
	INX
	DEC	SUBSVAR3
	BNE	FSK20
	PLA
	BMI	FSK25
	STA	SUBSVAR2
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
FSK25:	RTS	

;THIS SUB IS USED TO FETCH COLUMN DATA FROM A BACKGROUND BLOCK DIRECTLY
;INTO SCNBUF.  ON ENTRY:
;(NMI_PTR) POINTS TO THE FIRST BYTE TO FETCH.  BIT 8000H SET IF LOW PAGE,
;  	OFF IF HIGH PAGE (THAT BIT IS PRESERVED ON RETURN).
;TMP_NMI1 HAS THE COUNT TO FETCH.  
;X HAS THE PLACE TO PUT IT INTO SCNBUF. 
;TMP_NMI2 HAS THE WIDTH OF THE BACKGROUND IN COLUMNS (THE AMOUNT
;	TO SKIP AFTER EACH FETCH).  
;
;ON RETURN:  THE DATA IS IN SCNBUF, X IS UPDATED AND SO IS NMI_PTR.

LOADCOL:

	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	LDC15
	ORA	#128
	STA	NMI_PTR+1
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
LDC15:	CLC
	LDY	#0
LDC20:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCNBUF,X	;QUE IT UP
	INX
	LDA	NMI_PTR
	ADC	TMP_NMI2	;SKIP TO NEXT ROW IN DATA
	STA	NMI_PTR
	BCC	LDC30
	INC	NMI_PTR+1
	CLC
LDC30:	DEC	TMP_NMI1
	BNE	LDC20

LDC35:	PLA
	BMI	LDC40
	LDA	NMI_PTR+1
	EOR	#128
	STA	NMI_PTR+1
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
LDC40:	RTS	

;THIS ROUTINE IS USED TO WRITE PALETTE DATA INTO A SCREEN BUFFER IN
;COLUMN FORMAT.  IT DIFFERS DEPENDING ON BLOCK OR STRIP MODE.

;IN STRIP MODE, EACH PALETTE BYTE MUST BE INDIVIDUALLY
;ADDRESSED.  THIS ROUTINE WILL DO THAT WHILE FETCHING AND STORING DIRECTLY
;INTO SCNBUF.  ON ENTRY:
;TMP_NMI4:TMP_NMI3 POINTS TO THE PLACE TO PUT THE DATA IN THE VIDEO BUFFER.
;(NMI_PTR) POINTS TO THE PALETTE BYTE TO PUT THERE.
;TMP_NMI1 HAS THE COUNT OF PALETTE BYTES TO PUT THERE.
;TMP_NMI2 HAS THE WIDTH OF THE BACKGROUND'S PALETTE ARRAY.
;X HAS PLACE IN SCNBUF TO PUT THE DATA.

;IN BLOCK MODE THE DATA MUST BE SHIFTED BEFORE ADDRESSING AND THIS ROUTINE
;SIMPLY FETCHES IT INTO THE LOCATION YOU SPECIFY IN MEMORY.  IT FETCHES
;1 OR 2 BYTES EACH CALL SINCE THE BACKGROUNDS ARE ONLY 2 PALETTE BYTES
;HIGH.  ON ENTRY:
;(NMI_PTR) POINTS TO THE PALETTE BYTE TO GET FIRST
;TMP_NMI1 HAS THE COUNT OF PALETTE BYTES TO GET, 1 OR 2.  
;X HAS THE PLACE IN A 9 BYTE BUFFER STARTING AT TMP_NMI6 AT WHICH TO PUT
; THE DATA.  X IS UPDATED.

LOADPCOL:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDY	#0
	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	LPC14
	ORA	#128
	STA	NMI_PTR+1	;IN EITHER CASE, MAKE IT BE IN ROM
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
LPC14:	LDY	#0
LPC15:	LDA	(NMI_PTR),Y	;GET THE BYTE
	STA	TMP_NMI6,X	;QUE IT UP
	INX
	DEC	TMP_NMI1
	BEQ	LDC35		;SHARE SOME ENDING CODE
	LDY	#2
	JMP	LPC15
.endif	
	;', `
.ifndef BLOCKMODE
	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	LPC14
	ORA	#128
	STA	NMI_PTR+1	;IN EITHER CASE, MAKE IT BE IN ROM
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
LPC14:	LDY	#0
LPC15:	LDA	#0
	STA	SCNBUF,X	;SET HORIZONTAL/VERTICAL WRITE FLAG
	INX
	LDA	TMP_NMI4
	STA	SCNBUF,X
	INX
	LDA	TMP_NMI3
	STA	SCNBUF,X
	INX
	LDA	#1		;WE ALWAYS JUST QUE 1 IN THIS CASE
	STA	SCNBUF,X
	INX

	LDA	(NMI_PTR),Y	;GET THE BYTE
	STA	SCNBUF,X		;QUE IT UP
	INX
	TYA
	CLC
	ADC	TMP_NMI2	;UPDATE INDEX WITHIN OUR DATA
	TAY
	BCC	LPC20
	INC	NMI_PTR+1

;WRAP THE PALETTE RAM INDEX.  WE JUST NEED TO WRAP AROUND IN THIS BUFFER.

LPC20:	LDA	TMP_NMI3
	CLC
	ADC	#8		;SKIP TO NEXT PALETTE ROW
	STA	TMP_NMI3

 	DEC	TMP_NMI1
 	BNE	LPC15
	JMP	LDC35		;SHARE A HAPPY ENDING	

	.endif ;' )

;THIS SUB IS USED TO FETCH ROW DATA FROM A BACKGROUND BLOCK DIRECTLY
;INTO SCNBUF.  ON ENTRY:
;(NMI_PTR) POINTS TO THE FIRST BYTE TO FETCH.  BIT 8000H SET IF LOW PAGE,
;  	OFF IF HIGH PAGE (THAT BIT IS PRESERVED ON RETURN).
;TMP_NMI1 HAS THE COUNT TO FETCH.  
;X HAS THE PLACE TO PUT IT INTO SCNBUF. 
;
;ON RETURN:  THE DATA IS IN SCNBUF, X IS UPDATED AND SO IS NMI_PTR.

LOADROW:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	LDR15
	ORA	#128
	STA	NMI_PTR+1
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
LDR15:	CLC
	LDY	#0
LDR20:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCNBUF,X	;QUE IT UP
	INX
	LDA	NMI_PTR
	ADC	#1		;SKIP TO NEXT COL IN DATA
	STA	NMI_PTR
	BCC	LDR30
	INC	NMI_PTR+1
	CLC
LDR30:	DEC	TMP_NMI1
	BNE	LDR20
	JMP	LDC35

	.endif ;' )

;THIS SUB IS USED TO SHIFT ROW DATA FROM A BACKGROUND BLOCK DIRECTLY
;INTO SCNBUF.  THIS IS NECESSARY WHEN THE SCREEN PAGE IS VERTICALLY
;AN ODD VALUE.  LOADROW HAS ALREADY PUT SOME THERE AND WE ARE SHIFTING
;NEW DATA UP INTO IT NIBBLE WISE. ON ENTRY:
;(NMI_PTR) POINTS TO THE FIRST BYTE TO FETCH.  BIT 8000H SET IF LOW PAGE,
;  	OFF IF HIGH PAGE (THAT BIT IS PRESERVED ON RETURN).
;TMP_NMI1 HAS THE COUNT TO FETCH.  
;X HAS THE PLACE TO SHIFT IT INTO SCNBUF. 
;
;ON RETURN:  THE DATA IS IN SCNBUF, X IS UPDATED AND SO IS NMI_PTR.

SHIFTROW:

.ifdef BLOCKMODE ;IFDEF( `BLOCKMODE', `		

	LDA	NMI_PTR+1	;GET HIGH OFFSET TO MAKE A PAGE
	PHA
	BMI	SHR15
	ORA	#128
	STA	NMI_PTR+1
	LDA	ALTBANK
	LDY	ALTINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
SHR15:	LDY	#0
SHR20:	LDA	(NMI_PTR),Y	;GET A BYTE
	ROR	A	
	ROR	SCNBUF,X	
	ROR	A	
	ROR	SCNBUF,X	
	ROR	A	
	ROR	SCNBUF,X	
	ROR	A	
	ROR	SCNBUF,X	;SHIFT THE TOP NIBBLE INTO THE EXISTING BYTE
	INX
	LDA	NMI_PTR
	CLC
	ADC	#1		;SKIP TO NEXT COL IN DATA
	STA	NMI_PTR
	BCC	SHR30
	INC	NMI_PTR+1
SHR30:	DEC	TMP_NMI1
	BNE	SHR20
	JMP	LDC35

	.endif ;' )

;ENTER HERE WITH THE DESIRED PAGETAB VALUE IN A AND INDEX IN Y.

;THE TABLE IS NEEDED BECAUSE OUR ROM CARTRIDGE DOES NOT DECODE THE ROM AREA.
;ANY WRITE TO ROM TRIGGERS THE LS377 PAGING PORT.  SINCE A WRITE ALSO 
;TRIGGERS A ROM READ (WR DOES NOT QUALIFY ROM) WE NEED TO WRITE TO AN AREA
;OF ROM THAT RETURNS THE SAME VALUE WE ARE WRITING.
.segment "COMMONCODE"
SELPAGE:
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
	RTS

PAGETAB:
.byte 12,13
.byte 28,29
.byte 44,45
.byte 60,61
.byte 76,77
.byte 92,93
.byte 108,109
.byte 124,125

;THIS NMI VECTOR IS NEEDED TO INSURE WE CAN GET AN NMI INTERRUPT WHILE
;WE ARE GETTING DATA FROM THE SECOND PAGE.

PNMI:
	PHA 
	TYA
	PHA
	LDA	BACKBANK
	STA	NMIBANK
	LDA	BACKINDX
	STA	NMIINDX		;SET RETURN POINT
	LDA	BACKBANK
	LDY	BACKINDX
.ifdef ROMVER	;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y 
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
	JSR	NMI		;CALL THE NMI LOGIC
	LDA	NMIBANK
	LDY	NMIINDX
.ifdef ROMVER;IFDEF( `ROMVER', `		
	STA	PAGETAB,Y
.endif;	', `
.ifndef ROMVER
	STA	-2	  
.endif;	')
	PLA
	TAY
	PLA
IRQRTI:
	RTI	

;THIS BOOT VECTOR IS NEEDED TO INSURE THAT WE DON'T CRASH IF WE 
;HAVE A PAGED VERSION.

PBOOT: 	
	LDX	#$FF
	TXS			;SET UP THE STACK
	LDA	#12
	STA	PAGETAB
	JMP	BOOT

;.ORG	$FFFA
.segment "VECTORS"
;HERE ARE THE INTERRUPT AND BOOT VECTORS.  

	.word	PNMI		;NMI INTERRUPT (VERTICAL RETRACE INT)
	.word	PBOOT		;BOOT VECTOR
	.word	IRQRTI		;IRQ VECTOR
        
.export BOOT, NMI, LDC35, CMDLEN